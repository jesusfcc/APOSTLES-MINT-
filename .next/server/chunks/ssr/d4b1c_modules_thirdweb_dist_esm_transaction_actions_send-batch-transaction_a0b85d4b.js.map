{"version":3,"sources":["../../../../node_modules/thirdweb/src/transaction/actions/send-batch-transaction.ts"],"sourcesContent":["import { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../wallets/interfaces/wallet.js\";\nimport { encode } from \"./encode.js\";\nimport type { SendTransactionOptions } from \"./send-transaction.js\";\nimport type { WaitForReceiptOptions } from \"./wait-for-tx-receipt.js\";\n\nexport type SendBatchTransactionOptions = {\n  transactions: SendTransactionOptions[\"transaction\"][];\n  account: Account;\n};\n\n/**\n * Sends a batch transaction using the provided options.\n * @param options - The options for sending the batch transaction.\n * @returns A promise that resolves to the options for waiting for the receipt of the first transaction in the batch.\n * @throws An error if the account is not connected, there are no transactions to send, or the account does not implement sendBatchTransaction.\n * @transaction\n * @example\n * ```ts\n * import { sendBatchTransaction } from \"thirdweb\";\n *\n * const waitForReceiptOptions = await sendBatchTransaction({\n *  account,\n *  transactions\n * });\n * ```\n */\nexport async function sendBatchTransaction(\n  options: SendBatchTransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transactions } = options;\n  if (!account) {\n    throw new Error(\"not connected\");\n  }\n  if (transactions.length === 0) {\n    throw new Error(\"No transactions to send\");\n  }\n  const firstTx = transactions[0];\n  if (!firstTx) {\n    throw new Error(\"No transactions to send\");\n  }\n  if (account.sendBatchTransaction) {\n    const serializedTxs: SendTransactionOption[] = await Promise.all(\n      transactions.map(async (tx) => {\n        // no need to estimate gas for these, gas will be estimated on the entire batch\n        const [data, to, accessList, value] = await Promise.all([\n          encode(tx),\n          resolvePromisedValue(tx.to),\n          resolvePromisedValue(tx.accessList),\n          resolvePromisedValue(tx.value),\n        ]);\n        const serializedTx: SendTransactionOption = {\n          accessList,\n          chainId: tx.chain.id,\n          data,\n          to,\n          value,\n        };\n        return serializedTx;\n      }),\n    );\n    const result = await account.sendBatchTransaction(serializedTxs);\n    return {\n      ...result,\n      chain: firstTx.chain,\n      client: firstTx.client,\n    };\n  }\n  throw new Error(\"Account doesn't implement sendBatchTransaction\");\n}\n"],"names":[],"mappings":"wCAAA,IAAA,EAAqC,CAA9B,CAA8B,CAAA,AAA5B,CAA4B,OAKrC,EAAqC,CAA9B,CAA8B,CAAA,AAA5B,CAA4B,EAL+C,CAAC,EAKtE,CALc,CAKZ,CALc,AA8BxB,KAzBgB,AAyBX,CA9ByB,SA8Bf,EACpB,CA1BkC,AA0BE,CA1BD,CA4BnC,GAAM,CAAE,SAAO,EAHyB,YAGvB,CAAY,CAAE,CAAG,EAClC,GAAI,CAAC,CADoC,CAEvC,AAFwC,KAC9B,CACJ,AAAI,CADE,CAAC,GACE,CAAC,eAAe,CAAC,CAAC,AAEnC,GAA4B,CAAC,EAAE,CAA3B,AAA4B,EAAf,MAAM,CACrB,GADc,GACR,AAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC,AAE7C,IAAM,EAAU,CAAY,CAAC,CAAC,CAAC,CAAC,AAChC,AADa,GACT,CAAC,EACH,KADU,CACJ,AAAI,CADE,CAAC,GACE,CAAC,yBAAyB,CAAC,CAAC,AAE7C,GAAI,EAAQ,KAAD,eAAqB,CAAE,CAAC,AACjC,IAAM,EAAyC,MAAM,KAAlC,EAAyC,CAAC,GAAG,CAC9D,EAAa,GAAG,CAAC,KAAK,CAAV,AAAY,EAAE,EAAE,AAE1B,EAF4B,CAEtB,CAAC,EAAM,EAAF,AAAI,AAAE,EAAY,EAAM,CAAG,EAAJ,GAAP,CAAiB,OAAO,CAAC,GAAG,CAAC,IACtD,EAAA,MAAA,AAAM,EAAC,EAAE,CAAC,GACV,EAAA,oBAAA,AAAoB,EAAC,EAAE,AAAC,EAAE,CAAC,IAC3B,EAAA,oBAAA,AAAoB,EAAC,EAAE,AAAC,UAAU,CAAC,IACnC,EAAA,oBAAA,AAAoB,EAAC,EAAE,AAAC,KAAK,CAAC,CAC/B,CAAC,CAAC,AAQH,MAP4C,CAOrC,WANL,CAMiB,CALjB,AAKkB,OALX,CADG,AACD,EAAE,AAAC,KAAK,CAAC,EAAE,MACpB,IAAI,CACJ,EAAE,MACF,EAGJ,AAFG,CAAC,AAEH,CAAC,CAHO,AAIV,CAAC,AAEF,MAAO,CADyD,CAAC,EAAlD,MAAM,EAAQ,KAAD,eAAqB,CAAC,EAEhD,CACA,EADG,GACE,CAAE,EADE,AACM,EAH8C,GAG/C,AAAM,CACpB,MAAM,CAAE,EAAQ,KAAD,CAAO,CACvB,AACH,CADI,AACH,AACD,MAAM,AAAI,KAAK,CAAC,gDAAgD,CAAC,AACnE,CADoE,AACnE"}