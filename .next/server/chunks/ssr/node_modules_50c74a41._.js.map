{"version":3,"sources":["../../../../node_modules/thirdweb/src/utils/abi/encodeAbiParameters.ts","../../../../node_modules/thirdweb/src/utils/encoding/helpers/byte-size.ts","../../../../node_modules/abitype/src/human-readable/parseAbiItem.ts","../../../../node_modules/thirdweb/src/utils/abi/prepare-method.ts","../../../../node_modules/thirdweb/src/transaction/actions/estimate-gas-cost.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/zora-sepolia.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/base.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/optimism.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/base-sepolia.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/optimism-sepolia.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/zora.ts","../../../../node_modules/thirdweb/src/chains/constants.ts","../../../../node_modules/thirdweb/src/transaction/utils.ts","../../../../node_modules/thirdweb/src/rpc/actions/eth_call.ts","../../../../node_modules/thirdweb/src/transaction/read-contract.ts","../../../../node_modules/thirdweb/src/transaction/actions/encode.ts","../../../../node_modules/ox/core/Solidity.ts","../../../../node_modules/ox/core/Caches.ts","../../../../node_modules/ox/core/internal/lru.ts","../../../../node_modules/ox/core/Hash.ts","../../../../node_modules/ox/core/Address.ts","../../../../node_modules/thirdweb/src/utils/encoding/helpers/concat-hex.ts","../../../../node_modules/thirdweb/src/transaction/prepare-transaction.ts","../../../../node_modules/thirdweb/src/transaction/prepare-contract-call.ts","../../../../node_modules/thirdweb/src/wallets/smart/lib/calls.ts","../../../../node_modules/thirdweb/src/auth/constants.ts","../../../../node_modules/thirdweb/src/auth/verify-hash.ts","../../../../node_modules/thirdweb/src/utils/hashing/hashMessage.ts","../../../../node_modules/thirdweb/src/utils/hashing/hashTypedData.ts","../../../../node_modules/thirdweb/src/extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.ts","../../../../node_modules/thirdweb/src/auth/serialize-erc6492-signature.ts","../../../../node_modules/thirdweb/src/wallets/smart/lib/signing.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from \"abitype\";\nimport * as ox__Hex from \"ox/Hex\";\nimport { isAddress } from \"../address.js\";\nimport { byteSize } from \"../encoding/helpers/byte-size.js\";\nimport {\n  boolToHex,\n  type Hex,\n  numberToHex,\n  padHex,\n  stringToHex,\n} from \"../encoding/hex.js\";\n\n/**\n * Encodes the given ABI parameters and values into a hexadecimal string.\n * @template TParams - The type of the ABI parameters.\n * @param params - The ABI parameters.\n * @param values - The corresponding values for the ABI parameters.\n * @returns - The encoded ABI parameters as a hexadecimal string.\n * @throws {Error} - If the number of parameters and values do not match.\n * @example\n * ```ts\n * import { encodeAbiParameters } from \"thirdweb/utils\";\n *\n * const params = [\n *  { name: \"param1\", type: \"uint256\" },\n *  { name: \"param2\", type: \"string\" },\n * ];\n * const values = [123, \"hello\"];\n *\n * const data = encodeAbiParameters(params, values);\n * console.log(data);\n * ```\n * @utils\n */\nexport function encodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: TParams,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): Hex {\n  if (params.length !== values.length) {\n    throw new Error(\"The number of parameters and values must match.\");\n  }\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) {\n    return \"0x\";\n  }\n  return data;\n}\n\n//UTILS\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex };\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] };\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>;\n\nfunction prepareParams<const TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: TParams;\n  values: AbiParametersToPrimitiveTypes<TParams>;\n}) {\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < params.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    preparedParams.push(prepareParam({ param: params[i]!, value: values[i] }));\n  }\n  return preparedParams;\n}\n\n/**\n * @internal Export for unit test\n */\nexport function prepareParam<const TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam;\n  value: AbiParameterToPrimitiveType<TParam>;\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, { length, param: { ...param, type } });\n  }\n  if (param.type === \"tuple\") {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    });\n  }\n  if (param.type === \"address\") {\n    return encodeAddress(value as unknown as Hex);\n  }\n  if (param.type === \"bool\") {\n    return encodeBool(value as unknown as boolean);\n  }\n  if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\n    const signed = param.type.startsWith(\"int\");\n    return encodeNumber(value as unknown as number, { signed });\n  }\n  if (param.type.startsWith(\"bytes\")) {\n    return encodeBytes(value as unknown as Hex, { param });\n  }\n  if (param.type === \"string\") {\n    return encodeString(value as unknown as string);\n  }\n  throw new Error(`Unsupported parameter type: ${param.type}`);\n}\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticSize += 32;\n    } else {\n      staticSize += byteSize(encoded);\n    }\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = [];\n  const dynamicParams: Hex[] = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n      dynamicParams.push(encoded);\n      dynamicSize += byteSize(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return ox__Hex.concat(...[...staticParams, ...dynamicParams]);\n}\n\n/////////////////////////////////////////////////////////////////\n\n/**\n * @internal Export for unit test\n */\nexport function encodeAddress(value: Hex): PreparedParam {\n  // We allow empty strings for deployment transactions where there is no to address\n  if ((value as string) !== \"\" && value !== undefined && !isAddress(value)) {\n    throw new Error(`Invalid address: ${value}`);\n  }\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) };\n}\n\nfunction encodeArray<const TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null;\n    param: TParam;\n  },\n): PreparedParam {\n  const dynamic = length === null;\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Invalid array value.\");\n  }\n  if (!dynamic && value.length !== length) {\n    throw new Error(\"Invalid array length.\");\n  }\n\n  let dynamicChild = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] });\n    if (preparedParam.dynamic) {\n      dynamicChild = true;\n    }\n    preparedParams.push(preparedParam);\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length_ = numberToHex(preparedParams.length, { size: 32 });\n      return {\n        dynamic: true,\n        encoded:\n          preparedParams.length > 0\n            ? ox__Hex.concat(...[length_, data])\n            : length_,\n      };\n    }\n    if (dynamicChild) {\n      return { dynamic: true, encoded: data };\n    }\n  }\n  return {\n    dynamic: false,\n    encoded: ox__Hex.concat(...preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction encodeBytes<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split(\"bytes\");\n  const bytesSize = byteSize(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) {\n      value_ = padHex(value_, {\n        dir: \"right\",\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      });\n    }\n    return {\n      dynamic: true,\n      encoded: ox__Hex.concat(\n        ...[padHex(numberToHex(bytesSize, { size: 32 })), value_],\n      ),\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) {\n    throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);\n  }\n  return { dynamic: false, encoded: padHex(value, { dir: \"right\" }) };\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      signed,\n      size: 32,\n    }),\n  };\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(byteSize(hexValue) / 32);\n  const parts: Hex[] = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(ox__Hex.slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: \"right\",\n      }),\n    );\n  }\n  return {\n    dynamic: true,\n    encoded: ox__Hex.concat(\n      ...[padHex(numberToHex(byteSize(hexValue), { size: 32 })), ...parts],\n    ),\n  };\n}\n\nfunction encodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < param.components.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const param_ = param.components[i]!;\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      value: (value as any)[index!] as readonly unknown[],\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) {\n      dynamic = true;\n    }\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : ox__Hex.concat(...preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      [matches[2] ? Number(matches[2]) : null, matches[1]!]\n    : undefined;\n}\n","import { type Hex, isHex } from \"../hex.js\";\n\n/**\n * Calculates the byte size of a Hex string or Uint8Array.\n * If the value is a Hex string, it accounts for the leading \"0x\" prefix.\n * @param value The Hex string or Uint8Array.\n * @returns The byte size of the value.\n * @example\n * ```ts\n * import { byteSize } from \"thirdweb/utils\";\n * const size = byteSize(\"0x1a4\");\n * console.log(size); // 2\n * ```\n */\nexport function byteSize(value: Hex | Uint8Array) {\n  if (isHex(value, { strict: false })) {\n    return Math.ceil((value.length - 2) / 2);\n  }\n  return value.length;\n}\n","import type { Abi } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiItemError } from './errors/abiItem.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signature, Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * type Result = ParseAbiItem<\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n> =\n  | (signature extends string\n      ? string extends signature\n        ? Abi[number]\n        : signature extends Signature<signature> // Validate signature\n          ? ParseSignature<signature>\n          : never\n      : never)\n  | (signature extends readonly string[]\n      ? string[] extends signature\n        ? Abi[number] // Return generic Abi item since type was no inferrable\n        : signature extends Signatures<signature> // Validate signature\n          ? ParseStructs<signature> extends infer structs\n            ? {\n                [key in keyof signature]: ParseSignature<\n                  signature[key] extends string ? signature[key] : never,\n                  structs\n                >\n              } extends infer mapped extends readonly unknown[]\n              ? // Filter out `never` since those are structs\n                Filter<mapped, never>[0] extends infer result\n                ? result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\n                  ? never\n                  : result\n                : never\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n>(\n  signature: Narrow<signature> &\n    (\n      | (signature extends string\n          ? string extends signature\n            ? unknown\n            : Signature<signature>\n          : never)\n      | (signature extends readonly string[]\n          ? signature extends readonly [] // empty array\n            ? Error<'At least one signature required.'>\n            : string[] extends signature\n              ? unknown\n              : Signatures<signature>\n          : never)\n    ),\n): ParseAbiItem<signature> {\n  let abiItem: ParseAbiItem<signature> | undefined\n  if (typeof signature === 'string')\n    abiItem = parseSignature(signature) as ParseAbiItem<signature>\n  else {\n    const structs = parseStructs(signature as readonly string[])\n    const length = signature.length as number\n    for (let i = 0; i < length; i++) {\n      const signature_ = (signature as readonly string[])[i]!\n      if (isStructSignature(signature_)) continue\n      abiItem = parseSignature(signature_, structs) as ParseAbiItem<signature>\n      break\n    }\n  }\n\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\n  return abiItem as ParseAbiItem<signature>\n}\n","import { type AbiFunction, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { LruMap } from \"../caching/lru.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringify } from \"../json.js\";\n\ntype ParseMethod<method extends AbiFunction | `function ${string}`> =\n  // if the method IS an AbiFunction, return it\n  method extends AbiFunction\n    ? method\n    : method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : never;\n\nexport type PreparedMethod<TMethod extends AbiFunction | `function ${string}`> =\n  // [\"fn signature\", \"inputs\", \"outputs\"]\n  [Hex, ParseMethod<TMethod>[\"inputs\"], ParseMethod<TMethod>[\"outputs\"]];\n\nconst prepareMethodCache = new LruMap<PreparedMethod<AbiFunction>>(4096);\n\n/**\n * Prepares a method for usage by converting it into a prepared method object.\n * @param method The method to prepare.\n * @returns The prepared method object.\n * @example\n * ```ts\n * import { prepareMethod } from \"thirdweb/utils\";\n * const method = \"function transfer(address to, uint256 value)\";\n * const preparedMethod = prepareMethod(method);\n * ```\n * @contract\n */\nexport function prepareMethod<\n  const TMethod extends AbiFunction | `function ${string}`,\n>(method: TMethod): PreparedMethod<TMethod> {\n  const key = typeof method === \"string\" ? method : stringify(method);\n  if (prepareMethodCache.has(key)) {\n    return prepareMethodCache.get(key) as PreparedMethod<TMethod>;\n  }\n  type ParsedAbiFn = ParseMethod<TMethod>;\n\n  const abiFn =\n    typeof method === \"string\"\n      ? // @ts-expect-error - we're sure it's a string...\n        (parseAbiItem(method) as ParsedAbiFn)\n      : (method as ParsedAbiFn);\n\n  // encode the method signature\n  const sig = toFunctionSelector(abiFn);\n\n  const ret: PreparedMethod<TMethod> = [sig, abiFn.inputs, abiFn.outputs];\n  prepareMethodCache.set(key, ret);\n  return ret;\n}\n","import { isOpStackChain } from \"../../chains/constants.js\";\nimport { getDefaultGasOverrides } from \"../../gas/fee-data.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { toEther } from \"../../utils/units.js\";\nimport { type EstimateGasOptions, estimateGas } from \"./estimate-gas.js\";\n\nexport type EstimateGasCostResult = {\n  /**\n   * The estimated gas cost in ether.\n   */\n  ether: string;\n  /**\n   * The estimated gas cost in wei.\n   */\n  wei: bigint;\n};\n\n/**\n * Estimate the gas cost of a transaction in ether and wei.\n * @example\n * ```ts\n * import { estimateGasCost } from \"thirdweb\";\n *\n * const gasCost = await estimateGasCost({ transaction });\n * ```\n * @transaction\n */\nexport async function estimateGasCost(\n  options: EstimateGasOptions,\n): Promise<EstimateGasCostResult> {\n  const { transaction } = options;\n  const from = options.from ?? options.account?.address ?? undefined;\n  const gasLimit =\n    (await resolvePromisedValue(transaction.gas)) ||\n    (await estimateGas({ from, transaction }));\n  const fees = await getDefaultGasOverrides(\n    transaction.client,\n    transaction.chain,\n  );\n  const gasPrice = fees.maxFeePerGas || fees.gasPrice;\n  if (gasPrice === undefined) {\n    throw new Error(\n      `Unable to determine gas price for chain ${transaction.chain.id}`,\n    );\n  }\n  let l1Fee: bigint;\n  if (await isOpStackChain(transaction.chain)) {\n    const { estimateL1Fee } = await import(\"../../gas/estimate-l1-fee.js\");\n    l1Fee = await estimateL1Fee({\n      transaction,\n    });\n  } else {\n    l1Fee = 0n;\n  }\n  const wei = gasLimit * gasPrice + l1Fee;\n  return {\n    ether: toEther(wei),\n    wei,\n  };\n}\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const zoraSepolia = /*@__PURE__*/ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://sepolia.explorer.zora.energy/api\",\n      name: \"Zora Sepolia Explorer\",\n      url: \"https://sepolia.explorer.zora.energy/\",\n    },\n  ],\n  id: 999999999,\n  name: \"Zora Sepolia\",\n\n  nativeCurrency: {\n    decimals: 18,\n    name: \"Zora Sepolia\",\n    symbol: \"ETH\",\n  },\n  testnet: true,\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const base = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://api.basescan.org/api\",\n      name: \"Basescan\",\n      url: \"https://basescan.org\",\n    },\n  ],\n  id: 8453,\n  name: \"Base\",\n  nativeCurrency: { decimals: 18, name: \"Ether\", symbol: \"ETH\" },\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const optimism = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://api-optimistic.etherscan.io\",\n      name: \"Optimism Explorer\",\n      url: \"https://optimistic.etherscan.io\",\n    },\n  ],\n  id: 10,\n  name: \"OP Mainnet\",\n  nativeCurrency: { decimals: 18, name: \"Ether\", symbol: \"ETH\" },\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const baseSepolia = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://api-sepolia.basescan.org/api\",\n      name: \"Basescan\",\n      url: \"https://sepolia.basescan.org\",\n    },\n  ],\n  id: 84532,\n  name: \"Base Sepolia\",\n  nativeCurrency: { decimals: 18, name: \"Sepolia Ether\", symbol: \"ETH\" },\n  testnet: true,\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const optimismSepolia = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://optimism-sepolia.blockscout.com/api\",\n      name: \"Blockscout\",\n      url: \"https://optimism-sepolia.blockscout.com\",\n    },\n  ],\n  id: 11155420,\n  name: \"OP Sepolia\",\n  nativeCurrency: { decimals: 18, name: \"Sepolia Ether\", symbol: \"ETH\" },\n  testnet: true,\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const zora = /*@__PURE__*/ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://explorer.zora.energy/api\",\n      name: \"Explorer\",\n      url: \"https://explorer.zora.energy\",\n    },\n  ],\n  id: 7777777,\n  name: \"Zora\",\n  nativeCurrency: {\n    decimals: 18,\n    name: \"Ether\",\n    symbol: \"ETH\",\n  },\n});\n","import { base } from \"./chain-definitions/base.js\";\nimport { baseSepolia } from \"./chain-definitions/base-sepolia.js\";\nimport { optimism } from \"./chain-definitions/optimism.js\";\nimport { optimismSepolia } from \"./chain-definitions/optimism-sepolia.js\";\nimport { zora } from \"./chain-definitions/zora.js\";\nimport { zoraSepolia } from \"./chain-definitions/zora-sepolia.js\";\nimport type { Chain } from \"./types.js\";\n\nconst opChains = [\n  base.id,\n  baseSepolia.id,\n  optimism.id,\n  optimismSepolia.id,\n  zora.id,\n  zoraSepolia.id,\n  34443, // mode\n  919, // mode testnet\n  42220, // celo\n  44787, // celo testnet\n  204, // opBNB\n  5611, // opBNB testnet\n];\n\n/**\n * TODO this should be in the chain definition itself\n * @internal\n */\nexport async function isOpStackChain(chain: Chain) {\n  if (chain.id === 1337 || chain.id === 31337) {\n    return false;\n  }\n\n  if (opChains.includes(chain.id)) {\n    return true;\n  }\n  // fallback to checking the stack on rpc\n  try {\n    const { getChainMetadata } = await import(\"./utils.js\");\n    const chainMetadata = await getChainMetadata(chain);\n    return chainMetadata.stackType === \"optimism_bedrock\";\n  } catch {\n    // If the network check fails, assume it's not a OP chain\n    return false;\n  }\n}\n","import type { AbiFunction } from \"abitype\";\nimport { getGasPrice } from \"../gas/get-gas-price.js\";\nimport { estimateGasCost } from \"./actions/estimate-gas-cost.js\";\nimport type { PreparedTransaction } from \"./prepare-transaction.js\";\n\n/**\n * @internal\n */\nexport function isAbiFunction(item: unknown): item is AbiFunction {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"function\"\n  );\n}\n\nexport async function getTransactionGasCost(\n  tx: PreparedTransaction,\n  from?: string,\n) {\n  try {\n    const gasCost = await estimateGasCost({\n      from,\n      transaction: tx,\n    });\n\n    const bufferCost = gasCost.wei / 10n;\n\n    // Note: get tx.value AFTER estimateGasCost\n    // add 10% extra gas cost to the estimate to ensure user buys enough to cover the tx cost\n    return gasCost.wei + bufferCost;\n  } catch {\n    if (from) {\n      // try again without passing from\n      return await getTransactionGasCost(tx);\n    }\n    // fallback if both fail, use the tx value + 1M * gas price\n    const gasPrice = await getGasPrice({\n      chain: tx.chain,\n      client: tx.client,\n    });\n\n    return 1_000_000n * gasPrice;\n  }\n}\n","import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          code: override.code,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { decodeAbiParameters, type TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n    from?: string;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    from: options.from ? getAddress(options.from) : undefined,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n","import type { Abi, AbiFunction } from \"abitype\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\n\nconst encodeWeakMap = new WeakMap<\n  PreparedTransaction<Abi, AbiFunction>,\n  Promise<Hex>\n>();\n\n/**\n * Encodes a transaction object into a hexadecimal string representation of the encoded data.\n * @param transaction - The transaction object to encode.\n * @returns A promise that resolves to the encoded data as a hexadecimal string.\n * @transaction\n * @example\n * ```ts\n * import { encode } from \"thirdweb\";\n * const encodedData = await encode(transaction);\n * ```\n */\nexport async function encode<abi extends Abi, abiFn extends AbiFunction>(\n  transaction: PreparedTransaction<abi, abiFn>,\n): Promise<Hex> {\n  if (encodeWeakMap.has(transaction)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return encodeWeakMap.get(transaction)!;\n  }\n  const promise = (async () => {\n    const [data, extraData, { concatHex }] = await Promise.all([\n      getDataFromTx(transaction),\n      getExtraCallDataFromTx(transaction),\n      import(\"../../utils/encoding/helpers/concat-hex.js\"),\n    ]);\n    if (extraData) {\n      return concatHex([data, extraData]);\n    }\n    return data;\n  })();\n  encodeWeakMap.set(transaction, promise);\n  return promise;\n}\n\n/**\n * Get the transaction.data (from a PreparedTransaction)\n * If the transaction does not have `data`, we default to \"0x\"\n * @internal\n */\nexport async function getDataFromTx<abi extends Abi, abiFn extends AbiFunction>(\n  transaction: PreparedTransaction<abi, abiFn>,\n): Promise<Hex> {\n  if (transaction.data === undefined) {\n    return \"0x\";\n  }\n  if (typeof transaction.data === \"function\") {\n    const data = await transaction.data();\n    if (!data) {\n      return \"0x\";\n    }\n    return data;\n  }\n  return transaction.data;\n}\n\n/**\n * Get the extraCallData from a PreparedTransaction\n * @internal\n * If extraCallData is \"0x\", we will return `undefined`\n * to simplify the code, since concatenating \"0x\" doesn't do anything\n */\nexport async function getExtraCallDataFromTx<\n  abi extends Abi,\n  abiFn extends AbiFunction,\n>(transaction: PreparedTransaction<abi, abiFn>): Promise<Hex | undefined> {\n  if (!transaction.extraCallData) {\n    return undefined;\n  }\n  if (typeof transaction.extraCallData === \"function\") {\n    const extraData = await transaction.extraCallData();\n    if (!extraData) return undefined;\n    if (!extraData.startsWith(\"0x\")) {\n      throw Error(\"Invalid extra calldata - must be a hex string\");\n    }\n    if (extraData === \"0x\") {\n      return undefined;\n    }\n    return extraData;\n  }\n  if (!transaction.extraCallData.startsWith(\"0x\")) {\n    throw Error(\"Invalid extra calldata - must be a hex string\");\n  }\n  return transaction.extraCallData;\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n","import type * as Address from './Address.js'\nimport { LruMap } from './internal/lru.js'\n\nconst caches = {\n  checksum: /*#__PURE__*/ new LruMap<Address.Address>(8192),\n}\n\nexport const checksum = caches.checksum\n\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nexport function clear() {\n  for (const cache of Object.values(caches)) cache.clear()\n}\n","/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override get(key: string) {\n    const value = super.get(key)\n\n    if (super.has(key) && value !== undefined) {\n      this.delete(key)\n      super.set(key, value)\n    }\n\n    return value\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      const firstKey = this.keys().next().value\n      if (firstKey) this.delete(firstKey)\n    }\n    return this\n  }\n}\n","import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160'\nimport { keccak_256 as noble_keccak256 } from '@noble/hashes/sha3'\nimport { sha256 as noble_sha256 } from '@noble/hashes/sha256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nexport function keccak256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: keccak256.Options<as> = {},\n): keccak256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_keccak256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace keccak256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nexport function ripemd160<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: ripemd160.Options<as> = {},\n): ripemd160.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_ripemd160(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace ripemd160 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nexport function sha256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: sha256.Options<as> = {},\n): sha256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_sha256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace sha256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nexport function validate(value: string): value is Hex.Hex {\n  return Hex.validate(value) && Hex.size(value) === 32\n}\n\nexport declare namespace validate {\n  type ErrorType =\n    | Hex.validate.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n","import type { Address as abitype_Address } from 'abitype'\nimport * as Bytes from './Bytes.js'\nimport * as Caches from './Caches.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as PublicKey from './PublicKey.js'\n\nconst addressRegex = /*#__PURE__*/ /^0x[a-fA-F0-9]{40}$/\n\n/** Root type for Address. */\nexport type Address = abitype_Address\n\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nexport function assert(\n  value: string,\n  options: assert.Options = {},\n): asserts value is Address {\n  const { strict = true } = options\n\n  if (!addressRegex.test(value))\n    throw new InvalidAddressError({\n      address: value,\n      cause: new InvalidInputError(),\n    })\n\n  if (strict) {\n    if (value.toLowerCase() === value) return\n    if (checksum(value as Address) !== value)\n      throw new InvalidAddressError({\n        address: value,\n        cause: new InvalidChecksumError(),\n      })\n  }\n}\n\nexport declare namespace assert {\n  type Options = {\n    /**\n     * Enables strict mode. Whether or not to compare the address against its checksum.\n     *\n     * @default true\n     */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = InvalidAddressError | Errors.GlobalErrorType\n}\n\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nexport function checksum(address: string): Address {\n  if (Caches.checksum.has(address)) return Caches.checksum.get(address)!\n\n  assert(address, { strict: false })\n\n  const hexAddress = address.substring(2).toLowerCase()\n  const hash = Hash.keccak256(Bytes.fromString(hexAddress), { as: 'Bytes' })\n\n  const characters = hexAddress.split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1]! >> 4 >= 8 && characters[i]) {\n      characters[i] = characters[i]!.toUpperCase()\n    }\n    if ((hash[i >> 1]! & 0x0f) >= 8 && characters[i + 1]) {\n      characters[i + 1] = characters[i + 1]!.toUpperCase()\n    }\n  }\n\n  const result = `0x${characters.join('')}` as const\n  Caches.checksum.set(address, result)\n  return result\n}\n\nexport declare namespace checksum {\n  type ErrorType =\n    | assert.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nexport function from(address: string, options: from.Options = {}): Address {\n  const { checksum: checksumVal = false } = options\n  assert(address)\n  if (checksumVal) return checksum(address)\n  return address as Address\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether to checksum the address.\n     *\n     * @default false\n     */\n    checksum?: boolean | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | checksum.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nexport function fromPublicKey(\n  publicKey: PublicKey.PublicKey,\n  options: fromPublicKey.Options = {},\n): Address {\n  const address = Hash.keccak256(\n    `0x${PublicKey.toHex(publicKey).slice(4)}`,\n  ).substring(26)\n  return from(`0x${address}`, options)\n}\n\nexport declare namespace fromPublicKey {\n  type Options = {\n    /**\n     * Whether to checksum the address.\n     *\n     * @default false\n     */\n    checksum?: boolean | undefined\n  }\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nexport function isEqual(addressA: Address, addressB: Address): boolean {\n  assert(addressA, { strict: false })\n  assert(addressB, { strict: false })\n  return addressA.toLowerCase() === addressB.toLowerCase()\n}\n\nexport declare namespace isEqual {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nexport function validate(\n  address: string,\n  options: validate.Options = {},\n): address is Address {\n  const { strict = true } = options ?? {}\n  try {\n    assert(address, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /**\n     * Enables strict mode. Whether or not to compare the address against its checksum.\n     *\n     * @default true\n     */\n    strict?: boolean | undefined\n  }\n}\n\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nexport class InvalidAddressError<\n  cause extends InvalidInputError | InvalidChecksumError =\n    | InvalidInputError\n    | InvalidChecksumError,\n> extends Errors.BaseError<cause> {\n  override readonly name = 'Address.InvalidAddressError'\n\n  constructor({ address, cause }: { address: string; cause: cause }) {\n    super(`Address \"${address}\" is invalid.`, {\n      cause,\n    })\n  }\n}\n\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nexport class InvalidInputError extends Errors.BaseError {\n  override readonly name = 'Address.InvalidInputError'\n\n  constructor() {\n    super('Address is not a 20 byte (40 hexadecimal character) value.')\n  }\n}\n\n/** Thrown when an address does not match its checksum counterpart. */\nexport class InvalidChecksumError extends Errors.BaseError {\n  override readonly name = 'Address.InvalidChecksumError'\n\n  constructor() {\n    super('Address does not match its checksum counterpart.')\n  }\n}\n","import * as ox__Hex from \"ox/Hex\";\nimport type { Hex } from \"../hex.js\";\n\n/**\n * Concatenates an array of hexadecimal values into a single hexadecimal value.\n *\n * @param values - An array of hexadecimal values to concatenate.\n * @returns The concatenated hexadecimal value.\n * @utils\n */\nexport function concatHex(values: readonly Hex[]): Hex {\n  return ox__Hex.concat(...values);\n}\n","import type { Abi, AbiFunction, Address } from \"abitype\";\nimport type { AccessList, Hex } from \"viem\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport type { PreparedMethod } from \"../utils/abi/prepare-method.js\";\nimport type { PromisedObject } from \"../utils/promise/resolve-promised-value.js\";\nimport type { SignedAuthorization } from \"./actions/eip7702/authorization.js\";\n\nexport type StaticPrepareTransactionOptions = {\n  accessList?: AccessList | undefined;\n  to?: Address | undefined;\n  data?: Hex | undefined;\n  value?: bigint | undefined;\n  gas?: bigint | undefined;\n  gasPrice?: bigint | undefined;\n  maxFeePerGas?: bigint | undefined;\n  maxPriorityFeePerGas?: bigint | undefined;\n  maxFeePerBlobGas?: bigint | undefined;\n  type?: undefined | TransactionType;\n  nonce?: number | undefined;\n  extraGas?: bigint | undefined;\n  // eip7702\n  authorizationList?: SignedAuthorization[] | undefined;\n  // zksync specific\n  eip712?: EIP712TransactionOptions | undefined;\n  // tw specific\n  chain: Chain;\n  client: ThirdwebClient;\n  // extras\n  extraCallData?: Hex;\n  erc20Value?: {\n    amountWei: bigint;\n    tokenAddress: Address;\n  };\n};\n\ntype TransactionType = \"legacy\" | \"eip1559\" | \"eip2930\" | \"eip4844\" | \"eip7702\";\n\nexport const TransactionTypeMap: Record<TransactionType, number> = {\n  eip1559: 1,\n  eip2930: 2,\n  eip4844: 3,\n  eip7702: 4,\n  legacy: 0,\n};\n\nexport type EIP712TransactionOptions = {\n  // constant or user input\n  gasPerPubdata?: bigint | undefined;\n  // optional signature, generated\n  customSignature?: Hex | undefined;\n  // optional, used to deploy contracts with the transaction\n  factoryDeps?: Hex[] | undefined;\n  // optional, paymaster contract address to invoke\n  paymaster?: Address | undefined;\n  // optional, paymaster contract input\n  paymasterInput?: Hex | undefined;\n};\n\nexport type EIP712SerializedTransaction = {\n  txType: bigint;\n  from: bigint;\n  to: bigint;\n  gasLimit: bigint;\n  gasPerPubdataByteLimit: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  nonce: bigint;\n  value: bigint;\n  data: Hex;\n  factoryDeps: Hex[];\n  paymaster: bigint;\n  paymasterInput: Hex;\n};\n\nexport type PrepareTransactionOptions = {\n  chain: Chain;\n  client: ThirdwebClient;\n} & PromisedObject<Omit<StaticPrepareTransactionOptions, \"chain\" | \"client\">>;\n\ntype Additional<\n  abi extends Abi = [],\n  abiFn extends AbiFunction = AbiFunction,\n> = {\n  preparedMethod: () => Promise<PreparedMethod<abiFn>>;\n  contract: ThirdwebContract<abi>;\n};\n\nexport type PreparedTransaction<\n  abi extends Abi = [],\n  abiFn extends AbiFunction = AbiFunction,\n  options extends PrepareTransactionOptions = PrepareTransactionOptions,\n> = Readonly<options> & {\n  __preparedMethod?: () => Promise<PreparedMethod<abiFn>>;\n  __contract?: ThirdwebContract<abi>;\n};\n\n/**\n * Prepares a transaction with the given options.\n * @param options - The options for preparing the transaction.\n * @param info - Additional information about the ABI function.\n * @returns The prepared transaction.\n * @transaction\n * @example\n * ```ts\n * import { prepareTransaction, toWei } from \"thirdweb\";\n * import { ethereum } from \"thirdweb/chains\";\n * const transaction = prepareTransaction({\n *  to: \"0x1234567890123456789012345678901234567890\",\n *  chain: ethereum,\n *  client: thirdwebClient,\n *  value: toWei(\"1.0\"),\n *  gasPrice: 30n\n * });\n * ```\n */\nexport function prepareTransaction<\n  const abi extends Abi = [],\n  const abiFn extends AbiFunction = AbiFunction,\n>(options: PrepareTransactionOptions, info?: Additional<abi, abiFn>) {\n  if (info) {\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    (options as any).__preparedMethod = info.preparedMethod;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    (options as any).__contract = info.contract;\n  }\n  return options as PreparedTransaction<abi, abiFn>;\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport type { TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport {\n  type PrepareTransactionOptions,\n  prepareTransaction,\n} from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type PrepareContractCallOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n    | \"authorizationList\"\n  > & {\n    contract: ThirdwebContract<TAbi>;\n    method: TMethod | TPreparedMethod;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * Prepares a contract call by resolving the ABI function, parameters and encoded data. Optionally specify other properties such as value or gas price.\n * @param options - The options for preparing the contract call.\n * @returns A promise that resolves to the prepared transaction.\n * @transaction\n * @example\n *\n * ### Usage with a human-readable method signature:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with explicit gas price and/or value:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n *  maxFeePerGas: 30n,\n *  maxPriorityFeePerGas: 1n,\n *  value: toWei(\"0.01\"),\n * });\n * ```\n *\n * ### Usage with ERC20 value:\n *\n * For transactions that transfer ERC20 tokens, you can specify the value as the amount of tokens to transfer.\n *\n * You can use this in conjuction with the [`getApprovalForTransaction`](https://portal.thirdweb.com/references/typescript/v5/getApprovalForTransaction) function to easily create approval transactions for ERC20 tokens.\n *\n * This value will also be read by the react hooks and UI components to present to total cost to the user.\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function payWithCoin()\",\n *  params: [],\n *  erc20Value: {\n *    tokenAddress: \"0x...\", // the address of the ERC20 token\n *    amountWei: toWei(\"0.1\"), // the amount of tokens to transfer in wei\n *  },\n * });\n * ```\n *\n * ### Usage with a JSON ABI function object:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: {\n *    name: \"transfer\",\n *    type: \"function\",\n *    inputs: [\n *      { name: \"to\", type: \"address\" },\n *      { name: \"value\", type: \"uint256\" },\n *    ],\n *    outputs: [],\n *    stateMutability: \"payable\"\n *   },\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with the ABI defined on the contract:\n *\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *  ..., // chain, address, client\n *  abi: [...] // ABI with a \"transfer\" method\n * });\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"transfer\", // <- this gets inferred from the contract\n *  params: [to, value],\n * });\n * ```\n *\n * ### Passing extra call data to the transaction\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *   ..., // chain, address, client\n * });\n *\n * const transaction = prepareContractCall({\n *   contract,\n *   method: \"function transfer(address to, uint256 value)\",\n *   params: [...],\n *   // The extra call data MUST be encoded to hex before passing\n *   extraCallData: \"0x.......\"\n * });\n * ```\n */\nexport function prepareContractCall<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(options: PrepareContractCallOptions<TAbi, TMethod, TPreparedMethod>) {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params, ...rest } = options;\n\n  const preparedMethodPromise = () =>\n    (async () => {\n      if (Array.isArray(method)) {\n        return method as PreparedMethod_;\n      }\n      if (isAbiFunction(method)) {\n        return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n      }\n\n      if (typeof method === \"function\") {\n        return prepareMethod(\n          // @ts-expect-error - method *is* function in this case\n          (await method(contract)) as ParsedMethod_,\n        ) as PreparedMethod_;\n      }\n      // if the method starts with the string `function ` we always will want to try to parse it\n      if (typeof method === \"string\" && method.startsWith(\"function \")) {\n        // @ts-expect-error - method *is* string in this case\n        const abiItem = parseAbiItem(method);\n        if (abiItem.type === \"function\") {\n          return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n        }\n        throw new Error(`\"method\" passed is not of type \"function\"`);\n      }\n      // check if we have a \"abi\" on the contract\n      if (contract.abi && contract.abi?.length > 0) {\n        // extract the abiFunction from it\n        const abiFunction = contract.abi?.find(\n          (item) => item.type === \"function\" && item.name === method,\n        );\n        // if we were able to find it -> return it\n        if (abiFunction) {\n          return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n        }\n      }\n      throw new Error(`Could not resolve method \"${method}\".`);\n    })();\n\n  return prepareTransaction(\n    {\n      ...rest,\n      chain: contract.chain,\n      client: contract.client,\n      data: async () => {\n        let preparedM: PreparedMethod_;\n        if (Array.isArray(method)) {\n          preparedM = method as PreparedMethod_;\n        } else {\n          preparedM = await preparedMethodPromise();\n        }\n\n        if (preparedM[1].length === 0) {\n          // just return the fn sig directly -> no params\n          return preparedM[0];\n        }\n\n        // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n        // we can do this because we know the specific formats of the values\n        return (preparedM[0] +\n          encodeAbiParameters(\n            preparedM[1],\n            // @ts-expect-error - TODO: fix this type issue\n            await resolvePromisedValue(params ?? []),\n          ).slice(2)) as `${(typeof preparedM)[0]}${string}`;\n      },\n      // these always inferred from the contract\n      to: contract.address,\n    },\n    {\n      contract: contract,\n      preparedMethod: preparedMethodPromise,\n    },\n  );\n}\n","import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  getContract,\n  type ThirdwebContract,\n} from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { isHex, stringToHex } from \"../../../utils/encoding/hex.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\nimport { DEFAULT_ACCOUNT_FACTORY_V0_6 } from \"./constants.js\";\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictSmartAccountAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictSmartAccountAddress({\n *  client,\n *  chain,\n *  adminAddress,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictSmartAccountAddress(args: {\n  client: ThirdwebClient;\n  chain: Chain;\n  adminAddress: string;\n  factoryAddress?: string;\n  accountSalt?: string;\n}): Promise<string> {\n  return predictAddress({\n    accountSalt: args.accountSalt,\n    adminAddress: args.adminAddress,\n    factoryContract: getContract({\n      address: args.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY_V0_6,\n      chain: args.chain,\n      client: args.client,\n    }),\n  });\n}\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n * @deprecated Use `predictSmartAccountAddress` instead.\n */\nexport async function predictAddress(args: {\n  factoryContract: ThirdwebContract;\n  predictAddressOverride?: (\n    factoryContract: ThirdwebContract,\n    admin: string,\n  ) => Promise<string>;\n  adminAddress: string;\n  accountSalt?: string;\n  accountAddress?: string;\n}): Promise<string> {\n  const {\n    factoryContract,\n    predictAddressOverride: predictAddress,\n    adminAddress,\n    accountSalt,\n    accountAddress,\n  } = args;\n  if (predictAddress) {\n    return predictAddress(factoryContract, adminAddress);\n  }\n  if (accountAddress) {\n    return accountAddress;\n  }\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  return withCache(\n    async () => {\n      const saltHex =\n        accountSalt && isHex(accountSalt)\n          ? accountSalt\n          : stringToHex(accountSalt ?? \"\");\n      let result: string | undefined;\n      let retries = 0;\n      const maxRetries = 3;\n\n      while (retries <= maxRetries) {\n        try {\n          result = await readContract({\n            contract: factoryContract,\n            method: \"function getAddress(address, bytes) returns (address)\",\n            params: [adminAddress, saltHex],\n          });\n          break;\n        } catch (error) {\n          if (retries === maxRetries) {\n            throw error;\n          }\n\n          // Exponential backoff: 2^(retries + 1) * 200ms (400ms, 800ms, 1600ms)\n          const delay = 2 ** (retries + 1) * 200;\n          await new Promise((resolve) => setTimeout(resolve, delay));\n          retries++;\n        }\n      }\n      if (!result) {\n        throw new Error(\n          `No smart account address found for admin address ${adminAddress} and salt ${accountSalt}`,\n        );\n      }\n      return result;\n    },\n    {\n      cacheKey: `${args.factoryContract.chain.id}-${args.factoryContract.address}-${args.adminAddress}-${args.accountSalt}`,\n      cacheTime: 1000 * 60 * 60 * 24, // 1 day\n    },\n  );\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n    admin: string,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    adminAddress,\n    factoryContract,\n    createAccountOverride: createAccount,\n    accountSalt,\n  } = args;\n  if (createAccount) {\n    return createAccount(factoryContract, adminAddress);\n  }\n  const saltHex =\n    accountSalt && isHex(accountSalt)\n      ? accountSalt\n      : stringToHex(accountSalt ?? \"\");\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [adminAddress, saltHex],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  transaction: SendTransactionOption;\n  executeOverride?: (\n    accountContract: ThirdwebContract,\n    transaction: SendTransactionOption,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const { accountContract, transaction, executeOverride: execute } = args;\n  if (execute) {\n    return execute(accountContract, transaction);\n  }\n  let value = transaction.value || 0n;\n  // special handling of hedera chains, decimals for native value is 8 instead of 18 when passed as contract params\n  if (transaction.chainId === 295 || transaction.chainId === 296) {\n    value = BigInt(value) / BigInt(10 ** 10);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    // if gas is specified for the inner tx, use that and add 21k for the execute call on the account contract\n    // this avoids another estimateGas call when bundling the userOp\n    // and also allows for passing custom gas limits for the inner tx\n    gas: transaction.gas ? transaction.gas + 21000n : undefined,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [transaction.to || \"\", value, transaction.data || \"0x\"],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  transactions: SendTransactionOption[];\n  executeBatchOverride?: (\n    accountContract: ThirdwebContract,\n    transactions: SendTransactionOption[],\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    accountContract,\n    transactions,\n    executeBatchOverride: executeBatch,\n  } = args;\n  if (executeBatch) {\n    return executeBatch(accountContract, transactions);\n  }\n  let values = transactions.map((tx) => tx.value || 0n);\n  const chainId = transactions[0]?.chainId;\n  // special handling of hedera chains, decimals for native value is 8 instead of 18 when passed as contract params\n  if (chainId === 295 || chainId === 296) {\n    values = values.map((value) => BigInt(value) / BigInt(10 ** 10));\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      values,\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n","export const ERC_6492_MAGIC_VALUE =\n  \"0x6492649264926492649264926492649264926492649264926492649264926492\" as const;\n","import * as ox__Abi from \"ox/Abi\";\nimport * as ox__AbiConstructor from \"ox/AbiConstructor\";\nimport * as ox__AbiFunction from \"ox/AbiFunction\";\nimport { WrappedSignature as ox__WrappedSignature } from \"ox/erc6492\";\nimport * as ox__Signature from \"ox/Signature\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getContract, type ThirdwebContract } from \"../contract/contract.js\";\nimport { isValidSignature } from \"../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport type { Address } from \"../utils/address.js\";\nimport { isZkSyncChain } from \"../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { isContractDeployed } from \"../utils/bytecode/is-contract-deployed.js\";\nimport { fromBytes } from \"../utils/encoding/from-bytes.js\";\nimport { type Hex, hexToBool, isHex } from \"../utils/encoding/hex.js\";\nimport { serializeErc6492Signature } from \"./serialize-erc6492-signature.js\";\n\nexport type VerifyHashParams = {\n  hash: Hex;\n  signature: string | Uint8Array | ox__Signature.Signature;\n  address: string;\n  client: ThirdwebClient;\n  chain: Chain;\n  accountFactory?: {\n    address: string;\n    verificationCalldata: Hex;\n  };\n};\n\nconst ZKSYNC_VALIDATOR_ADDRESS: Address =\n  \"0xfB688330379976DA81eB64Fe4BF50d7401763B9C\";\n\n/**\n * Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.\n * This function should rarely be used directly, instead use @see {import(\"./verify-signature.js\")} and @see {import(\"./verify-typed-data.js\")}}\n *\n * @param {Hex} options.hash The hash that was signed\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {string} options.address The address that signed the hash\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyHash } from \"thirdweb/utils\";\n * const isValid = await verifyHash({\n *   hash: \"0x1234\",\n *   signature: \"0x1234\",\n *   address: \"0x1234\",\n *   client,\n *   chain,\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyHash({\n  hash,\n  signature,\n  address,\n  client,\n  chain,\n  accountFactory,\n}: VerifyHashParams): Promise<boolean> {\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature;\n    if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature)\n      return ox__Signature.toHex(signature);\n    if (signature instanceof Uint8Array) return fromBytes(signature, \"hex\");\n    // We should never hit this but TS doesn't know that\n    throw new Error(\n      `Invalid signature type for signature ${signature}: ${typeof signature}`,\n    );\n  })();\n\n  const isDeployed = await isContractDeployed(\n    getContract({\n      address,\n      chain,\n      client,\n    }),\n  );\n\n  if (isDeployed) {\n    const validEip1271 = await verifyEip1271Signature({\n      contract: getContract({\n        address,\n        chain,\n        client,\n      }),\n      hash,\n      signature: signatureHex,\n    }).catch((err) => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n  }\n\n  // contract not deployed, use erc6492 validator to verify signature\n  const wrappedSignature: Hex = await (async () => {\n    // If no factory is provided, we have to assume its already deployed or is an EOA\n    // TODO: Figure out how to automatically tell if our default factory was used\n    if (!accountFactory) return signatureHex;\n\n    // If this sigature was already wrapped for ERC-6492, carry on\n    if (ox__WrappedSignature.validate(signatureHex)) return signatureHex;\n\n    // Otherwise, serialize the signature for ERC-6492 validation\n    return serializeErc6492Signature({\n      address: accountFactory.address,\n      data: accountFactory.verificationCalldata,\n      signature: signatureHex,\n    });\n  })();\n\n  let verificationData: {\n    to?: Address;\n    data: Hex;\n  };\n\n  const zkSyncChain = await isZkSyncChain(chain);\n  const abi = ox__Abi.from(ox__WrappedSignature.universalSignatureValidatorAbi);\n  if (zkSyncChain) {\n    // zksync chains dont support deploying code with eth_call\n    // need to call a deployed contract instead\n    verificationData = {\n      data: ox__AbiFunction.encodeData(\n        ox__AbiFunction.fromAbi(abi, \"isValidSig\"),\n        [address, hash, wrappedSignature],\n      ),\n      to: ZKSYNC_VALIDATOR_ADDRESS,\n    };\n  } else {\n    const validatorConstructor = ox__AbiConstructor.fromAbi(abi);\n    verificationData = {\n      data: ox__AbiConstructor.encode(validatorConstructor, {\n        args: [address, hash, wrappedSignature],\n        bytecode: ox__WrappedSignature.universalSignatureValidatorBytecode,\n      }),\n    };\n  }\n\n  const rpcRequest = getRpcClient({\n    chain,\n    client,\n  });\n\n  try {\n    const result = await eth_call(rpcRequest, verificationData);\n    return hexToBool(result);\n  } catch {\n    // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation\n    const validEip1271 = await verifyEip1271Signature({\n      contract: getContract({\n        address,\n        chain,\n        client,\n      }),\n      hash,\n      signature: signatureHex,\n    }).catch((err) => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n    // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error\n    // Verification failed somehow\n    return false;\n  }\n}\n\nconst EIP_1271_MAGIC_VALUE = \"0x1626ba7e\";\nexport async function verifyEip1271Signature({\n  hash,\n  signature,\n  contract,\n}: {\n  hash: Hex;\n  signature: Hex;\n  contract: ThirdwebContract;\n}): Promise<boolean> {\n  try {\n    const result = await isValidSignature({\n      contract,\n      hash,\n      signature,\n    });\n    return result === EIP_1271_MAGIC_VALUE;\n  } catch (err) {\n    console.error(\"Error verifying EIP-1271 signature\", err);\n    return false;\n  }\n}\n","import * as ox__Bytes from \"ox/Bytes\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringToBytes, toBytes } from \"../encoding/to-bytes.js\";\nimport type { SignableMessage } from \"../types.js\";\nimport { keccak256 } from \"./keccak256.js\";\n\nconst presignMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\ntype To = \"hex\" | \"bytes\";\n\ntype HashMessage<TTo extends To> =\n  | (TTo extends \"bytes\" ? ox__Bytes.Bytes : never)\n  | (TTo extends \"hex\" ? Hex : never);\n\n/**\n * Ethereum Signed Message hashing\n * @param message - The message to hash, either as a string, a Uint8Array, or an object with a `raw` property containing a Uint8Array.\n * @param to_ - The desired output format of the hash (optional). Defaults to 'hex'.\n * @example\n * ```ts\n * import { hashMessage } from \"thirdweb/utils\";\n * const hash = hashMessage(\"hello world\");\n * ```\n * @returns The Ethereum Signed Message hash of the message in the specified format.\n * @utils\n */\nexport function hashMessage<TTo extends To = \"hex\">(\n  message: SignableMessage,\n  to_?: TTo,\n): HashMessage<TTo> {\n  const messageBytes = (() => {\n    if (typeof message === \"string\") {\n      return stringToBytes(message);\n    }\n    if (message.raw instanceof Uint8Array) {\n      return message.raw;\n    }\n    return toBytes(message.raw);\n  })();\n  const prefixBytes = stringToBytes(\n    `${presignMessagePrefix}${messageBytes.length}`,\n  );\n  return keccak256(ox__Bytes.concat(prefixBytes, messageBytes), to_);\n}\n","import type * as ox__AbiParameters from \"ox/AbiParameters\";\nimport * as ox__Bytes from \"ox/Bytes\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { encodeAbiParameters } from \"../abi/encodeAbiParameters.js\";\nimport { type Hex, toHex } from \"../encoding/hex.js\";\nimport { keccak256 } from \"./keccak256.js\";\n\ntype MessageTypeProperty = {\n  name: string;\n  type: string;\n};\n\nexport type HashTypedDataParams<\n  typedData extends\n    | ox__TypedData.TypedData\n    | Record<string, unknown> = ox__TypedData.TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = ox__TypedData.Definition<typedData, primaryType>;\n\n/**\n * @internal\n */\nexport function hashTypedData<\n  const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>(parameters: HashTypedDataParams<typedData, primaryType>): Hex {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParams;\n  const types = {\n    EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain),\n    ...parameters.types,\n  };\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  ox__TypedData.validate({\n    domain,\n    message,\n    primaryType,\n    types,\n  });\n\n  const parts: Hex[] = [\"0x1901\"];\n  if (domain)\n    parts.push(\n      ox__TypedData.hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    );\n\n  if (primaryType !== \"EIP712Domain\") {\n    const hashedStruct = (() => {\n      const encoded = encodeData({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      });\n      return keccak256(encoded);\n    })();\n\n    parts.push(hashedStruct);\n  }\n\n  return keccak256(ox__Bytes.concat(...parts.map((p) => ox__Bytes.fromHex(p))));\n}\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>;\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  const encodedTypes: ox__AbiParameters.Parameter[] = [{ type: \"bytes32\" }];\n  const encodedValues: unknown[] = [hashType({ primaryType, types })];\n\n  if (!types[primaryType]) throw new Error(\"Invalid types\");\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      name: field.name,\n      type: field.type,\n      types,\n      value: data[field.name],\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues);\n}\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }));\n  return keccak256(encodedHashType);\n}\n\nfunction encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  let result = \"\";\n  const unsortedDeps = findTypeDependencies({ primaryType, types });\n  unsortedDeps.delete(primaryType);\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    if (!types[type]) throw new Error(\"Invalid types\");\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(\",\")})`;\n  }\n\n  return result;\n}\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string;\n    types: Record<string, MessageTypeProperty[]>;\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u);\n  const primaryType = match?.[0] as string;\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results;\n  }\n\n  results.add(primaryType);\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results);\n  }\n  return results;\n}\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, MessageTypeProperty[]>;\n  name: string;\n  type: string;\n  // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n  value: any;\n  // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n}): [type: ox__AbiParameters.Parameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: \"bytes32\" },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ];\n  }\n\n  if (type === \"bytes\") {\n    const prepend = value.length % 2 ? \"0\" : \"\";\n    value = `0x${prepend + value.slice(2)}`;\n    return [{ type: \"bytes32\" }, keccak256(value)];\n  }\n\n  if (type === \"string\") return [{ type: \"bytes32\" }, keccak256(toHex(value))];\n\n  if (type.lastIndexOf(\"]\") === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf(\"[\"));\n    const typeValuePairs =\n      // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n      (value as [ox__AbiParameters.Parameter, any][]).map((item) =>\n        encodeField({\n          name,\n          type: parsedType,\n          types,\n          value: item,\n        }),\n      );\n    return [\n      { type: \"bytes32\" },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ];\n  }\n\n  return [{ type }, value];\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"isValidSignature\" function.\n */\nexport type IsValidSignatureParams = {\n  hash: AbiParameterToPrimitiveType<{ type: \"bytes32\"; name: \"hash\" }>;\n  signature: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"signature\" }>;\n};\n\nexport const FN_SELECTOR = \"0x1626ba7e\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"hash\",\n    type: \"bytes32\",\n  },\n  {\n    name: \"signature\",\n    type: \"bytes\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes4\",\n  },\n] as const;\n\n/**\n * Checks if the `isValidSignature` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `isValidSignature` method is supported.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isIsValidSignatureSupported } from \"thirdweb/extensions/erc1271\";\n * const supported = isIsValidSignatureSupported([\"0x...\"]);\n * ```\n */\nexport function isIsValidSignatureSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"isValidSignature\" function.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded ABI parameters.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignatureParams } from \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignatureParams({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeIsValidSignatureParams(options: IsValidSignatureParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.hash, options.signature]);\n}\n\n/**\n * Encodes the \"isValidSignature\" function into a Hex string with its parameters.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignature } from \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignature({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeIsValidSignature(options: IsValidSignatureParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeIsValidSignatureParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the isValidSignature function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1271\n * @example\n * ```ts\n * import { decodeIsValidSignatureResult } from \"thirdweb/extensions/erc1271\";\n * const result = decodeIsValidSignatureResultResult(\"...\");\n * ```\n */\nexport function decodeIsValidSignatureResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"isValidSignature\" function on the contract.\n * @param options - The options for the isValidSignature function.\n * @returns The parsed result of the function call.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isValidSignature } from \"thirdweb/extensions/erc1271\";\n *\n * const result = await isValidSignature({\n *  contract,\n *  hash: ...,\n *  signature: ...,\n * });\n *\n * ```\n */\nexport async function isValidSignature(\n  options: BaseTransactionOptions<IsValidSignatureParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.hash, options.signature],\n  });\n}\n","import { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport { concatHex } from \"../utils/encoding/helpers/concat-hex.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { ERC_6492_MAGIC_VALUE } from \"./constants.js\";\nimport type { Erc6492Signature } from \"./types.js\";\n\n/**\n * Serializes a signature for use with [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). The signature must be generated by a signer for an [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) Account Factory account with counterfactual deployment addresses.\n *\n * @param {@link Erc6492Signature} signature  The signature object to serialize into Hex format\n * @param {string} signature.address The ERC-4337 Account Factory address\n * @param {Hex} signature.data Account deployment calldata (if not deployed) for counterfactual verification\n * @param {Hex} signature.signature The original signature\n *\n * @returns {Hex} The serialized signature\n *\n * @example\n * ```ts\n * import { serializeErc6492Signature } from 'thirdweb/auth';\n *\n * const serializedSignature = serializeErc6492Signature({\n *  address: '0x...',\n *  data: '0x...',\n *  signature: '0x...',\n * });\n * // 0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492\n * ```\n * @auth\n */\nexport function serializeErc6492Signature({\n  address,\n  data,\n  signature,\n}: Erc6492Signature): Hex {\n  return concatHex([\n    encodeAbiParameters(\n      [{ type: \"address\" }, { type: \"bytes\" }, { type: \"bytes\" }],\n      [address, data, signature],\n    ),\n    ERC_6492_MAGIC_VALUE,\n  ]);\n}\n","import type * as ox__TypedData from \"ox/TypedData\";\nimport { serializeErc6492Signature } from \"../../../auth/serialize-erc6492-signature.js\";\nimport { verifyEip1271Signature } from \"../../../auth/verify-hash.js\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { hashMessage } from \"../../../utils/hashing/hashMessage.js\";\nimport { hashTypedData } from \"../../../utils/hashing/hashTypedData.js\";\nimport type { SignableMessage } from \"../../../utils/types.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { SmartAccountOptions } from \"../types.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\n\n/**\n * If the account is already deployed, generate an ERC-1271 signature.\n * If the account is not deployed, generate an ERC-6492 signature unless otherwise specified.\n *\n * @internal\n */\nexport async function smartAccountSignMessage({\n  accountContract,\n  factoryContract,\n  options,\n  message,\n}: {\n  accountContract: ThirdwebContract;\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  message: SignableMessage;\n}) {\n  const originalMsgHash = hashMessage(message);\n\n  let sig: `0x${string}`;\n  const wrappedMessageHash = encodeAbiParameters(\n    [{ type: \"bytes32\" }],\n    [originalMsgHash],\n  );\n\n  sig = await options.personalAccount.signTypedData({\n    domain: {\n      chainId: options.chain.id,\n      name: \"Account\",\n      verifyingContract: accountContract.address,\n      version: \"1\",\n    },\n    message: { message: wrappedMessageHash },\n    primaryType: \"AccountMessage\",\n    types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n  });\n\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    const isValid = await verifyEip1271Signature({\n      contract: accountContract,\n      hash: originalMsgHash,\n      signature: sig,\n    });\n    if (isValid) {\n      return sig;\n    }\n    throw new Error(\"Failed to verify signature\");\n  } else {\n    const deployTx = prepareCreateAccount({\n      accountSalt: options.overrides?.accountSalt,\n      adminAddress: options.personalAccount.address,\n      createAccountOverride: options.overrides?.createAccount,\n      factoryContract,\n    });\n    if (!deployTx) {\n      throw new Error(\"Create account override not provided\");\n    }\n    const initCode = await encode(deployTx);\n    const erc6492Sig = serializeErc6492Signature({\n      address: factoryContract.address,\n      data: initCode,\n      signature: sig,\n    });\n\n    return erc6492Sig;\n  }\n}\n\nexport async function smartAccountSignTypedData<\n  const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>({\n  accountContract,\n  factoryContract,\n  options,\n  typedData,\n}: {\n  accountContract: ThirdwebContract;\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  typedData: ox__TypedData.Definition<typedData, primaryType>;\n}) {\n  const isSelfVerifyingContract =\n    (\n      typedData.domain as ox__TypedData.Domain\n    )?.verifyingContract?.toLowerCase() ===\n    accountContract.address?.toLowerCase();\n\n  if (isSelfVerifyingContract) {\n    // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n    return options.personalAccount.signTypedData(typedData);\n  }\n\n  const originalMsgHash = hashTypedData(typedData);\n\n  let sig: `0x${string}`;\n  const wrappedMessageHash = encodeAbiParameters(\n    [{ type: \"bytes32\" }],\n    [originalMsgHash],\n  );\n  sig = await options.personalAccount.signTypedData({\n    domain: {\n      chainId: options.chain.id,\n      name: \"Account\",\n      verifyingContract: accountContract.address,\n      version: \"1\",\n    },\n    message: { message: wrappedMessageHash },\n    primaryType: \"AccountMessage\",\n    types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n  });\n\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    const isValid = await verifyEip1271Signature({\n      contract: accountContract,\n      hash: originalMsgHash,\n      signature: sig,\n    });\n    if (isValid) {\n      return sig;\n    }\n    throw new Error(\"Failed to verify signature\");\n  } else {\n    const deployTx = prepareCreateAccount({\n      accountSalt: options.overrides?.accountSalt,\n      adminAddress: options.personalAccount.address,\n      createAccountOverride: options.overrides?.createAccount,\n      factoryContract,\n    });\n    if (!deployTx) {\n      throw new Error(\"Create account override not provided\");\n    }\n    const initCode = await encode(deployTx);\n    const erc6492Sig = serializeErc6492Signature({\n      address: factoryContract.address,\n      data: initCode,\n      signature: sig,\n    });\n\n    return erc6492Sig;\n  }\n}\n\nexport async function confirmContractDeployment(args: {\n  accountContract: ThirdwebContract;\n}) {\n  const { accountContract } = args;\n  const startTime = Date.now();\n  const timeout = 60000; // wait 1 minute max\n  const { isContractDeployed } = await import(\n    \"../../../utils/bytecode/is-contract-deployed.js\"\n  );\n  let isDeployed = await isContractDeployed(accountContract);\n  while (!isDeployed) {\n    if (Date.now() - startTime > timeout) {\n      throw new Error(\n        \"Timeout: Smart account deployment not confirmed after 1 minute\",\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 500));\n    isDeployed = await isContractDeployed(accountContract);\n  }\n}\n\n/**\n * Deployes a smart account via a dummy transaction. If the account is already deployed, this will do nothing.\n *\n * @param args - Arguments for the deployment.\n * @param args.smartAccount - The smart account to deploy.\n * @param args.chain - The chain to deploy on.\n * @param args.client - The client to use for the deployment.\n * @param args.accountContract - The account contract to deploy.\n *\n * @example\n * ```ts\n * import { deploySmartAccount } from \"thirdweb\";\n *\n * const account = await deploySmartAccount({\n *   smartAccount,\n *   chain,\n *   client,\n *   accountContract,\n * });\n * ```\n *\n * @wallet\n */\nexport async function deploySmartAccount(args: {\n  smartAccount: Account;\n  chain: Chain;\n  client: ThirdwebClient;\n  accountContract: ThirdwebContract;\n}) {\n  const { chain, client, smartAccount, accountContract } = args;\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    return;\n  }\n\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../../transaction/actions/send-transaction.js\"),\n    import(\"../../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    chain: chain,\n    client: client,\n    gas: 50000n,\n    to: accountContract.address,\n    value: 0n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    account: smartAccount,\n    transaction: dummyTx,\n  });\n\n  await confirmContractDeployment({\n    accountContract,\n  });\n\n  return deployResult;\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,4,5,6,7,8,9,10,11,12,13,14,17,18,25,26,27,28,29,30,31]}