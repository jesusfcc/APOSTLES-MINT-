{"version":3,"sources":["../../../../node_modules/thirdweb/src/transaction/actions/encode.ts","../../../../node_modules/ox/core/Solidity.ts","../../../../node_modules/ox/core/Caches.ts","../../../../node_modules/ox/core/internal/lru.ts","../../../../node_modules/ox/core/Hash.ts","../../../../node_modules/ox/core/Address.ts","../../../../node_modules/ox/core/Signature.ts","../../../../node_modules/ox/core/Rlp.ts","../../../../node_modules/ox/core/internal/cursor.ts","../../../../node_modules/ox/core/Authorization.ts"],"sourcesContent":["import type { Abi, AbiFunction } from \"abitype\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\n\nconst encodeWeakMap = new WeakMap<\n  PreparedTransaction<Abi, AbiFunction>,\n  Promise<Hex>\n>();\n\n/**\n * Encodes a transaction object into a hexadecimal string representation of the encoded data.\n * @param transaction - The transaction object to encode.\n * @returns A promise that resolves to the encoded data as a hexadecimal string.\n * @transaction\n * @example\n * ```ts\n * import { encode } from \"thirdweb\";\n * const encodedData = await encode(transaction);\n * ```\n */\nexport async function encode<abi extends Abi, abiFn extends AbiFunction>(\n  transaction: PreparedTransaction<abi, abiFn>,\n): Promise<Hex> {\n  if (encodeWeakMap.has(transaction)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return encodeWeakMap.get(transaction)!;\n  }\n  const promise = (async () => {\n    const [data, extraData, { concatHex }] = await Promise.all([\n      getDataFromTx(transaction),\n      getExtraCallDataFromTx(transaction),\n      import(\"../../utils/encoding/helpers/concat-hex.js\"),\n    ]);\n    if (extraData) {\n      return concatHex([data, extraData]);\n    }\n    return data;\n  })();\n  encodeWeakMap.set(transaction, promise);\n  return promise;\n}\n\n/**\n * Get the transaction.data (from a PreparedTransaction)\n * If the transaction does not have `data`, we default to \"0x\"\n * @internal\n */\nexport async function getDataFromTx<abi extends Abi, abiFn extends AbiFunction>(\n  transaction: PreparedTransaction<abi, abiFn>,\n): Promise<Hex> {\n  if (transaction.data === undefined) {\n    return \"0x\";\n  }\n  if (typeof transaction.data === \"function\") {\n    const data = await transaction.data();\n    if (!data) {\n      return \"0x\";\n    }\n    return data;\n  }\n  return transaction.data;\n}\n\n/**\n * Get the extraCallData from a PreparedTransaction\n * @internal\n * If extraCallData is \"0x\", we will return `undefined`\n * to simplify the code, since concatenating \"0x\" doesn't do anything\n */\nexport async function getExtraCallDataFromTx<\n  abi extends Abi,\n  abiFn extends AbiFunction,\n>(transaction: PreparedTransaction<abi, abiFn>): Promise<Hex | undefined> {\n  if (!transaction.extraCallData) {\n    return undefined;\n  }\n  if (typeof transaction.extraCallData === \"function\") {\n    const extraData = await transaction.extraCallData();\n    if (!extraData) return undefined;\n    if (!extraData.startsWith(\"0x\")) {\n      throw Error(\"Invalid extra calldata - must be a hex string\");\n    }\n    if (extraData === \"0x\") {\n      return undefined;\n    }\n    return extraData;\n  }\n  if (!transaction.extraCallData.startsWith(\"0x\")) {\n    throw Error(\"Invalid extra calldata - must be a hex string\");\n  }\n  return transaction.extraCallData;\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n","import type * as Address from './Address.js'\nimport { LruMap } from './internal/lru.js'\n\nconst caches = {\n  checksum: /*#__PURE__*/ new LruMap<Address.Address>(8192),\n}\n\nexport const checksum = caches.checksum\n\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nexport function clear() {\n  for (const cache of Object.values(caches)) cache.clear()\n}\n","/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override get(key: string) {\n    const value = super.get(key)\n\n    if (super.has(key) && value !== undefined) {\n      this.delete(key)\n      super.set(key, value)\n    }\n\n    return value\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      const firstKey = this.keys().next().value\n      if (firstKey) this.delete(firstKey)\n    }\n    return this\n  }\n}\n","import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160'\nimport { keccak_256 as noble_keccak256 } from '@noble/hashes/sha3'\nimport { sha256 as noble_sha256 } from '@noble/hashes/sha256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nexport function keccak256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: keccak256.Options<as> = {},\n): keccak256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_keccak256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace keccak256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nexport function ripemd160<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: ripemd160.Options<as> = {},\n): ripemd160.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_ripemd160(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace ripemd160 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nexport function sha256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: sha256.Options<as> = {},\n): sha256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_sha256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace sha256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nexport function validate(value: string): value is Hex.Hex {\n  return Hex.validate(value) && Hex.size(value) === 32\n}\n\nexport declare namespace validate {\n  type ErrorType =\n    | Hex.validate.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n","import type { Address as abitype_Address } from 'abitype'\nimport * as Bytes from './Bytes.js'\nimport * as Caches from './Caches.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as PublicKey from './PublicKey.js'\n\nconst addressRegex = /*#__PURE__*/ /^0x[a-fA-F0-9]{40}$/\n\n/** Root type for Address. */\nexport type Address = abitype_Address\n\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nexport function assert(\n  value: string,\n  options: assert.Options = {},\n): asserts value is Address {\n  const { strict = true } = options\n\n  if (!addressRegex.test(value))\n    throw new InvalidAddressError({\n      address: value,\n      cause: new InvalidInputError(),\n    })\n\n  if (strict) {\n    if (value.toLowerCase() === value) return\n    if (checksum(value as Address) !== value)\n      throw new InvalidAddressError({\n        address: value,\n        cause: new InvalidChecksumError(),\n      })\n  }\n}\n\nexport declare namespace assert {\n  type Options = {\n    /**\n     * Enables strict mode. Whether or not to compare the address against its checksum.\n     *\n     * @default true\n     */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = InvalidAddressError | Errors.GlobalErrorType\n}\n\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nexport function checksum(address: string): Address {\n  if (Caches.checksum.has(address)) return Caches.checksum.get(address)!\n\n  assert(address, { strict: false })\n\n  const hexAddress = address.substring(2).toLowerCase()\n  const hash = Hash.keccak256(Bytes.fromString(hexAddress), { as: 'Bytes' })\n\n  const characters = hexAddress.split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1]! >> 4 >= 8 && characters[i]) {\n      characters[i] = characters[i]!.toUpperCase()\n    }\n    if ((hash[i >> 1]! & 0x0f) >= 8 && characters[i + 1]) {\n      characters[i + 1] = characters[i + 1]!.toUpperCase()\n    }\n  }\n\n  const result = `0x${characters.join('')}` as const\n  Caches.checksum.set(address, result)\n  return result\n}\n\nexport declare namespace checksum {\n  type ErrorType =\n    | assert.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nexport function from(address: string, options: from.Options = {}): Address {\n  const { checksum: checksumVal = false } = options\n  assert(address)\n  if (checksumVal) return checksum(address)\n  return address as Address\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether to checksum the address.\n     *\n     * @default false\n     */\n    checksum?: boolean | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | checksum.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nexport function fromPublicKey(\n  publicKey: PublicKey.PublicKey,\n  options: fromPublicKey.Options = {},\n): Address {\n  const address = Hash.keccak256(\n    `0x${PublicKey.toHex(publicKey).slice(4)}`,\n  ).substring(26)\n  return from(`0x${address}`, options)\n}\n\nexport declare namespace fromPublicKey {\n  type Options = {\n    /**\n     * Whether to checksum the address.\n     *\n     * @default false\n     */\n    checksum?: boolean | undefined\n  }\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nexport function isEqual(addressA: Address, addressB: Address): boolean {\n  assert(addressA, { strict: false })\n  assert(addressB, { strict: false })\n  return addressA.toLowerCase() === addressB.toLowerCase()\n}\n\nexport declare namespace isEqual {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nexport function validate(\n  address: string,\n  options: validate.Options = {},\n): address is Address {\n  const { strict = true } = options ?? {}\n  try {\n    assert(address, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /**\n     * Enables strict mode. Whether or not to compare the address against its checksum.\n     *\n     * @default true\n     */\n    strict?: boolean | undefined\n  }\n}\n\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nexport class InvalidAddressError<\n  cause extends InvalidInputError | InvalidChecksumError =\n    | InvalidInputError\n    | InvalidChecksumError,\n> extends Errors.BaseError<cause> {\n  override readonly name = 'Address.InvalidAddressError'\n\n  constructor({ address, cause }: { address: string; cause: cause }) {\n    super(`Address \"${address}\" is invalid.`, {\n      cause,\n    })\n  }\n}\n\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nexport class InvalidInputError extends Errors.BaseError {\n  override readonly name = 'Address.InvalidInputError'\n\n  constructor() {\n    super('Address is not a 20 byte (40 hexadecimal character) value.')\n  }\n}\n\n/** Thrown when an address does not match its checksum counterpart. */\nexport class InvalidChecksumError extends Errors.BaseError {\n  override readonly name = 'Address.InvalidChecksumError'\n\n  constructor() {\n    super('Address does not match its checksum counterpart.')\n  }\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\nimport type { Compute, ExactPartial, OneOf } from './internal/types.js'\n\n/** Root type for an ECDSA signature. */\nexport type Signature<\n  recovered extends boolean = true,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  recovered extends true\n    ? {\n        r: bigintType\n        s: bigintType\n        yParity: numberType\n      }\n    : {\n        r: bigintType\n        s: bigintType\n        yParity?: numberType | undefined\n      }\n>\n\n/** RPC-formatted ECDSA signature. */\nexport type Rpc<recovered extends boolean = true> = Signature<\n  recovered,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/** (Legacy) ECDSA signature. */\nexport type Legacy<bigintType = bigint, numberType = number> = {\n  r: bigintType\n  s: bigintType\n  v: numberType\n}\n\n/** RPC-formatted (Legacy) ECDSA signature. */\nexport type LegacyRpc = Legacy<Hex.Hex, Hex.Hex>\n\nexport type Tuple = readonly [yParity: Hex.Hex, r: Hex.Hex, s: Hex.Hex]\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(\n  signature: ExactPartial<Signature>,\n  options: assert.Options = {},\n): asserts signature is Signature {\n  const { recovered } = options\n  if (typeof signature.r === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (typeof signature.s === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (recovered && typeof signature.yParity === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (signature.r < 0n || signature.r > Solidity.maxUint256)\n    throw new InvalidRError({ value: signature.r })\n  if (signature.s < 0n || signature.s > Solidity.maxUint256)\n    throw new InvalidSError({ value: signature.s })\n  if (\n    typeof signature.yParity === 'number' &&\n    signature.yParity !== 0 &&\n    signature.yParity !== 1\n  )\n    throw new InvalidYParityError({ value: signature.yParity })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType =\n    | MissingPropertiesError\n    | InvalidRError\n    | InvalidSError\n    | InvalidYParityError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature: Bytes.Bytes): Signature {\n  return fromHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature: Hex.Hex): Signature {\n  if (signature.length !== 130 && signature.length !== 132)\n    throw new InvalidSerializedSizeError({ signature })\n\n  const r = BigInt(Hex.slice(signature, 0, 32))\n  const s = BigInt(Hex.slice(signature, 32, 64))\n\n  const yParity = (() => {\n    const yParity = Number(`0x${signature.slice(130)}`)\n    if (Number.isNaN(yParity)) return undefined\n    try {\n      return vToYParity(yParity)\n    } catch {\n      throw new InvalidYParityError({ value: yParity })\n    }\n  })()\n\n  if (typeof yParity === 'undefined')\n    return {\n      r,\n      s,\n    } as never\n  return {\n    r,\n    s,\n    yParity,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType =\n    | Hex.from.ErrorType\n    | InvalidSerializedSizeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value: extract.Value): Signature | undefined {\n  if (typeof value.r === 'undefined') return undefined\n  if (typeof value.s === 'undefined') return undefined\n  return from(value as any)\n}\n\nexport declare namespace extract {\n  type Value = {\n    r?: bigint | Hex.Hex | undefined\n    s?: bigint | Hex.Hex | undefined\n    yParity?: number | Hex.Hex | undefined\n    v?: number | Hex.Hex | undefined\n  }\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from<\n  const signature extends\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n>(\n  signature:\n    | signature\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n): from.ReturnType<signature> {\n  const signature_ = (() => {\n    if (typeof signature === 'string') return fromHex(signature)\n    if (signature instanceof Uint8Array) return fromBytes(signature)\n    if (typeof signature.r === 'string') return fromRpc(signature)\n    if (signature.v) return fromLegacy(signature)\n    return {\n      r: signature.r,\n      s: signature.s,\n      ...(typeof signature.yParity !== 'undefined'\n        ? { yParity: signature.yParity }\n        : {}),\n    }\n  })()\n  assert(signature_)\n  return signature_ as never\n}\n\nexport declare namespace from {\n  type ReturnType<\n    signature extends\n      | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n      | Hex.Hex\n      | Bytes.Bytes,\n  > = signature extends Signature<boolean> & { v?: undefined }\n    ? signature\n    : Signature\n\n  type ErrorType =\n    | assert.ErrorType\n    | fromBytes.ErrorType\n    | fromHex.ErrorType\n    | vToYParity.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature: Bytes.Bytes): Signature<false> {\n  return fromDerHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature: Hex.Hex): Signature<false> {\n  const { r, s } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2))\n  return { r, s }\n}\n\nexport declare namespace fromDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature: Legacy): Signature {\n  return {\n    r: signature.r,\n    s: signature.s,\n    yParity: vToYParity(signature.v),\n  }\n}\n\nexport declare namespace fromLegacy {\n  type ErrorType = vToYParity.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature: {\n  r: Hex.Hex\n  s: Hex.Hex\n  yParity?: Hex.Hex | undefined\n  v?: Hex.Hex | undefined\n}): Signature {\n  const yParity = (() => {\n    const v = signature.v ? Number(signature.v) : undefined\n    let yParity = signature.yParity ? Number(signature.yParity) : undefined\n    if (typeof v === 'number' && typeof yParity !== 'number')\n      yParity = vToYParity(v)\n    if (typeof yParity !== 'number')\n      throw new InvalidYParityError({ value: signature.yParity })\n    return yParity\n  })()\n\n  return {\n    r: BigInt(signature.r),\n    s: BigInt(signature.s),\n    yParity,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple: Tuple): Signature {\n  const [yParity, r, s] = tuple\n  return from({\n    r: r === '0x' ? 0n : BigInt(r),\n    s: s === '0x' ? 0n : BigInt(s),\n    yParity: yParity === '0x' ? 0 : Number(yParity),\n  })\n}\n\nexport declare namespace fromTuple {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature: Signature<boolean>): Bytes.Bytes {\n  return Bytes.fromHex(toHex(signature))\n}\n\nexport declare namespace toBytes {\n  type ErrorType =\n    | toHex.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature: Signature<boolean>): Hex.Hex {\n  assert(signature)\n\n  const r = signature.r\n  const s = signature.s\n\n  const signature_ = Hex.concat(\n    Hex.fromNumber(r, { size: 32 }),\n    Hex.fromNumber(s, { size: 32 }),\n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n      ? Hex.fromNumber(yParityToV(signature.yParity), { size: 1 })\n      : '0x',\n  )\n\n  return signature_\n}\n\nexport declare namespace toHex {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature: Signature<boolean>): Bytes.Bytes {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return sig.toDERRawBytes()\n}\n\nexport declare namespace toDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature: Signature<boolean>): Hex.Hex {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return `0x${sig.toDERHex()}`\n}\n\nexport declare namespace toDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature: Signature): Legacy {\n  return {\n    r: signature.r,\n    s: signature.s,\n    v: yParityToV(signature.yParity),\n  }\n}\n\nexport declare namespace toLegacy {\n  type ErrorType = yParityToV.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature: Signature): Rpc {\n  const { r, s, yParity } = signature\n  return {\n    r: Hex.fromNumber(r, { size: 32 }),\n    s: Hex.fromNumber(s, { size: 32 }),\n    yParity: yParity === 0 ? '0x0' : '0x1',\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature: Signature): Tuple {\n  const { r, s, yParity } = signature\n\n  return [\n    yParity ? '0x01' : '0x',\n    r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r!)),\n    s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s!)),\n  ] as const\n}\n\nexport declare namespace toTuple {\n  type ErrorType =\n    | Hex.trimLeft.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(\n  signature: ExactPartial<Signature>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(signature, options)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v: number): Signature['yParity'] {\n  if (v === 0 || v === 27) return 0\n  if (v === 1 || v === 28) return 1\n  if (v >= 35) return v % 2 === 0 ? 1 : 0\n  throw new InvalidVError({ value: v })\n}\n\nexport declare namespace vToYParity {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity: number): number {\n  if (yParity === 0) return 27\n  if (yParity === 1) return 28\n  throw new InvalidYParityError({ value: yParity })\n}\n\nexport declare namespace yParityToV {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSerializedSizeError'\n\n  constructor({ signature }: { signature: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${signature}\\` is an invalid signature size.`, {\n      metaMessages: [\n        'Expected: 64 bytes or 65 bytes.',\n        `Received ${Hex.size(Hex.from(signature))} bytes.`,\n      ],\n    })\n  }\n}\n\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n  override readonly name = 'Signature.MissingPropertiesError'\n\n  constructor({ signature }: { signature: unknown }) {\n    super(\n      `Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidRError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidYParityError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidVError'\n\n  constructor({ value }: { value: number }) {\n    super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`)\n  }\n}\n","import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Cursor from './internal/cursor.js'\nimport type { ExactPartial, RecursiveArray } from './internal/types.js'\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nexport function toBytes(\n  value: Bytes.Bytes | Hex.Hex,\n): RecursiveArray<Bytes.Bytes> {\n  return to(value, 'Bytes')\n}\n\nexport declare namespace toBytes {\n  type ErrorType = to.ErrorType\n}\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value: Bytes.Bytes | Hex.Hex): RecursiveArray<Hex.Hex> {\n  return to(value, 'Hex')\n}\n\nexport declare namespace toHex {\n  type ErrorType = to.ErrorType\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport function to<\n  value extends Bytes.Bytes | Hex.Hex,\n  to extends 'Hex' | 'Bytes',\n>(value: value, to: to | 'Hex' | 'Bytes'): to.ReturnType<to> {\n  const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes')\n\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0)\n        throw new Hex.InvalidLengthError(value)\n      return Bytes.fromHex(value)\n    }\n    return value as Bytes.Bytes\n  })()\n\n  const cursor = Cursor.create(bytes, {\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n  })\n  const result = decodeRlpCursor(cursor, to_)\n\n  return result as to.ReturnType<to>\n}\n\n/** @internal */\nexport declare namespace to {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (to extends 'Bytes' ? RecursiveArray<Bytes.Bytes> : never)\n    | (to extends 'Hex' ? RecursiveArray<Hex.Hex> : never)\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | decodeRlpCursor.ErrorType\n    | Cursor.create.ErrorType\n    | Hex.InvalidLengthError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\n\n/** @internal */\nexport function decodeRlpCursor<to extends 'Hex' | 'Bytes' = 'Hex'>(\n  cursor: Cursor.Cursor,\n  to: to | 'Hex' | 'Bytes' | undefined = 'Hex',\n): decodeRlpCursor.ReturnType<to> {\n  if (cursor.bytes.length === 0)\n    return (\n      to === 'Hex' ? Hex.fromBytes(cursor.bytes) : cursor.bytes\n    ) as decodeRlpCursor.ReturnType<to>\n\n  const prefix = cursor.readByte()\n  if (prefix < 0x80) cursor.decrementPosition(1)\n\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80)\n    const bytes = cursor.readBytes(length)\n    return (\n      to === 'Hex' ? Hex.fromBytes(bytes) : bytes\n    ) as decodeRlpCursor.ReturnType<to>\n  }\n\n  // list\n  const length = readLength(cursor, prefix, 0xc0)\n  return readList(cursor, length, to) as {} as decodeRlpCursor.ReturnType<to>\n}\n\n/** @internal */\nexport declare namespace decodeRlpCursor {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex'> = to.ReturnType<to>\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | readLength.ErrorType\n    | readList.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function readLength(\n  cursor: Cursor.Cursor,\n  prefix: number,\n  offset: number,\n) {\n  if (offset === 0x80 && prefix < 0x80) return 1\n  if (prefix <= offset + 55) return prefix - offset\n  if (prefix === offset + 55 + 1) return cursor.readUint8()\n  if (prefix === offset + 55 + 2) return cursor.readUint16()\n  if (prefix === offset + 55 + 3) return cursor.readUint24()\n  if (prefix === offset + 55 + 4) return cursor.readUint32()\n  throw new Errors.BaseError('Invalid RLP prefix')\n}\n\n/** @internal */\nexport declare namespace readLength {\n  type ErrorType = Errors.BaseError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function readList<to extends 'Hex' | 'Bytes'>(\n  cursor: Cursor.Cursor,\n  length: number,\n  to: to | 'Hex' | 'Bytes',\n) {\n  const position = cursor.position\n  const value: decodeRlpCursor.ReturnType<to>[] = []\n  while (cursor.position - position < length)\n    value.push(decodeRlpCursor(cursor, to))\n  return value\n}\n\n/** @internal */\nexport declare namespace readList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor.Cursor): void\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function from<as extends 'Hex' | 'Bytes'>(\n  value: RecursiveArray<Bytes.Bytes> | RecursiveArray<Hex.Hex>,\n  options: from.Options<as>,\n): from.ReturnType<as> {\n  const { as } = options\n\n  const encodable = getEncodable(value)\n  const cursor = Cursor.create(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (as === 'Hex') return Hex.fromBytes(cursor.bytes) as from.ReturnType<as>\n  return cursor.bytes as from.ReturnType<as>\n}\n\nexport declare namespace from {\n  type Options<as extends 'Hex' | 'Bytes'> = {\n    /** The type to convert the RLP value to. */\n    as: as | 'Hex' | 'Bytes'\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Cursor.create.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromBytes<as extends 'Hex' | 'Bytes' = 'Bytes'>(\n  bytes: RecursiveArray<Bytes.Bytes>,\n  options: fromBytes.Options<as> = {},\n): fromBytes.ReturnType<as> {\n  const { as = 'Bytes' } = options\n  return from(bytes, { as }) as never\n}\n\nexport declare namespace fromBytes {\n  type Options<as extends 'Hex' | 'Bytes' = 'Bytes'> = ExactPartial<\n    from.Options<as>\n  >\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Bytes'> = from.ReturnType<as>\n\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromHex<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  hex: RecursiveArray<Hex.Hex>,\n  options: fromHex.Options<as> = {},\n): fromHex.ReturnType<as> {\n  const { as = 'Hex' } = options\n  return from(hex, { as }) as never\n}\n\nexport declare namespace fromHex {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = ExactPartial<\n    from.Options<as>\n  >\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = from.ReturnType<as>\n\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n\nfunction getEncodable(\n  bytes: RecursiveArray<Bytes.Bytes> | RecursiveArray<Hex.Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor.Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: Bytes.Bytes | Hex.Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? Bytes.fromHex(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0]! < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor.Cursor) {\n      if (bytes.length === 1 && bytes[0]! < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new Errors.BaseError('Length is too large.')\n}\n","import type { Bytes } from '../Bytes.js'\nimport * as Errors from '../Errors.js'\n\n/** @internal */\nexport type Cursor = {\n  bytes: Bytes\n  dataView: DataView\n  position: number\n  positionReadCount: Map<number, number>\n  recursiveReadCount: number\n  recursiveReadLimit: number\n  remaining: number\n  assertReadLimit(position?: number): void\n  assertPosition(position: number): void\n  decrementPosition(offset: number): void\n  getReadCount(position?: number): number\n  incrementPosition(offset: number): void\n  inspectByte(position?: number): Bytes[number]\n  inspectBytes(length: number, position?: number): Bytes\n  inspectUint8(position?: number): number\n  inspectUint16(position?: number): number\n  inspectUint24(position?: number): number\n  inspectUint32(position?: number): number\n  pushByte(byte: Bytes[number]): void\n  pushBytes(bytes: Bytes): void\n  pushUint8(value: number): void\n  pushUint16(value: number): void\n  pushUint24(value: number): void\n  pushUint32(value: number): void\n  readByte(): Bytes[number]\n  readBytes(length: number, size?: number): Bytes\n  readUint8(): number\n  readUint16(): number\n  readUint24(): number\n  readUint32(): number\n  setPosition(position: number): () => void\n  _touch(): void\n}\n\nconst staticCursor: Cursor = /*#__PURE__*/ {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit)\n      throw new RecursiveReadLimitExceededError({\n        count: this.recursiveReadCount + 1,\n        limit: this.recursiveReadLimit,\n      })\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1)\n      throw new PositionOutOfBoundsError({\n        length: this.bytes.length,\n        position,\n      })\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position - offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position + offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]!\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + length - 1)\n    return this.bytes.subarray(position, position + length)\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]!\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 1)\n    return this.dataView.getUint16(position)\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 2)\n    return (\n      (this.dataView.getUint16(position) << 8) +\n      this.dataView.getUint8(position + 2)\n    )\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 3)\n    return this.dataView.getUint32(position)\n  },\n  pushByte(byte: Bytes[number]) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = byte\n    this.position++\n  },\n  pushBytes(bytes: Bytes) {\n    this.assertPosition(this.position + bytes.length - 1)\n    this.bytes.set(bytes, this.position)\n    this.position += bytes.length\n  },\n  pushUint8(value: number) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = value\n    this.position++\n  },\n  pushUint16(value: number) {\n    this.assertPosition(this.position + 1)\n    this.dataView.setUint16(this.position, value)\n    this.position += 2\n  },\n  pushUint24(value: number) {\n    this.assertPosition(this.position + 2)\n    this.dataView.setUint16(this.position, value >> 8)\n    this.dataView.setUint8(this.position + 2, value & ~4294967040)\n    this.position += 3\n  },\n  pushUint32(value: number) {\n    this.assertPosition(this.position + 3)\n    this.dataView.setUint32(this.position, value)\n    this.position += 4\n  },\n  readByte() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectByte()\n    this.position++\n    return value\n  },\n  readBytes(length, size) {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectBytes(length)\n    this.position += size ?? length\n    return value\n  },\n  readUint8() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint8()\n    this.position += 1\n    return value\n  },\n  readUint16() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint16()\n    this.position += 2\n    return value\n  },\n  readUint24() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint24()\n    this.position += 3\n    return value\n  },\n  readUint32() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint32()\n    this.position += 4\n    return value\n  },\n  get remaining() {\n    return this.bytes.length - this.position\n  },\n  setPosition(position) {\n    const oldPosition = this.position\n    this.assertPosition(position)\n    this.position = position\n    return () => (this.position = oldPosition)\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return\n    const count = this.getReadCount()\n    this.positionReadCount.set(this.position, count + 1)\n    if (count > 0) this.recursiveReadCount++\n  },\n}\n\n/** @internal */\nexport function create(\n  bytes: Bytes,\n  { recursiveReadLimit = 8_192 }: create.Config = {},\n): Cursor {\n  const cursor: Cursor = Object.create(staticCursor)\n  cursor.bytes = bytes\n  cursor.dataView = new DataView(\n    bytes.buffer,\n    bytes.byteOffset,\n    bytes.byteLength,\n  )\n  cursor.positionReadCount = new Map()\n  cursor.recursiveReadLimit = recursiveReadLimit\n  return cursor\n}\n\n/** @internal */\nexport declare namespace create {\n  type Config = { recursiveReadLimit?: number | undefined }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport class NegativeOffsetError extends Errors.BaseError {\n  override readonly name = 'Cursor.NegativeOffsetError'\n\n  constructor({ offset }: { offset: number }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`)\n  }\n}\n\n/** @internal */\nexport class PositionOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Cursor.PositionOutOfBoundsError'\n\n  constructor({ length, position }: { length: number; position: number }) {\n    super(\n      `Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`,\n    )\n  }\n}\n\n/** @internal */\nexport class RecursiveReadLimitExceededError extends Errors.BaseError {\n  override readonly name = 'Cursor.RecursiveReadLimitExceededError'\n\n  constructor({ count, limit }: { count: number; limit: number }) {\n    super(\n      `Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`,\n    )\n  }\n}\n","import type * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport type { Compute, Mutable, Undefined } from './internal/types.js'\n\n/** Root type for an EIP-7702 Authorization. */\nexport type Authorization<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  {\n    /** Address of the contract to set as code for the Authority. */\n    address: Address.Address\n    /** Chain ID to authorize. */\n    chainId: numberType\n    /** Nonce of the Authority to authorize. */\n    nonce: bigintType\n  } & (signed extends true\n    ? Signature.Signature<true, bigintType, numberType>\n    : Undefined<Signature.Signature>)\n>\n\n/** RPC representation of an {@link ox#Authorization.Authorization}. */\nexport type Rpc = Authorization<true, Hex.Hex, Hex.Hex>\n\n/** List of {@link ox#Authorization.Authorization}. */\nexport type List<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<readonly Authorization<signed, bigintType, numberType>[]>\n\n/** RPC representation of an {@link ox#Authorization.List}. */\nexport type ListRpc = List<true, Hex.Hex, Hex.Hex>\n\n/** Signed representation of a list of {@link ox#Authorization.Authorization}. */\nexport type ListSigned<bigintType = bigint, numberType = number> = List<\n  true,\n  bigintType,\n  numberType\n>\n\n/** Signed representation of an {@link ox#Authorization.Authorization}. */\nexport type Signed<bigintType = bigint, numberType = number> = Authorization<\n  true,\n  bigintType,\n  numberType\n>\n\n/** Tuple representation of an {@link ox#Authorization.Authorization}. */\nexport type Tuple<signed extends boolean = boolean> = signed extends true\n  ? readonly [\n      chainId: Hex.Hex,\n      address: Hex.Hex,\n      nonce: Hex.Hex,\n      yParity: Hex.Hex,\n      r: Hex.Hex,\n      s: Hex.Hex,\n    ]\n  : readonly [chainId: Hex.Hex, address: Hex.Hex, nonce: Hex.Hex]\n\n/** Tuple representation of a signed {@link ox#Authorization.Authorization}. */\nexport type TupleSigned = Tuple<true>\n\n/** Tuple representation of a list of {@link ox#Authorization.Authorization}. */\nexport type TupleList<signed extends boolean = boolean> =\n  readonly Tuple<signed>[]\n\n/** Tuple representation of a list of signed {@link ox#Authorization.Authorization}. */\nexport type TupleListSigned = TupleList<true>\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nexport function from<\n  const authorization extends Authorization | Rpc,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  authorization: authorization | Authorization,\n  options: from.Options<signature> = {},\n): from.ReturnType<authorization, signature> {\n  if (typeof authorization.chainId === 'string')\n    return fromRpc(authorization) as never\n  return { ...authorization, ...options.signature } as never\n}\n\nexport declare namespace from {\n  type Options<\n    signature extends Signature.Signature | undefined =\n      | Signature.Signature\n      | undefined,\n  > = {\n    /** The {@link ox#Signature.Signature} to attach to the Authorization. */\n    signature?: signature | Signature.Signature | undefined\n  }\n\n  type ReturnType<\n    authorization extends Authorization | Rpc = Authorization,\n    signature extends Signature.Signature | undefined =\n      | Signature.Signature\n      | undefined,\n  > = Compute<\n    authorization extends Rpc\n      ? Signed\n      : authorization &\n          (signature extends Signature.Signature ? Readonly<signature> : {})\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */\nexport function fromRpc(authorization: Rpc): Signed {\n  const { address, chainId, nonce } = authorization\n  const signature = Signature.extract(authorization)!\n\n  return {\n    address,\n    chainId: Number(chainId),\n    nonce: BigInt(nonce),\n    ...signature,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */\nexport function fromRpcList(authorizationList: ListRpc): ListSigned {\n  return authorizationList.map(fromRpc)\n}\n\nexport declare namespace fromRpcList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nexport function fromTuple<const tuple extends Tuple>(\n  tuple: tuple,\n): fromTuple.ReturnType<tuple> {\n  const [chainId, address, nonce, yParity, r, s] = tuple\n  const signature =\n    yParity && r && s ? Signature.fromTuple([yParity, r, s]) : undefined\n  return from({\n    address,\n    chainId: Number(chainId),\n    nonce: BigInt(nonce),\n    ...signature,\n  }) as never\n}\n\nexport declare namespace fromTuple {\n  type ReturnType<authorization extends Tuple = Tuple> = Compute<\n    Authorization<authorization extends Tuple<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */\nexport function fromTupleList<const tupleList extends TupleList>(\n  tupleList: tupleList,\n): fromTupleList.ReturnType<tupleList> {\n  const list: Mutable<List> = []\n  for (const tuple of tupleList) list.push(fromTuple(tuple))\n  return list as never\n}\n\nexport declare namespace fromTupleList {\n  type ReturnType<tupleList extends TupleList> = Compute<\n    TupleList<tupleList extends TupleList<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */\nexport function getSignPayload(authorization: Authorization): Hex.Hex {\n  return hash(authorization)\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */\nexport function hash(authorization: Authorization): Hex.Hex {\n  return Hash.keccak256(Hex.concat('0x05', Rlp.fromHex(toTuple(authorization))))\n}\n\nexport declare namespace hash {\n  type ErrorType =\n    | toTuple.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */\nexport function toRpc(authorization: Signed): Rpc {\n  const { address, chainId, nonce, ...signature } = authorization\n\n  return {\n    address,\n    chainId: Hex.fromNumber(chainId),\n    nonce: Hex.fromNumber(nonce),\n    ...Signature.toRpc(signature),\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */\nexport function toRpcList(authorizationList: ListSigned): ListRpc {\n  return authorizationList.map(toRpc)\n}\n\nexport declare namespace toRpcList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */\nexport function toTuple<const authorization extends Authorization>(\n  authorization: authorization,\n): toTuple.ReturnType<authorization> {\n  const { address, chainId, nonce } = authorization\n  const signature = Signature.extract(authorization)\n  return [\n    chainId ? Hex.fromNumber(chainId) : '0x',\n    address,\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    ...(signature ? Signature.toTuple(signature) : []),\n  ] as never\n}\n\nexport declare namespace toTuple {\n  type ReturnType<authorization extends Authorization = Authorization> =\n    Compute<Tuple<authorization extends Signature.Signature ? true : false>>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */\nexport function toTupleList<\n  const list extends\n    | readonly Authorization<true>[]\n    | readonly Authorization<false>[],\n>(list?: list | undefined): toTupleList.ReturnType<list> {\n  if (!list || list.length === 0) return []\n\n  const tupleList: Mutable<TupleList> = []\n  for (const authorization of list) tupleList.push(toTuple(authorization))\n\n  return tupleList as never\n}\n\nexport declare namespace toTupleList {\n  type ReturnType<\n    list extends\n      | readonly Authorization<true>[]\n      | readonly Authorization<false>[],\n  > = Compute<\n    TupleList<list extends readonly Authorization<true>[] ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"names":[],"mappings":"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","ignoreList":[2,3,7,8]}