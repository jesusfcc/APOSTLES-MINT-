{"version":3,"sources":["../../../../node_modules/abitype/src/version.ts","../../../../node_modules/abitype/src/errors.ts","../../../../node_modules/abitype/src/human-readable/errors/abiItem.ts","../../../../node_modules/abitype/src/regex.ts","../../../../node_modules/abitype/src/human-readable/runtime/signatures.ts","../../../../node_modules/abitype/src/human-readable/errors/abiParameter.ts","../../../../node_modules/abitype/src/human-readable/runtime/structs.ts","../../../../node_modules/abitype/src/human-readable/errors/struct.ts","../../../../node_modules/abitype/src/human-readable/errors/splitParameters.ts","../../../../node_modules/abitype/src/human-readable/runtime/utils.ts","../../../../node_modules/abitype/src/human-readable/errors/signature.ts","../../../../node_modules/abitype/src/human-readable/runtime/cache.ts","../../../../node_modules/abitype/src/human-readable/formatAbiParameter.ts","../../../../node_modules/abitype/src/human-readable/formatAbiParameters.ts"],"sourcesContent":["export const version = '1.0.8'\n","import type { OneOf, Pretty } from './types.js'\nimport { version } from './version.js'\n\ntype BaseErrorArgs = Pretty<\n  {\n    docsPath?: string | undefined\n    metaMessages?: string[] | undefined\n  } & OneOf<{ details?: string | undefined } | { cause?: BaseError | Error }>\n>\n\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n\n  override name = 'AbiTypeError'\n\n  constructor(shortMessage: string, args: BaseErrorArgs = {}) {\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n          ? args.cause.message\n          : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: abitype@${version}`,\n    ].join('\\n')\n\n    super(message)\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n}\n","import { BaseError } from '../../errors.js'\n\nexport class InvalidAbiItemError extends BaseError {\n  override name = 'InvalidAbiItemError'\n\n  constructor({ signature }: { signature: string | object }) {\n    super('Failed to parse ABI item.', {\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n      docsPath: '/api/human#parseabiitem-1',\n    })\n  }\n}\n\nexport class UnknownTypeError extends BaseError {\n  override name = 'UnknownTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [\n        `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n      ],\n    })\n  }\n}\n\nexport class UnknownSolidityTypeError extends BaseError {\n  override name = 'UnknownSolidityTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n    })\n  }\n}\n","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n","import type { AbiStateMutability } from '../../abi.js'\nimport { execTyped } from '../../regex.js'\nimport type {\n  EventModifier,\n  FunctionModifier,\n  Modifier,\n} from '../types/signatures.js'\n\n// https://regexr.com/7gmok\nconst errorSignatureRegex =\n  /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isErrorSignature(signature: string) {\n  return errorSignatureRegex.test(signature)\n}\nexport function execErrorSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    errorSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmoq\nconst eventSignatureRegex =\n  /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isEventSignature(signature: string) {\n  return eventSignatureRegex.test(signature)\n}\nexport function execEventSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    eventSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmot\nconst functionSignatureRegex =\n  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/\nexport function isFunctionSignature(signature: string) {\n  return functionSignatureRegex.test(signature)\n}\nexport function execFunctionSignature(signature: string) {\n  return execTyped<{\n    name: string\n    parameters: string\n    stateMutability?: AbiStateMutability\n    returns?: string\n  }>(functionSignatureRegex, signature)\n}\n\n// https://regexr.com/7gmp3\nconst structSignatureRegex =\n  /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/\nexport function isStructSignature(signature: string) {\n  return structSignatureRegex.test(signature)\n}\nexport function execStructSignature(signature: string) {\n  return execTyped<{ name: string; properties: string }>(\n    structSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/78u01\nconst constructorSignatureRegex =\n  /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isConstructorSignature(signature: string) {\n  return constructorSignatureRegex.test(signature)\n}\nexport function execConstructorSignature(signature: string) {\n  return execTyped<{\n    parameters: string\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\n  }>(constructorSignatureRegex, signature)\n}\n\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex =\n  /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isFallbackSignature(signature: string) {\n  return fallbackSignatureRegex.test(signature)\n}\nexport function execFallbackSignature(signature: string) {\n  return execTyped<{\n    parameters: string\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\n  }>(fallbackSignatureRegex, signature)\n}\n\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/\nexport function isReceiveSignature(signature: string) {\n  return receiveSignatureRegex.test(signature)\n}\n\nexport const modifiers = new Set<Modifier>([\n  'memory',\n  'indexed',\n  'storage',\n  'calldata',\n])\nexport const eventModifiers = new Set<EventModifier>(['indexed'])\nexport const functionModifiers = new Set<FunctionModifier>([\n  'calldata',\n  'memory',\n  'storage',\n])\n","import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\nimport type { Modifier } from '../types/signatures.js'\n\nexport class InvalidAbiParameterError extends BaseError {\n  override name = 'InvalidAbiParameterError'\n\n  constructor({ param }: { param: string | object }) {\n    super('Failed to parse ABI parameter.', {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: '/api/human#parseabiparameter-1',\n    })\n  }\n}\n\nexport class InvalidAbiParametersError extends BaseError {\n  override name = 'InvalidAbiParametersError'\n\n  constructor({ params }: { params: string | object }) {\n    super('Failed to parse ABI parameters.', {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: '/api/human#parseabiparameters-1',\n    })\n  }\n}\n\nexport class InvalidParameterError extends BaseError {\n  override name = 'InvalidParameterError'\n\n  constructor({ param }: { param: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n    })\n  }\n}\n\nexport class SolidityProtectedKeywordError extends BaseError {\n  override name = 'SolidityProtectedKeywordError'\n\n  constructor({ param, name }: { param: string; name: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n      ],\n    })\n  }\n}\n\nexport class InvalidModifierError extends BaseError {\n  override name = 'InvalidModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidFunctionModifierError extends BaseError {\n  override name = 'InvalidFunctionModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n        `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidAbiTypeParameterError extends BaseError {\n  override name = 'InvalidAbiTypeParameterError'\n\n  constructor({\n    abiParameter,\n  }: {\n    abiParameter: AbiParameter & { indexed?: boolean | undefined }\n  }) {\n    super('Invalid ABI parameter.', {\n      details: JSON.stringify(abiParameter, null, 2),\n      metaMessages: ['ABI parameter type is invalid.'],\n    })\n  }\n}\n","import type { AbiParameter } from '../../abi.js'\nimport { execTyped, isTupleRegex } from '../../regex.js'\nimport { UnknownTypeError } from '../errors/abiItem.js'\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n} from '../errors/signature.js'\nimport { CircularReferenceError } from '../errors/struct.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { execStructSignature, isStructSignature } from './signatures.js'\nimport { isSolidityType, parseAbiParameter } from './utils.js'\n\nexport function parseStructs(signatures: readonly string[]) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs: StructLookup = {}\n  const signaturesLength = signatures.length\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i]!\n    if (!isStructSignature(signature)) continue\n\n    const match = execStructSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\n\n    const properties = match.properties.split(';')\n\n    const components: AbiParameter[] = []\n    const propertiesLength = properties.length\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k]!\n      const trimmed = property.trim()\n      if (!trimmed) continue\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct',\n      })\n      components.push(abiParameter)\n    }\n\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\n    shallowStructs[match.name] = components\n  }\n\n  // Resolve nested structs inside each parameter\n  const resolvedStructs: StructLookup = {}\n  const entries = Object.entries(shallowStructs)\n  const entriesLength = entries.length\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i]!\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\n  }\n\n  return resolvedStructs\n}\n\nconst typeWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\n\nfunction resolveStructs(\n  abiParameters: readonly (AbiParameter & { indexed?: true })[],\n  structs: StructLookup,\n  ancestors = new Set<string>(),\n) {\n  const components: AbiParameter[] = []\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    const isTuple = isTupleRegex.test(abiParameter.type)\n    if (isTuple) components.push(abiParameter)\n    else {\n      const match = execTyped<{ array?: string; type: string }>(\n        typeWithoutTupleRegex,\n        abiParameter.type,\n      )\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\n\n      const { array, type } = match\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\n\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            new Set([...ancestors, type]),\n          ),\n        })\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter)\n        else throw new UnknownTypeError({ type })\n      }\n    }\n  }\n\n  return components\n}\n","import { BaseError } from '../../errors.js'\n\nexport class CircularReferenceError extends BaseError {\n  override name = 'CircularReferenceError'\n\n  constructor({ type }: { type: string }) {\n    super('Circular reference detected.', {\n      metaMessages: [`Struct \"${type}\" is a circular reference.`],\n    })\n  }\n}\n","import { BaseError } from '../../errors.js'\n\nexport class InvalidParenthesisError extends BaseError {\n  override name = 'InvalidParenthesisError'\n\n  constructor({ current, depth }: { current: string; depth: number }) {\n    super('Unbalanced parentheses.', {\n      metaMessages: [\n        `\"${current.trim()}\" has too many ${\n          depth > 0 ? 'opening' : 'closing'\n        } parentheses.`,\n      ],\n      details: `Depth \"${depth}\"`,\n    })\n  }\n}\n","import type {\n  AbiItemType,\n  AbiType,\n  SolidityArray,\n  SolidityBytes,\n  SolidityString,\n  SolidityTuple,\n} from '../../abi.js'\nimport {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex,\n} from '../../regex.js'\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\nimport {\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  SolidityProtectedKeywordError,\n} from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  UnknownSignatureError,\n} from '../errors/signature.js'\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { getParameterCacheKey, parameterCache } from './cache.js'\nimport {\n  eventModifiers,\n  execConstructorSignature,\n  execErrorSignature,\n  execEventSignature,\n  execFallbackSignature,\n  execFunctionSignature,\n  functionModifiers,\n  isConstructorSignature,\n  isErrorSignature,\n  isEventSignature,\n  isFallbackSignature,\n  isFunctionSignature,\n  isReceiveSignature,\n} from './signatures.js'\n\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\n  if (isFunctionSignature(signature))\n    return parseFunctionSignature(signature, structs)\n\n  if (isEventSignature(signature))\n    return parseEventSignature(signature, structs)\n\n  if (isErrorSignature(signature))\n    return parseErrorSignature(signature, structs)\n\n  if (isConstructorSignature(signature))\n    return parseConstructorSignature(signature, structs)\n\n  if (isFallbackSignature(signature)) return parseFallbackSignature(signature)\n\n  if (isReceiveSignature(signature))\n    return {\n      type: 'receive',\n      stateMutability: 'payable',\n    }\n\n  throw new UnknownSignatureError({ signature })\n}\n\nexport function parseFunctionSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execFunctionSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\n\n  const inputParams = splitParameters(match.parameters)\n  const inputs = []\n  const inputLength = inputParams.length\n  for (let i = 0; i < inputLength; i++) {\n    inputs.push(\n      parseAbiParameter(inputParams[i]!, {\n        modifiers: functionModifiers,\n        structs,\n        type: 'function',\n      }),\n    )\n  }\n\n  const outputs = []\n  if (match.returns) {\n    const outputParams = splitParameters(match.returns)\n    const outputLength = outputParams.length\n    for (let i = 0; i < outputLength; i++) {\n      outputs.push(\n        parseAbiParameter(outputParams[i]!, {\n          modifiers: functionModifiers,\n          structs,\n          type: 'function',\n        }),\n      )\n    }\n  }\n\n  return {\n    name: match.name,\n    type: 'function',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs,\n    outputs,\n  }\n}\n\nexport function parseEventSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execEventSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, {\n        modifiers: eventModifiers,\n        structs,\n        type: 'event',\n      }),\n    )\n  return { name: match.name, type: 'event', inputs: abiParameters }\n}\n\nexport function parseErrorSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execErrorSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, { structs, type: 'error' }),\n    )\n  return { name: match.name, type: 'error', inputs: abiParameters }\n}\n\nexport function parseConstructorSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execConstructorSignature(signature)\n  if (!match)\n    throw new InvalidSignatureError({ signature, type: 'constructor' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\n    )\n  return {\n    type: 'constructor',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs: abiParameters,\n  }\n}\n\nexport function parseFallbackSignature(signature: string) {\n  const match = execFallbackSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'fallback' })\n\n  return {\n    type: 'fallback',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n  }\n}\n\nconst abiParameterWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst abiParameterWithTupleRegex =\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst dynamicIntegerRegex = /^u?int$/\n\ntype ParseOptions = {\n  modifiers?: Set<Modifier>\n  structs?: StructLookup\n  type?: AbiItemType | 'struct'\n}\n\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(\n    param,\n    options?.type,\n    options?.structs,\n  )\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey)!\n\n  const isTuple = isTupleRegex.test(param)\n  const match = execTyped<{\n    array?: string\n    modifier?: Modifier\n    name?: string\n    type: string\n  }>(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param,\n  )\n  if (!match) throw new InvalidParameterError({ param })\n\n  if (match.name && isSolidityKeyword(match.name))\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\n\n  const name = match.name ? { name: match.name } : {}\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\n  const structs = options?.structs ?? {}\n  let type: string\n  let components = {}\n  if (isTuple) {\n    type = 'tuple'\n    const params = splitParameters(match.type)\n    const components_ = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i]!, { structs }))\n    }\n    components = { components: components_ }\n  } else if (match.type in structs) {\n    type = 'tuple'\n    components = { components: structs[match.type] }\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`\n  } else {\n    type = match.type\n    if (!(options?.type === 'struct') && !isSolidityType(type))\n      throw new UnknownSolidityTypeError({ type })\n  }\n\n  if (match.modifier) {\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new InvalidModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n\n    // Check if resolved `type` is valid if there is a function modifier\n    if (\n      functionModifiers.has(match.modifier as FunctionModifier) &&\n      !isValidDataLocation(type, !!match.array)\n    )\n      throw new InvalidFunctionModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n  }\n\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components,\n  }\n  parameterCache.set(parameterCacheKey, abiParameter)\n  return abiParameter\n}\n\n// s/o latika for this\nexport function splitParameters(\n  params: string,\n  result: string[] = [],\n  current = '',\n  depth = 0,\n): readonly string[] {\n  const length = params.trim().length\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i]\n    const tail = params.slice(i + 1)\n    switch (char) {\n      case ',':\n        return depth === 0\n          ? splitParameters(tail, [...result, current.trim()])\n          : splitParameters(tail, result, `${current}${char}`, depth)\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth)\n    }\n  }\n\n  if (current === '') return result\n  if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\n\n  result.push(current.trim())\n  return result\n}\n\nexport function isSolidityType(\n  type: string,\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\n  return (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'function' ||\n    type === 'string' ||\n    bytesRegex.test(type) ||\n    integerRegex.test(type)\n  )\n}\n\nconst protectedKeywordsRegex =\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\n\n/** @internal */\nexport function isSolidityKeyword(name: string) {\n  return (\n    name === 'address' ||\n    name === 'bool' ||\n    name === 'function' ||\n    name === 'string' ||\n    name === 'tuple' ||\n    bytesRegex.test(name) ||\n    integerRegex.test(name) ||\n    protectedKeywordsRegex.test(name)\n  )\n}\n\n/** @internal */\nexport function isValidDataLocation(\n  type: string,\n  isArray: boolean,\n): type is Exclude<\n  AbiType,\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\n> {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\n}\n","import type { AbiItemType } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\n\nexport class InvalidSignatureError extends BaseError {\n  override name = 'InvalidSignatureError'\n\n  constructor({\n    signature,\n    type,\n  }: {\n    signature: string\n    type: AbiItemType | 'struct'\n  }) {\n    super(`Invalid ${type} signature.`, {\n      details: signature,\n    })\n  }\n}\n\nexport class UnknownSignatureError extends BaseError {\n  override name = 'UnknownSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Unknown signature.', {\n      details: signature,\n    })\n  }\n}\n\nexport class InvalidStructSignatureError extends BaseError {\n  override name = 'InvalidStructSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Invalid struct signature.', {\n      details: signature,\n      metaMessages: ['No properties exist.'],\n    })\n  }\n}\n","import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport type { StructLookup } from '../types/structs.js'\n\n/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(\n  param: string,\n  type?: AbiItemType | 'struct',\n  structs?: StructLookup,\n) {\n  let structKey = ''\n  if (structs)\n    for (const struct of Object.entries(structs)) {\n      if (!struct) continue\n      let propertyKey = ''\n      for (const property of struct[1]) {\n        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`\n      }\n      structKey += `(${struct[0]}{${propertyKey}})`\n    }\n  if (type) return `${type}:${param}${structKey}`\n  return param\n}\n\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map<\n  string,\n  AbiParameter & { indexed?: boolean }\n>([\n  // Unnamed\n  ['address', { type: 'address' }],\n  ['bool', { type: 'bool' }],\n  ['bytes', { type: 'bytes' }],\n  ['bytes32', { type: 'bytes32' }],\n  ['int', { type: 'int256' }],\n  ['int256', { type: 'int256' }],\n  ['string', { type: 'string' }],\n  ['uint', { type: 'uint256' }],\n  ['uint8', { type: 'uint8' }],\n  ['uint16', { type: 'uint16' }],\n  ['uint24', { type: 'uint24' }],\n  ['uint32', { type: 'uint32' }],\n  ['uint64', { type: 'uint64' }],\n  ['uint96', { type: 'uint96' }],\n  ['uint112', { type: 'uint112' }],\n  ['uint160', { type: 'uint160' }],\n  ['uint192', { type: 'uint192' }],\n  ['uint256', { type: 'uint256' }],\n\n  // Named\n  ['address owner', { type: 'address', name: 'owner' }],\n  ['address to', { type: 'address', name: 'to' }],\n  ['bool approved', { type: 'bool', name: 'approved' }],\n  ['bytes _data', { type: 'bytes', name: '_data' }],\n  ['bytes data', { type: 'bytes', name: 'data' }],\n  ['bytes signature', { type: 'bytes', name: 'signature' }],\n  ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n  ['bytes32 r', { type: 'bytes32', name: 'r' }],\n  ['bytes32 root', { type: 'bytes32', name: 'root' }],\n  ['bytes32 s', { type: 'bytes32', name: 's' }],\n  ['string name', { type: 'string', name: 'name' }],\n  ['string symbol', { type: 'string', name: 'symbol' }],\n  ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n  ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint8 v', { type: 'uint8', name: 'v' }],\n  ['uint256 balance', { type: 'uint256', name: 'balance' }],\n  ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint256 value', { type: 'uint256', name: 'value' }],\n\n  // Indexed\n  [\n    'event:address indexed from',\n    { type: 'address', name: 'from', indexed: true },\n  ],\n  ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n  [\n    'event:uint indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n  [\n    'event:uint256 indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n])\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<abiParameters>\n}\n"],"names":[],"mappings":"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C,CAAC,AAX6C,CAY/C,oPC5GD,IAAA,EGWE,CHXK,AIAA,AFDA,ACQA,AFRA,CEaA,CFbE,ACAA,ACSP,ACRO,AJAA,AGYF,CAAA,MHZiD,CAAA,CCDtC,ACAA,AECA,AJAA,AGWJ,AHVd,CGOY,CHRQ,AIAA,AHDA,ACAA,ADEd,AGCA,AFDA,CCQJ,AAGD,CDXK,CCWiB,ADXjB,CCWiB,ADXjB,EDFoB,ACAA,AECA,CDYnB,GAHI,EHTqB,AAEhC,AGQE,EHRF,AAFkC,EAElC,CAAA,CAAA,EAFwC,GIAG,AFDA,ADAA,CEW7B,ADX6B,ADAA,AGCA,+BAEA,EAAA,SAAS,yBAIvC,MACT,CAAI,CAIL,CJTkC,kBIUhB,EAAI,EAAA,SAAA,CAAa,CAAA,SACvB,GFPG,ADAA,+GGYZ,MAAO,UAAA,EAAA,SAAuC,OCCD,MDErC,WAAE,CJDD,AICU,CAAyB,CAAA,OACxC,EDiC0B,EHlCtB,GKAC,cAAA,SDEA,uFAJG,MJUC,mBIJjB,CAAC,CD2CG,AC1CL,ECKE,IDHU,CD6CD,SC7CqC,EAAA,SAAS,CAGxD,YAAY,CAAA,UAAA,CAAW,CAAyB,CAAA,CAC9C,KAAK,CAAC,CDyCmC,2BCzCN,CACjC,CD0CqC,OC1CrC,eACc,CAAC,ECKM,qBDLiB,sFAL1B,iCAQjB,wBHpC2C,EAAA,SAAS,oBAGjC,CAAoB,CAAA,sCACE,OEiBnB,GACtB,GHlB4B,ECCR,CEiBd,AHjBN,ACAoB,EGOG,CJNO,CGiBC,CHjBC,CAD1B,AGkB2B,EAAA,EFlBF,CDCO,CGiBC,AFlBJ,EAAA,UEiBL,CAAA,IHhB6B,CAAA,AAD7B,CAAA,OAC6B,CCDI,CAAC,gHAE/D,CAAC,AGOA,CJNH,GKFG,CAAA,ELEI,CGkBA,AHlBA,CAAA,CAAA,CAAA,iBERM,UAAgC,EAAA,AFApB,EAAE,MGYM,AHZA,CEAqB,AECnB,CDWA,AHZoB,AEGrD,ADHkC,CCAC,AFAkB,EAChD,AGYA,EACL,AHbO,CGWgC,EAAsB,CAAA,GHXtD,CAAA,QAAA,CEEc,CAAA,MAAA,CAAO,CAAsC,CAAA,OAC1D,0BAA2B,CAC/B,OEOO,MFPO,CACZ,CAAA,CAAA,EA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","ignoreList":[0,1,6,7,8,9,10,11,12,13]}