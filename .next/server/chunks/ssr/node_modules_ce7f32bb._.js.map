{"version":3,"sources":["../../../../node_modules/abitype/src/human-readable/parseAbiItem.ts","../../../../node_modules/thirdweb/src/utils/abi/encodeAbiParameters.ts","../../../../node_modules/thirdweb/src/utils/encoding/helpers/byte-size.ts","../../../../node_modules/thirdweb/src/utils/abi/prepare-method.ts","../../../../node_modules/thirdweb/src/transaction/actions/estimate-gas-cost.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/zora-sepolia.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/base.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/optimism.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/base-sepolia.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/optimism-sepolia.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/zora.ts","../../../../node_modules/thirdweb/src/chains/constants.ts","../../../../node_modules/thirdweb/src/transaction/utils.ts","../../../../node_modules/thirdweb/src/rpc/actions/eth_call.ts","../../../../node_modules/thirdweb/src/transaction/read-contract.ts","../../../../node_modules/thirdweb/src/rpc/actions/eth_getStorageAt.ts","../../../../node_modules/thirdweb/src/utils/bytecode/resolveImplementation.ts","../../../../node_modules/thirdweb/src/utils/bytecode/extractMinimalProxyImplementationAddress.ts"],"sourcesContent":["import type { Abi } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiItemError } from './errors/abiItem.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signature, Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * type Result = ParseAbiItem<\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n> =\n  | (signature extends string\n      ? string extends signature\n        ? Abi[number]\n        : signature extends Signature<signature> // Validate signature\n          ? ParseSignature<signature>\n          : never\n      : never)\n  | (signature extends readonly string[]\n      ? string[] extends signature\n        ? Abi[number] // Return generic Abi item since type was no inferrable\n        : signature extends Signatures<signature> // Validate signature\n          ? ParseStructs<signature> extends infer structs\n            ? {\n                [key in keyof signature]: ParseSignature<\n                  signature[key] extends string ? signature[key] : never,\n                  structs\n                >\n              } extends infer mapped extends readonly unknown[]\n              ? // Filter out `never` since those are structs\n                Filter<mapped, never>[0] extends infer result\n                ? result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\n                  ? never\n                  : result\n                : never\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n>(\n  signature: Narrow<signature> &\n    (\n      | (signature extends string\n          ? string extends signature\n            ? unknown\n            : Signature<signature>\n          : never)\n      | (signature extends readonly string[]\n          ? signature extends readonly [] // empty array\n            ? Error<'At least one signature required.'>\n            : string[] extends signature\n              ? unknown\n              : Signatures<signature>\n          : never)\n    ),\n): ParseAbiItem<signature> {\n  let abiItem: ParseAbiItem<signature> | undefined\n  if (typeof signature === 'string')\n    abiItem = parseSignature(signature) as ParseAbiItem<signature>\n  else {\n    const structs = parseStructs(signature as readonly string[])\n    const length = signature.length as number\n    for (let i = 0; i < length; i++) {\n      const signature_ = (signature as readonly string[])[i]!\n      if (isStructSignature(signature_)) continue\n      abiItem = parseSignature(signature_, structs) as ParseAbiItem<signature>\n      break\n    }\n  }\n\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\n  return abiItem as ParseAbiItem<signature>\n}\n","import type {\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from \"abitype\";\nimport * as ox__Hex from \"ox/Hex\";\nimport { isAddress } from \"../address.js\";\nimport { byteSize } from \"../encoding/helpers/byte-size.js\";\nimport {\n  boolToHex,\n  type Hex,\n  numberToHex,\n  padHex,\n  stringToHex,\n} from \"../encoding/hex.js\";\n\n/**\n * Encodes the given ABI parameters and values into a hexadecimal string.\n * @template TParams - The type of the ABI parameters.\n * @param params - The ABI parameters.\n * @param values - The corresponding values for the ABI parameters.\n * @returns - The encoded ABI parameters as a hexadecimal string.\n * @throws {Error} - If the number of parameters and values do not match.\n * @example\n * ```ts\n * import { encodeAbiParameters } from \"thirdweb/utils\";\n *\n * const params = [\n *  { name: \"param1\", type: \"uint256\" },\n *  { name: \"param2\", type: \"string\" },\n * ];\n * const values = [123, \"hello\"];\n *\n * const data = encodeAbiParameters(params, values);\n * console.log(data);\n * ```\n * @utils\n */\nexport function encodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: TParams,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): Hex {\n  if (params.length !== values.length) {\n    throw new Error(\"The number of parameters and values must match.\");\n  }\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) {\n    return \"0x\";\n  }\n  return data;\n}\n\n//UTILS\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex };\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] };\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>;\n\nfunction prepareParams<const TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: TParams;\n  values: AbiParametersToPrimitiveTypes<TParams>;\n}) {\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < params.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    preparedParams.push(prepareParam({ param: params[i]!, value: values[i] }));\n  }\n  return preparedParams;\n}\n\n/**\n * @internal Export for unit test\n */\nexport function prepareParam<const TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam;\n  value: AbiParameterToPrimitiveType<TParam>;\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, { length, param: { ...param, type } });\n  }\n  if (param.type === \"tuple\") {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    });\n  }\n  if (param.type === \"address\") {\n    return encodeAddress(value as unknown as Hex);\n  }\n  if (param.type === \"bool\") {\n    return encodeBool(value as unknown as boolean);\n  }\n  if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\n    const signed = param.type.startsWith(\"int\");\n    return encodeNumber(value as unknown as number, { signed });\n  }\n  if (param.type.startsWith(\"bytes\")) {\n    return encodeBytes(value as unknown as Hex, { param });\n  }\n  if (param.type === \"string\") {\n    return encodeString(value as unknown as string);\n  }\n  throw new Error(`Unsupported parameter type: ${param.type}`);\n}\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticSize += 32;\n    } else {\n      staticSize += byteSize(encoded);\n    }\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = [];\n  const dynamicParams: Hex[] = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n      dynamicParams.push(encoded);\n      dynamicSize += byteSize(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return ox__Hex.concat(...[...staticParams, ...dynamicParams]);\n}\n\n/////////////////////////////////////////////////////////////////\n\n/**\n * @internal Export for unit test\n */\nexport function encodeAddress(value: Hex): PreparedParam {\n  // We allow empty strings for deployment transactions where there is no to address\n  if ((value as string) !== \"\" && value !== undefined && !isAddress(value)) {\n    throw new Error(`Invalid address: ${value}`);\n  }\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) };\n}\n\nfunction encodeArray<const TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null;\n    param: TParam;\n  },\n): PreparedParam {\n  const dynamic = length === null;\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Invalid array value.\");\n  }\n  if (!dynamic && value.length !== length) {\n    throw new Error(\"Invalid array length.\");\n  }\n\n  let dynamicChild = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] });\n    if (preparedParam.dynamic) {\n      dynamicChild = true;\n    }\n    preparedParams.push(preparedParam);\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length_ = numberToHex(preparedParams.length, { size: 32 });\n      return {\n        dynamic: true,\n        encoded:\n          preparedParams.length > 0\n            ? ox__Hex.concat(...[length_, data])\n            : length_,\n      };\n    }\n    if (dynamicChild) {\n      return { dynamic: true, encoded: data };\n    }\n  }\n  return {\n    dynamic: false,\n    encoded: ox__Hex.concat(...preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction encodeBytes<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split(\"bytes\");\n  const bytesSize = byteSize(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) {\n      value_ = padHex(value_, {\n        dir: \"right\",\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      });\n    }\n    return {\n      dynamic: true,\n      encoded: ox__Hex.concat(\n        ...[padHex(numberToHex(bytesSize, { size: 32 })), value_],\n      ),\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) {\n    throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);\n  }\n  return { dynamic: false, encoded: padHex(value, { dir: \"right\" }) };\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      signed,\n      size: 32,\n    }),\n  };\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(byteSize(hexValue) / 32);\n  const parts: Hex[] = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(ox__Hex.slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: \"right\",\n      }),\n    );\n  }\n  return {\n    dynamic: true,\n    encoded: ox__Hex.concat(\n      ...[padHex(numberToHex(byteSize(hexValue), { size: 32 })), ...parts],\n    ),\n  };\n}\n\nfunction encodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < param.components.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const param_ = param.components[i]!;\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      value: (value as any)[index!] as readonly unknown[],\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) {\n      dynamic = true;\n    }\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : ox__Hex.concat(...preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      [matches[2] ? Number(matches[2]) : null, matches[1]!]\n    : undefined;\n}\n","import { type Hex, isHex } from \"../hex.js\";\n\n/**\n * Calculates the byte size of a Hex string or Uint8Array.\n * If the value is a Hex string, it accounts for the leading \"0x\" prefix.\n * @param value The Hex string or Uint8Array.\n * @returns The byte size of the value.\n * @example\n * ```ts\n * import { byteSize } from \"thirdweb/utils\";\n * const size = byteSize(\"0x1a4\");\n * console.log(size); // 2\n * ```\n */\nexport function byteSize(value: Hex | Uint8Array) {\n  if (isHex(value, { strict: false })) {\n    return Math.ceil((value.length - 2) / 2);\n  }\n  return value.length;\n}\n","import { type AbiFunction, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { LruMap } from \"../caching/lru.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringify } from \"../json.js\";\n\ntype ParseMethod<method extends AbiFunction | `function ${string}`> =\n  // if the method IS an AbiFunction, return it\n  method extends AbiFunction\n    ? method\n    : method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : never;\n\nexport type PreparedMethod<TMethod extends AbiFunction | `function ${string}`> =\n  // [\"fn signature\", \"inputs\", \"outputs\"]\n  [Hex, ParseMethod<TMethod>[\"inputs\"], ParseMethod<TMethod>[\"outputs\"]];\n\nconst prepareMethodCache = new LruMap<PreparedMethod<AbiFunction>>(4096);\n\n/**\n * Prepares a method for usage by converting it into a prepared method object.\n * @param method The method to prepare.\n * @returns The prepared method object.\n * @example\n * ```ts\n * import { prepareMethod } from \"thirdweb/utils\";\n * const method = \"function transfer(address to, uint256 value)\";\n * const preparedMethod = prepareMethod(method);\n * ```\n * @contract\n */\nexport function prepareMethod<\n  const TMethod extends AbiFunction | `function ${string}`,\n>(method: TMethod): PreparedMethod<TMethod> {\n  const key = typeof method === \"string\" ? method : stringify(method);\n  if (prepareMethodCache.has(key)) {\n    return prepareMethodCache.get(key) as PreparedMethod<TMethod>;\n  }\n  type ParsedAbiFn = ParseMethod<TMethod>;\n\n  const abiFn =\n    typeof method === \"string\"\n      ? // @ts-expect-error - we're sure it's a string...\n        (parseAbiItem(method) as ParsedAbiFn)\n      : (method as ParsedAbiFn);\n\n  // encode the method signature\n  const sig = toFunctionSelector(abiFn);\n\n  const ret: PreparedMethod<TMethod> = [sig, abiFn.inputs, abiFn.outputs];\n  prepareMethodCache.set(key, ret);\n  return ret;\n}\n","import { isOpStackChain } from \"../../chains/constants.js\";\nimport { getDefaultGasOverrides } from \"../../gas/fee-data.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { toEther } from \"../../utils/units.js\";\nimport { type EstimateGasOptions, estimateGas } from \"./estimate-gas.js\";\n\nexport type EstimateGasCostResult = {\n  /**\n   * The estimated gas cost in ether.\n   */\n  ether: string;\n  /**\n   * The estimated gas cost in wei.\n   */\n  wei: bigint;\n};\n\n/**\n * Estimate the gas cost of a transaction in ether and wei.\n * @example\n * ```ts\n * import { estimateGasCost } from \"thirdweb\";\n *\n * const gasCost = await estimateGasCost({ transaction });\n * ```\n * @transaction\n */\nexport async function estimateGasCost(\n  options: EstimateGasOptions,\n): Promise<EstimateGasCostResult> {\n  const { transaction } = options;\n  const from = options.from ?? options.account?.address ?? undefined;\n  const gasLimit =\n    (await resolvePromisedValue(transaction.gas)) ||\n    (await estimateGas({ from, transaction }));\n  const fees = await getDefaultGasOverrides(\n    transaction.client,\n    transaction.chain,\n  );\n  const gasPrice = fees.maxFeePerGas || fees.gasPrice;\n  if (gasPrice === undefined) {\n    throw new Error(\n      `Unable to determine gas price for chain ${transaction.chain.id}`,\n    );\n  }\n  let l1Fee: bigint;\n  if (await isOpStackChain(transaction.chain)) {\n    const { estimateL1Fee } = await import(\"../../gas/estimate-l1-fee.js\");\n    l1Fee = await estimateL1Fee({\n      transaction,\n    });\n  } else {\n    l1Fee = 0n;\n  }\n  const wei = gasLimit * gasPrice + l1Fee;\n  return {\n    ether: toEther(wei),\n    wei,\n  };\n}\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const zoraSepolia = /*@__PURE__*/ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://sepolia.explorer.zora.energy/api\",\n      name: \"Zora Sepolia Explorer\",\n      url: \"https://sepolia.explorer.zora.energy/\",\n    },\n  ],\n  id: 999999999,\n  name: \"Zora Sepolia\",\n\n  nativeCurrency: {\n    decimals: 18,\n    name: \"Zora Sepolia\",\n    symbol: \"ETH\",\n  },\n  testnet: true,\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const base = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://api.basescan.org/api\",\n      name: \"Basescan\",\n      url: \"https://basescan.org\",\n    },\n  ],\n  id: 8453,\n  name: \"Base\",\n  nativeCurrency: { decimals: 18, name: \"Ether\", symbol: \"ETH\" },\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const optimism = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://api-optimistic.etherscan.io\",\n      name: \"Optimism Explorer\",\n      url: \"https://optimistic.etherscan.io\",\n    },\n  ],\n  id: 10,\n  name: \"OP Mainnet\",\n  nativeCurrency: { decimals: 18, name: \"Ether\", symbol: \"ETH\" },\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const baseSepolia = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://api-sepolia.basescan.org/api\",\n      name: \"Basescan\",\n      url: \"https://sepolia.basescan.org\",\n    },\n  ],\n  id: 84532,\n  name: \"Base Sepolia\",\n  nativeCurrency: { decimals: 18, name: \"Sepolia Ether\", symbol: \"ETH\" },\n  testnet: true,\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const optimismSepolia = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://optimism-sepolia.blockscout.com/api\",\n      name: \"Blockscout\",\n      url: \"https://optimism-sepolia.blockscout.com\",\n    },\n  ],\n  id: 11155420,\n  name: \"OP Sepolia\",\n  nativeCurrency: { decimals: 18, name: \"Sepolia Ether\", symbol: \"ETH\" },\n  testnet: true,\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const zora = /*@__PURE__*/ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://explorer.zora.energy/api\",\n      name: \"Explorer\",\n      url: \"https://explorer.zora.energy\",\n    },\n  ],\n  id: 7777777,\n  name: \"Zora\",\n  nativeCurrency: {\n    decimals: 18,\n    name: \"Ether\",\n    symbol: \"ETH\",\n  },\n});\n","import { base } from \"./chain-definitions/base.js\";\nimport { baseSepolia } from \"./chain-definitions/base-sepolia.js\";\nimport { optimism } from \"./chain-definitions/optimism.js\";\nimport { optimismSepolia } from \"./chain-definitions/optimism-sepolia.js\";\nimport { zora } from \"./chain-definitions/zora.js\";\nimport { zoraSepolia } from \"./chain-definitions/zora-sepolia.js\";\nimport type { Chain } from \"./types.js\";\n\nconst opChains = [\n  base.id,\n  baseSepolia.id,\n  optimism.id,\n  optimismSepolia.id,\n  zora.id,\n  zoraSepolia.id,\n  34443, // mode\n  919, // mode testnet\n  42220, // celo\n  44787, // celo testnet\n  204, // opBNB\n  5611, // opBNB testnet\n];\n\n/**\n * TODO this should be in the chain definition itself\n * @internal\n */\nexport async function isOpStackChain(chain: Chain) {\n  if (chain.id === 1337 || chain.id === 31337) {\n    return false;\n  }\n\n  if (opChains.includes(chain.id)) {\n    return true;\n  }\n  // fallback to checking the stack on rpc\n  try {\n    const { getChainMetadata } = await import(\"./utils.js\");\n    const chainMetadata = await getChainMetadata(chain);\n    return chainMetadata.stackType === \"optimism_bedrock\";\n  } catch {\n    // If the network check fails, assume it's not a OP chain\n    return false;\n  }\n}\n","import type { AbiFunction } from \"abitype\";\nimport { getGasPrice } from \"../gas/get-gas-price.js\";\nimport { estimateGasCost } from \"./actions/estimate-gas-cost.js\";\nimport type { PreparedTransaction } from \"./prepare-transaction.js\";\n\n/**\n * @internal\n */\nexport function isAbiFunction(item: unknown): item is AbiFunction {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"function\"\n  );\n}\n\nexport async function getTransactionGasCost(\n  tx: PreparedTransaction,\n  from?: string,\n) {\n  try {\n    const gasCost = await estimateGasCost({\n      from,\n      transaction: tx,\n    });\n\n    const bufferCost = gasCost.wei / 10n;\n\n    // Note: get tx.value AFTER estimateGasCost\n    // add 10% extra gas cost to the estimate to ensure user buys enough to cover the tx cost\n    return gasCost.wei + bufferCost;\n  } catch {\n    if (from) {\n      // try again without passing from\n      return await getTransactionGasCost(tx);\n    }\n    // fallback if both fail, use the tx value + 1M * gas price\n    const gasPrice = await getGasPrice({\n      chain: tx.chain,\n      client: tx.client,\n    });\n\n    return 1_000_000n * gasPrice;\n  }\n}\n","import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          code: override.code,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { decodeAbiParameters, type TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n    from?: string;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    from: options.from ? getAddress(options.from) : undefined,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n","import type { BlockTag, EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\nimport { getAddress } from \"../../utils/address.js\";\n\ntype GetStorageAtParams = {\n  address: string;\n  position: Hex;\n  blockTag?: BlockTag;\n};\n\n/**\n * Retrieves the value stored at a specific position in the storage of a contract.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the eth_getStorageAt method.\n * @returns A promise that resolves to the value stored at the specified position.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getStorageAt } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const storageValue = await eth_getStorageAt(rpcRequest, {\n * address: \"0x...\",\n *  position: 0n,\n * });\n * ```\n */\nexport async function eth_getStorageAt(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetStorageAtParams,\n): Promise<Hex> {\n  return await request({\n    method: \"eth_getStorageAt\",\n    params: [\n      getAddress(params.address),\n      params.position,\n      params.blockTag ?? \"latest\",\n    ],\n  });\n}\n","import { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport { getContract, type ThirdwebContract } from \"../../contract/contract.js\";\nimport { eth_getStorageAt } from \"../../rpc/actions/eth_getStorageAt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { isAddress } from \"../address.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { extractMinimalProxyImplementationAddress } from \"./extractMinimalProxyImplementationAddress.js\";\n\n// TODO: move to const exports\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\nconst ZERO_BYTES32 =\n  \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n/**\n * Resolves the implementation address and bytecode for a given proxy contract.\n * @param contract The contract to resolve the implementation for.\n * @returns A promise that resolves to an object containing the implementation address and bytecode.\n * @example\n * ```ts\n * import { resolveImplementation } from \"thirdweb/utils\";\n * const implementation = await resolveImplementation(contract);\n * ```\n * @contract\n */\nexport async function resolveImplementation(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<{ address: string; bytecode: Hex }> {\n  const [originalBytecode, beacon] = await Promise.all([\n    getBytecode(contract),\n    getBeaconFromStorageSlot(contract),\n  ]);\n  // check minimal proxy first synchronously\n  const minimalProxyImplementationAddress =\n    extractMinimalProxyImplementationAddress(originalBytecode);\n  if (minimalProxyImplementationAddress) {\n    return {\n      address: minimalProxyImplementationAddress,\n      bytecode: await getBytecode(\n        getContract({\n          ...contract,\n          address: minimalProxyImplementationAddress,\n        }),\n      ),\n    };\n  }\n\n  // check other proxy types\n  if (beacon && beacon !== AddressZero) {\n    // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation\n    // Hence we replace the proxy address with Beacon address, and continue further resolving below\n    contract = getContract({\n      ...contract,\n      address: beacon,\n    });\n  }\n\n  const implementations = await Promise.all([\n    getImplementationFromStorageSlot(contract),\n    getImplementationFromContractCall(contract),\n  ]);\n\n  for (const implementationAddress of implementations) {\n    if (\n      implementationAddress &&\n      isAddress(implementationAddress) &&\n      implementationAddress !== AddressZero\n    ) {\n      const implementationBytecode = await getBytecode({\n        ...contract,\n        address: implementationAddress,\n      });\n      // return the original contract bytecode if the implementation bytecode is empty\n      if (implementationBytecode === \"0x\") {\n        return {\n          address: contract.address,\n          bytecode: originalBytecode,\n        };\n      }\n\n      return {\n        address: implementationAddress,\n        bytecode: implementationBytecode,\n      };\n    }\n  }\n\n  return { address: contract.address, bytecode: originalBytecode };\n}\n\nasync function getBeaconFromStorageSlot(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  /**\n   * The storage slot of the Beacon as defined in EIP-1967\n   * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address\n   *\n   * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))\n   */\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  try {\n    const proxyStorage = await eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position:\n        \"0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50\",\n    });\n    if (proxyStorage.length >= 40) {\n      return `0x${proxyStorage.slice(-40)}`;\n    }\n    return undefined;\n  } catch {\n    return undefined;\n  }\n}\n\nasync function getImplementationFromStorageSlot(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  try {\n    const proxyStoragePromises = [\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n      }),\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          // keccak256(\"matic.network.proxy.implementation\") - used in polygon USDT proxy: https://polygonscan.com/address/0xc2132d05d31c914a87c6611c10748aeb04b58e8f#code\n          \"0xbaab7dbf64751104133af04abc7d9979f0fda3b059a322a8333f533d3f32bf7f\",\n      }),\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          // keccak256(\"org.zeppelinos.proxy.implementation\") - e.g. base USDC proxy: https://basescan.org/address/0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913#code\n          \"0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3\",\n      }),\n    ];\n\n    const proxyStorages = await Promise.all(proxyStoragePromises);\n    const proxyStorage = proxyStorages.find(\n      (storage) => storage !== ZERO_BYTES32,\n    );\n\n    return proxyStorage ? `0x${proxyStorage.slice(-40)}` : AddressZero;\n  } catch {\n    return undefined;\n  }\n}\n\nconst UPGRADEABLE_PROXY_ABI = {\n  inputs: [],\n  name: \"implementation\",\n  outputs: [\n    {\n      internalType: \"address\",\n      name: \"\",\n      type: \"address\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nasync function getImplementationFromContractCall(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  try {\n    return await readContract({ contract, method: UPGRADEABLE_PROXY_ABI });\n  } catch {\n    return undefined;\n  }\n}\n","/**\n * Extracts the implementation address from a given bytecode string if it matches any of the known minimal proxy patterns.\n * @param bytecode The bytecode string to extract the implementation address from.\n * @returns The implementation address as a string if a match is found, otherwise undefined.\n * @example\n * ```ts\n * import { extractMinimalProxyImplementationAddress } from \"thirdweb/utils\";\n * const bytecode = \"0x363d3d373d3d3d363d73...\";\n * const implementationAddress = extractMinimalProxyImplementationAddress(bytecode);\n * ```\n * @utils\n */\nexport function extractMinimalProxyImplementationAddress(\n  bytecode: string,\n): string | undefined {\n  if (!bytecode.startsWith(\"0x\")) {\n    bytecode = `0x${bytecode}`;\n  }\n  // EIP-1167 clone minimal proxy - https://eips.ethereum.org/EIPS/eip-1167\n  if (bytecode.startsWith(\"0x363d3d373d3d3d363d73\")) {\n    const implementationAddress = bytecode.slice(22, 62);\n    return `0x${implementationAddress}`;\n  }\n\n  // Minimal Proxy with receive() from 0xSplits - https://github.com/0xSplits/splits-contracts/blob/c7b741926ec9746182d0d1e2c4c2046102e5d337/contracts/libraries/Clones.sol\n  if (bytecode.startsWith(\"0x36603057343d5230\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(122, 122 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // 0age's minimal proxy - https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48\n  if (bytecode.startsWith(\"0x3d3d3d3d363d3d37363d73\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(24, 24 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // vyper's minimal proxy (uniswap v1) - https://etherscan.io/address/0x09cabec1ead1c0ba254b09efb3ee13841712be14#code\n  if (bytecode.startsWith(\"0x366000600037611000600036600073\")) {\n    const implementationAddress = bytecode.slice(32, 32 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  if (bytecode.startsWith(\"0x36600080376020600036600073\")) {\n    const implementationAddress = bytecode.slice(28, 28 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // EIP-7511 minimal proxy with PUSH0 opcode - https://eips.ethereum.org/EIPS/eip-7511\n  if (bytecode.startsWith(\"0x365f5f375f5f365f73\")) {\n    const implementationAddress = bytecode.slice(20, 60);\n    return `0x${implementationAddress}`;\n  }\n\n  // EIP-7702 - https://eips.ethereum.org/EIPS/eip-7702#abstract\n  if (bytecode.length === 48 && bytecode.startsWith(\"0xef0100\")) {\n    const implementationAddress = bytecode.slice(8, 48);\n    return `0x${implementationAddress}`;\n  }\n\n  return undefined;\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17]}