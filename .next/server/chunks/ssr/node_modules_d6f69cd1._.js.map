{"version":3,"sources":["../../../../node_modules/thirdweb/src/transaction/prepare-transaction.ts","../../../../node_modules/thirdweb/src/transaction/prepare-contract-call.ts","../../../../node_modules/viem/utils/abi/parseEventLogs.ts","../../../../node_modules/viem/utils/abi/decodeEventLog.ts","../../../../node_modules/viem/errors/log.ts","../../../../node_modules/viem/utils/abi/encodeEventTopics.ts","../../../../node_modules/thirdweb/src/utils/promise/once.ts","../../../../node_modules/thirdweb/src/wallets/smart/types.ts","../../../../node_modules/thirdweb/src/event/actions/parse-logs.ts","../../../../node_modules/thirdweb/src/wallets/smart/lib/utils.ts","../../../../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.ts","../../../../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.ts","../../../../node_modules/thirdweb/src/event/prepare-event.ts","../../../../node_modules/thirdweb/src/wallets/smart/lib/bundler.ts","../../../../node_modules/thirdweb/src/event/utils.ts"],"sourcesContent":["import type { Abi, AbiFunction, Address } from \"abitype\";\nimport type { AccessList, Hex } from \"viem\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport type { PreparedMethod } from \"../utils/abi/prepare-method.js\";\nimport type { PromisedObject } from \"../utils/promise/resolve-promised-value.js\";\nimport type { SignedAuthorization } from \"./actions/eip7702/authorization.js\";\n\nexport type StaticPrepareTransactionOptions = {\n  accessList?: AccessList | undefined;\n  to?: Address | undefined;\n  data?: Hex | undefined;\n  value?: bigint | undefined;\n  gas?: bigint | undefined;\n  gasPrice?: bigint | undefined;\n  maxFeePerGas?: bigint | undefined;\n  maxPriorityFeePerGas?: bigint | undefined;\n  maxFeePerBlobGas?: bigint | undefined;\n  type?: undefined | TransactionType;\n  nonce?: number | undefined;\n  extraGas?: bigint | undefined;\n  // eip7702\n  authorizationList?: SignedAuthorization[] | undefined;\n  // zksync specific\n  eip712?: EIP712TransactionOptions | undefined;\n  // tw specific\n  chain: Chain;\n  client: ThirdwebClient;\n  // extras\n  extraCallData?: Hex;\n  erc20Value?: {\n    amountWei: bigint;\n    tokenAddress: Address;\n  };\n};\n\ntype TransactionType = \"legacy\" | \"eip1559\" | \"eip2930\" | \"eip4844\" | \"eip7702\";\n\nexport const TransactionTypeMap: Record<TransactionType, number> = {\n  eip1559: 1,\n  eip2930: 2,\n  eip4844: 3,\n  eip7702: 4,\n  legacy: 0,\n};\n\nexport type EIP712TransactionOptions = {\n  // constant or user input\n  gasPerPubdata?: bigint | undefined;\n  // optional signature, generated\n  customSignature?: Hex | undefined;\n  // optional, used to deploy contracts with the transaction\n  factoryDeps?: Hex[] | undefined;\n  // optional, paymaster contract address to invoke\n  paymaster?: Address | undefined;\n  // optional, paymaster contract input\n  paymasterInput?: Hex | undefined;\n};\n\nexport type EIP712SerializedTransaction = {\n  txType: bigint;\n  from: bigint;\n  to: bigint;\n  gasLimit: bigint;\n  gasPerPubdataByteLimit: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  nonce: bigint;\n  value: bigint;\n  data: Hex;\n  factoryDeps: Hex[];\n  paymaster: bigint;\n  paymasterInput: Hex;\n};\n\nexport type PrepareTransactionOptions = {\n  chain: Chain;\n  client: ThirdwebClient;\n} & PromisedObject<Omit<StaticPrepareTransactionOptions, \"chain\" | \"client\">>;\n\ntype Additional<\n  abi extends Abi = [],\n  abiFn extends AbiFunction = AbiFunction,\n> = {\n  preparedMethod: () => Promise<PreparedMethod<abiFn>>;\n  contract: ThirdwebContract<abi>;\n};\n\nexport type PreparedTransaction<\n  abi extends Abi = [],\n  abiFn extends AbiFunction = AbiFunction,\n  options extends PrepareTransactionOptions = PrepareTransactionOptions,\n> = Readonly<options> & {\n  __preparedMethod?: () => Promise<PreparedMethod<abiFn>>;\n  __contract?: ThirdwebContract<abi>;\n};\n\n/**\n * Prepares a transaction with the given options.\n * @param options - The options for preparing the transaction.\n * @param info - Additional information about the ABI function.\n * @returns The prepared transaction.\n * @transaction\n * @example\n * ```ts\n * import { prepareTransaction, toWei } from \"thirdweb\";\n * import { ethereum } from \"thirdweb/chains\";\n * const transaction = prepareTransaction({\n *  to: \"0x1234567890123456789012345678901234567890\",\n *  chain: ethereum,\n *  client: thirdwebClient,\n *  value: toWei(\"1.0\"),\n *  gasPrice: 30n\n * });\n * ```\n */\nexport function prepareTransaction<\n  const abi extends Abi = [],\n  const abiFn extends AbiFunction = AbiFunction,\n>(options: PrepareTransactionOptions, info?: Additional<abi, abiFn>) {\n  if (info) {\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    (options as any).__preparedMethod = info.preparedMethod;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    (options as any).__contract = info.contract;\n  }\n  return options as PreparedTransaction<abi, abiFn>;\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport type { TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport {\n  type PrepareTransactionOptions,\n  prepareTransaction,\n} from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type PrepareContractCallOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n    | \"authorizationList\"\n  > & {\n    contract: ThirdwebContract<TAbi>;\n    method: TMethod | TPreparedMethod;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * Prepares a contract call by resolving the ABI function, parameters and encoded data. Optionally specify other properties such as value or gas price.\n * @param options - The options for preparing the contract call.\n * @returns A promise that resolves to the prepared transaction.\n * @transaction\n * @example\n *\n * ### Usage with a human-readable method signature:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with explicit gas price and/or value:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n *  maxFeePerGas: 30n,\n *  maxPriorityFeePerGas: 1n,\n *  value: toWei(\"0.01\"),\n * });\n * ```\n *\n * ### Usage with ERC20 value:\n *\n * For transactions that transfer ERC20 tokens, you can specify the value as the amount of tokens to transfer.\n *\n * You can use this in conjuction with the [`getApprovalForTransaction`](https://portal.thirdweb.com/references/typescript/v5/getApprovalForTransaction) function to easily create approval transactions for ERC20 tokens.\n *\n * This value will also be read by the react hooks and UI components to present to total cost to the user.\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function payWithCoin()\",\n *  params: [],\n *  erc20Value: {\n *    tokenAddress: \"0x...\", // the address of the ERC20 token\n *    amountWei: toWei(\"0.1\"), // the amount of tokens to transfer in wei\n *  },\n * });\n * ```\n *\n * ### Usage with a JSON ABI function object:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: {\n *    name: \"transfer\",\n *    type: \"function\",\n *    inputs: [\n *      { name: \"to\", type: \"address\" },\n *      { name: \"value\", type: \"uint256\" },\n *    ],\n *    outputs: [],\n *    stateMutability: \"payable\"\n *   },\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with the ABI defined on the contract:\n *\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *  ..., // chain, address, client\n *  abi: [...] // ABI with a \"transfer\" method\n * });\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"transfer\", // <- this gets inferred from the contract\n *  params: [to, value],\n * });\n * ```\n *\n * ### Passing extra call data to the transaction\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *   ..., // chain, address, client\n * });\n *\n * const transaction = prepareContractCall({\n *   contract,\n *   method: \"function transfer(address to, uint256 value)\",\n *   params: [...],\n *   // The extra call data MUST be encoded to hex before passing\n *   extraCallData: \"0x.......\"\n * });\n * ```\n */\nexport function prepareContractCall<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(options: PrepareContractCallOptions<TAbi, TMethod, TPreparedMethod>) {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params, ...rest } = options;\n\n  const preparedMethodPromise = () =>\n    (async () => {\n      if (Array.isArray(method)) {\n        return method as PreparedMethod_;\n      }\n      if (isAbiFunction(method)) {\n        return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n      }\n\n      if (typeof method === \"function\") {\n        return prepareMethod(\n          // @ts-expect-error - method *is* function in this case\n          (await method(contract)) as ParsedMethod_,\n        ) as PreparedMethod_;\n      }\n      // if the method starts with the string `function ` we always will want to try to parse it\n      if (typeof method === \"string\" && method.startsWith(\"function \")) {\n        // @ts-expect-error - method *is* string in this case\n        const abiItem = parseAbiItem(method);\n        if (abiItem.type === \"function\") {\n          return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n        }\n        throw new Error(`\"method\" passed is not of type \"function\"`);\n      }\n      // check if we have a \"abi\" on the contract\n      if (contract.abi && contract.abi?.length > 0) {\n        // extract the abiFunction from it\n        const abiFunction = contract.abi?.find(\n          (item) => item.type === \"function\" && item.name === method,\n        );\n        // if we were able to find it -> return it\n        if (abiFunction) {\n          return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n        }\n      }\n      throw new Error(`Could not resolve method \"${method}\".`);\n    })();\n\n  return prepareTransaction(\n    {\n      ...rest,\n      chain: contract.chain,\n      client: contract.client,\n      data: async () => {\n        let preparedM: PreparedMethod_;\n        if (Array.isArray(method)) {\n          preparedM = method as PreparedMethod_;\n        } else {\n          preparedM = await preparedMethodPromise();\n        }\n\n        if (preparedM[1].length === 0) {\n          // just return the fn sig directly -> no params\n          return preparedM[0];\n        }\n\n        // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n        // we can do this because we know the specific formats of the values\n        return (preparedM[0] +\n          encodeAbiParameters(\n            preparedM[1],\n            // @ts-expect-error - TODO: fix this type issue\n            await resolvePromisedValue(params ?? []),\n          ).slice(2)) as `${(typeof preparedM)[0]}${string}`;\n      },\n      // these always inferred from the contract\n      to: contract.address,\n    },\n    {\n      contract: contract,\n      preparedMethod: preparedMethodPromise,\n    },\n  );\n}\n","// TODO(v3): checksum address.\n\nimport type { Abi, AbiEvent, AbiEventParameter, Address } from 'abitype'\nimport {\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractEventName, GetEventArgs } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { isAddressEqual } from '../address/isAddressEqual.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  allArgs = GetEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    {\n      EnableUnion: true\n      IndexedOnly: false\n      Required: false\n    }\n  >,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Arguments for the event. */\n  args?: allArgs | undefined\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>(\n  parameters: ParseEventLogsParameters<abi, eventName, strict>,\n): ParseEventLogsReturnType<abi, eventName, strict> {\n  const { abi, args, logs, strict = true } = parameters\n\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined\n    if (Array.isArray(parameters.eventName)) return parameters.eventName\n    return [parameters.eventName as string]\n  })()\n\n  return logs\n    .map((log) => {\n      try {\n        const abiItem = (abi as Abi).find(\n          (abiItem) =>\n            abiItem.type === 'event' &&\n            log.topics[0] === toEventSelector(abiItem),\n        ) as AbiEvent\n        if (!abiItem) return null\n\n        const event = decodeEventLog({\n          ...log,\n          abi: [abiItem],\n          strict,\n        })\n\n        // Check that the decoded event name matches the provided event name.\n        if (eventName && !eventName.includes(event.eventName)) return null\n\n        // Check that the decoded event args match the provided args.\n        if (\n          !includesArgs({\n            args: event.args,\n            inputs: abiItem.inputs,\n            matchArgs: args,\n          })\n        )\n          return null\n\n        return { ...event, ...log }\n      } catch (err) {\n        let eventName: string | undefined\n        let isUnnamed: boolean | undefined\n\n        if (err instanceof AbiEventSignatureNotFoundError) return null\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return null\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return { ...log, args: isUnnamed ? [] : {}, eventName }\n      }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n\nfunction includesArgs(parameters: {\n  args: unknown\n  inputs: AbiEvent['inputs']\n  matchArgs: unknown\n}) {\n  const { args, inputs, matchArgs } = parameters\n\n  if (!matchArgs) return true\n  if (!args) return false\n\n  function isEqual(input: AbiEventParameter, value: unknown, arg: unknown) {\n    try {\n      if (input.type === 'address')\n        return isAddressEqual(value as Address, arg as Address)\n      if (input.type === 'string' || input.type === 'bytes')\n        return keccak256(toBytes(value as string)) === arg\n      return value === arg\n    } catch {\n      return false\n    }\n  }\n\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (value === null || value === undefined) return true\n      const input = inputs[index]\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) => isEqual(input, value, args[index]))\n    })\n  }\n\n  if (\n    typeof args === 'object' &&\n    !Array.isArray(args) &&\n    typeof matchArgs === 'object' &&\n    !Array.isArray(matchArgs)\n  )\n    return Object.entries(matchArgs).every(([key, value]) => {\n      if (value === null || value === undefined) return true\n      const input = inputs.find((input) => input.name === key)\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) =>\n        isEqual(input, value, (args as Record<string, unknown>)[key]),\n      )\n    })\n\n  return false\n}\n","import type { Abi, AbiParameter } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n} from '../../errors/abi.js'\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgsFromTopics,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  IsNarrowable,\n  Prettify,\n  UnionEvaluate,\n} from '../../types/utils.js'\nimport { size } from '../data/size.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n> = {\n  abi: abi\n  data?: data | undefined\n  eventName?: eventName | ContractEventName<abi> | undefined\n  strict?: strict | boolean | undefined\n  topics: [signature: Hex, ...args: topics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n  ///\n  allEventNames extends\n    ContractEventName<abi> = eventName extends ContractEventName<abi>\n    ? eventName\n    : ContractEventName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? {\n      [name in allEventNames]: Prettify<\n        {\n          eventName: name\n        } & UnionEvaluate<\n          ContractEventArgsFromTopics<abi, name, strict> extends infer allArgs\n            ? topics extends readonly []\n              ? data extends undefined\n                ? { args?: undefined }\n                : { args?: allArgs | undefined }\n              : { args: allArgs }\n            : never\n        >\n      >\n    }[allEventNames]\n  : {\n      eventName: eventName\n      args: readonly unknown[] | undefined\n    }\n\nexport type DecodeEventLogErrorType =\n  | AbiDecodingDataSizeTooSmallErrorType\n  | AbiEventSignatureEmptyTopicsErrorType\n  | AbiEventSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | DecodeLogTopicsMismatchErrorType\n  | DecodeLogDataMismatchErrorType\n  | FormatAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n>(\n  parameters: DecodeEventLogParameters<abi, eventName, topics, data, strict>,\n): DecodeEventLogReturnType<abi, eventName, topics, data, strict> {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics,\n  } = parameters as DecodeEventLogParameters\n\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({ docsPath })\n\n  const abiItem = abi.find(\n    (x) =>\n      x.type === 'event' &&\n      signature === toEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, { docsPath })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  const args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs\n    .map((x, i) => [x, i] as const)\n    .filter(([x]) => 'indexed' in x && x.indexed)\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const [param, argIndex] = indexedInputs[i]\n    const topic = argTopics[i]\n    if (!topic)\n      throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param as AbiParameter & { indexed: boolean },\n      })\n    args[isUnnamed ? argIndex : param.name || argIndex] = decodeTopic({\n      param,\n      value: topic,\n    })\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed)\n            for (let i = 0; i < inputs.length; i++)\n              args[i] = args[i] ?? decodedData.shift()\n          else\n            for (let i = 0; i < nonIndexedInputs.length; i++)\n              args[nonIndexedInputs[i].name!] = decodedData[i]\n        }\n      } catch (err) {\n        if (strict) {\n          if (\n            err instanceof AbiDecodingDataSizeTooSmallError ||\n            err instanceof PositionOutOfBoundsError\n          )\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: data,\n              params: nonIndexedInputs,\n              size: size(data),\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<abi, eventName, topics, data, strict>\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n","import { BaseError } from './base.js'\n\nexport type FilterTypeNotSupportedErrorType = FilterTypeNotSupportedError & {\n  name: 'FilterTypeNotSupportedError'\n}\nexport class FilterTypeNotSupportedError extends BaseError {\n  constructor(type: string) {\n    super(`Filter type \"${type}\" is not supported.`, {\n      name: 'FilterTypeNotSupportedError',\n    })\n  }\n}\n","import type {\n  Abi,\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  ExtractAbiEvents,\n} from 'abitype'\n\nimport {\n  AbiEventNotFoundError,\n  type AbiEventNotFoundErrorType,\n} from '../../errors/abi.js'\nimport {\n  FilterTypeNotSupportedError,\n  type FilterTypeNotSupportedErrorType,\n} from '../../errors/log.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeEventTopics'\n\nexport type EncodeEventTopicsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  ///\n  hasEvents = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiEvents<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>\n  >,\n  allErrorNames = ContractEventName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { eventName?: eventName | allErrorNames | undefined }\n      : { eventName: eventName | allErrorNames }\n    : { eventName?: eventName | allErrorNames | undefined }\n> &\n  (hasEvents extends true ? unknown : never)\n\nexport type EncodeEventTopicsReturnType = [Hex, ...(Hex | Hex[] | null)[]]\n\nexport type EncodeEventTopicsErrorType =\n  | AbiEventNotFoundErrorType\n  | EncodeArgErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nexport function encodeEventTopics<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n>(\n  parameters: EncodeEventTopicsParameters<abi, eventName>,\n): EncodeEventTopicsReturnType {\n  const { abi, eventName, args } = parameters as EncodeEventTopicsParameters\n\n  let abiItem = abi[0]\n  if (eventName) {\n    const item = getAbiItem({ abi, name: eventName })\n    if (!item) throw new AbiEventNotFoundError(eventName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'event')\n    throw new AbiEventNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toEventSelector(definition as EventDefinition)\n\n  let topics: (Hex | Hex[] | null)[] = []\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n        ? (indexedInputs?.map((x: any) => (args as any)[x.name]) ?? [])\n        : []\n\n    if (args_.length > 0) {\n      topics =\n        indexedInputs?.map((param, i) => {\n          if (Array.isArray(args_[i]))\n            return args_[i].map((_: any, j: number) =>\n              encodeArg({ param, value: args_[i][j] }),\n            )\n          return typeof args_[i] !== 'undefined' && args_[i] !== null\n            ? encodeArg({ param, value: args_[i] })\n            : null\n        }) ?? []\n    }\n  }\n  return [signature, ...topics]\n}\n\nexport type EncodeArgErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | EncodeAbiParametersErrorType\n  | FilterTypeNotSupportedErrorType\n  | ErrorType\n\nfunction encodeArg({\n  param,\n  value,\n}: {\n  param: AbiParameter\n  value: AbiParameterToPrimitiveType<AbiParameter>\n}) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n","type OnceFn<T> = () => Promise<T>;\n\nexport function once<const T>(fn: OnceFn<T>): OnceFn<T> {\n  let result: Promise<T>;\n  return () => {\n    if (!result) {\n      result = fn();\n    }\n    return result;\n  };\n}\n","import type * as ox__Address from \"ox/Address\";\nimport type * as ox__TypedData from \"ox/TypedData\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport type { AccountPermissions } from \"../../extensions/erc4337/account/types.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../transaction/types.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { SignableMessage } from \"../../utils/types.js\";\nimport type { Account, SendTransactionOption } from \"../interfaces/wallet.js\";\n\nexport type TokenPaymasterConfig = {\n  chainId: number;\n  paymasterAddress: string;\n  tokenAddress: string;\n  balanceStorageSlot: bigint;\n};\n\nexport type SmartWalletOptions = Prettify<\n  {\n    chain: Chain; // TODO consider making default chain optional\n    factoryAddress?: string;\n    sessionKey?: {\n      address: string;\n      permissions: AccountPermissions;\n    };\n    overrides?: {\n      bundlerUrl?: string;\n      accountAddress?: string;\n      accountSalt?: string;\n      entrypointAddress?: string;\n      tokenPaymaster?: TokenPaymasterConfig;\n      paymaster?: (\n        userOp: UserOperationV06 | UserOperationV07,\n      ) => Promise<PaymasterResult>;\n      predictAddress?: (\n        factoryContract: ThirdwebContract,\n        admin: string,\n      ) => Promise<string>;\n      createAccount?: (\n        factoryContract: ThirdwebContract,\n        admin: string,\n      ) => PreparedTransaction;\n      execute?: (\n        accountContract: ThirdwebContract,\n        transaction: SendTransactionOption,\n      ) => PreparedTransaction;\n      executeBatch?: (\n        accountContract: ThirdwebContract,\n        transactions: SendTransactionOption[],\n      ) => PreparedTransaction;\n      getAccountNonce?: (accountContract: ThirdwebContract) => Promise<bigint>;\n      signMessage?: (options: {\n        adminAccount: Account;\n        accountContract: ThirdwebContract;\n        factoryContract: ThirdwebContract;\n        message: SignableMessage;\n      }) => Promise<Hex>;\n      signTypedData?: <\n        const typedData extends\n          | ox__TypedData.TypedData\n          | Record<string, unknown>,\n        primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n      >(options: {\n        adminAccount: Account;\n        accountContract: ThirdwebContract;\n        factoryContract: ThirdwebContract;\n        typedData: ox__TypedData.Definition<typedData, primaryType>;\n      }) => Promise<Hex>;\n    };\n  } & (\n    | {\n        /**\n         * @deprecated use 'sponsorGas' instead\n         */\n        gasless: boolean;\n      }\n    | {\n        sponsorGas: boolean;\n      }\n  )\n>;\n\n// internal type\nexport type SmartAccountOptions = Prettify<\n  Omit<SmartWalletOptions, \"chain\" | \"gasless\" | \"sponsorGas\"> & {\n    chain: Chain;\n    sponsorGas: boolean;\n    personalAccount: Account;\n    factoryContract: ThirdwebContract;\n    accountContract: ThirdwebContract;\n    client: ThirdwebClient;\n  }\n>;\n\nexport type BundlerOptions = {\n  bundlerUrl?: string;\n  entrypointAddress?: string;\n  chain: Chain;\n  client: ThirdwebClient;\n};\n\nexport type SmartWalletConnectionOptions = {\n  personalAccount: Account;\n  client: ThirdwebClient;\n  chain?: Chain;\n};\n\nexport type UserOperationV06 = {\n  sender: ox__Address.Address;\n  nonce: bigint;\n  initCode: Hex;\n  callData: Hex;\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  paymasterAndData: Hex;\n  signature: Hex;\n};\n\nexport type UserOperationV07 = {\n  sender: string; // address\n  nonce: bigint; // uint256\n  factory: string | undefined; // address\n  factoryData: Hex; // bytes\n  callData: Hex; // bytes\n  callGasLimit: bigint; // uint256\n  verificationGasLimit: bigint; // uint256\n  preVerificationGas: bigint; // uint256\n  maxFeePerGas: bigint; // uint256\n  maxPriorityFeePerGas: bigint; // uint256\n  paymaster: string | undefined; // address\n  paymasterData: Hex; // bytes\n  paymasterVerificationGasLimit: bigint; // uint256\n  paymasterPostOpGasLimit: bigint; // uint256\n  signature: Hex; // bytes\n};\n\nexport type PackedUserOperation = {\n  sender: string; // address\n  nonce: bigint; // uint256\n  initCode: Hex; // bytes\n  callData: Hex; // bytes\n  accountGasLimits: Hex; // bytes32\n  preVerificationGas: bigint; // uint256\n  gasFees: Hex; // bytes32\n  paymasterAndData: Hex; // bytes\n  signature: Hex; // bytes\n};\n\nexport type UserOperationV06Hexed = {\n  sender: ox__Address.Address;\n  nonce: Hex;\n  initCode: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n  paymasterAndData: Hex;\n  signature: Hex;\n};\n\nexport type UserOperationV07Hexed = {\n  sender: Hex;\n  nonce: Hex;\n  factory: Hex;\n  factoryData: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n  paymaster: Hex;\n  paymasterVerificationGasLimit: Hex;\n  paymasterPostOpGasLimit: Hex;\n  paymasterData: Hex;\n  signature: Hex;\n};\n\nexport type PaymasterResult = {\n  preVerificationGas?: bigint;\n  verificationGasLimit?: bigint;\n  callGasLimit?: bigint;\n} & (\n  | {\n      // v0.6 types\n      paymasterAndData: string;\n    }\n  | {\n      // v0.7 types\n      paymaster: string;\n      paymasterData: string;\n      paymasterVerificationGasLimit?: bigint;\n      paymasterPostOpGasLimit?: bigint;\n    }\n);\n\nexport type EstimationResult = {\n  preVerificationGas: bigint;\n  verificationGas?: bigint;\n  verificationGasLimit: bigint;\n  callGasLimit: bigint;\n  // v0.7 types\n  paymasterVerificationGasLimit?: bigint;\n  paymasterPostOpGasLimit?: bigint;\n};\n\nexport type GasPriceResult = {\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n};\n\nexport type PmTransactionData = {\n  paymaster: ox__Address.Address;\n  paymasterInput: Hex;\n};\n\nexport type UserOperationReceipt = {\n  receipt: TransactionReceipt;\n  logs: TransactionReceipt[\"logs\"];\n  userOpHash: Hex;\n  entryPoint: ox__Address.Address;\n  sender: ox__Address.Address;\n  nonce: bigint;\n  paymaster: ox__Address.Address;\n  actualGasUsed: bigint;\n  actualGasCost: bigint;\n  success: boolean;\n};\n\nexport function formatUserOperationReceipt(\n  userOpReceiptRaw: UserOperationReceipt,\n) {\n  const { receipt: transactionReceipt } = userOpReceiptRaw;\n\n  const receipt = {\n    ...transactionReceipt,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs,\n    status: transactionReceipt.status,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionHash: transactionReceipt.transactionHash,\n    transactionIndex: transactionReceipt.transactionIndex,\n    type: transactionReceipt.type,\n  } as TransactionReceipt;\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);\n\n  const userOpReceipt = {\n    ...userOpReceiptRaw,\n    actualGasCost: BigInt(userOpReceiptRaw.actualGasCost),\n    actualGasUsed: BigInt(userOpReceiptRaw.actualGasUsed),\n    nonce: BigInt(userOpReceiptRaw.nonce),\n    receipt,\n    userOpHash: userOpReceiptRaw.userOpHash,\n  } as UserOperationReceipt;\n  return userOpReceipt;\n}\n","import type { AbiEvent } from \"abitype\";\nimport {\n  type Log,\n  type RpcLog,\n  parseEventLogs as viem_parseEventLogs,\n} from \"viem\";\nimport type { PreparedEvent } from \"../prepare-event.js\";\n\nexport type ParseEventLogsOptions<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  logs: (Log | RpcLog)[];\n  events: abiEvents;\n  strict?: TStrict;\n};\n\nexport type ParseEventLogsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n  abiEvent extends AbiEvent = abiEvents[number][\"abiEvent\"],\n> = Array<Log<bigint, number, false, undefined, TStrict, abiEvent[]>>;\n\n/**\n * Parses logs and returns the corresponding events.\n * @param options - The options for parsing logs.\n * @returns The parsed events.\n * @example\n * ```ts\n * import { parseEventLogs } from \"thirdweb\";\n * const events = parseEventLogs({\n *  logs,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport function parseEventLogs<\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n  const TStrict extends boolean = true,\n>(\n  options: ParseEventLogsOptions<abiEvents, TStrict>,\n): ParseEventLogsResult<abiEvents, TStrict> {\n  const { logs, events, strict } = options;\n  return viem_parseEventLogs({\n    abi: events.map((e) => e.abiEvent),\n    logs,\n    strict,\n  }) as unknown as ParseEventLogsResult<abiEvents, TStrict>;\n}\n","import { isHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport type {\n  UserOperationV06,\n  UserOperationV06Hexed,\n  UserOperationV07,\n  UserOperationV07Hexed,\n} from \"../types.js\";\n\nexport const generateRandomUint192 = (): bigint => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return (\n    (rand1 << BigInt(160)) |\n    (rand2 << BigInt(128)) |\n    (rand3 << BigInt(96)) |\n    (rand4 << BigInt(64)) |\n    (rand5 << BigInt(32)) |\n    rand6\n  );\n};\n\n/**\n * @internal\n */\nexport function hexlifyUserOp(\n  userOp: UserOperationV06 | UserOperationV07,\n): UserOperationV06Hexed | UserOperationV07Hexed {\n  return Object.fromEntries(\n    Object.entries(userOp).map(([key, val]) => [\n      key,\n      // turn any value that's not hex into hex\n      val === undefined || val === null || isHex(val) ? val : toHex(val),\n    ]),\n  ) as UserOperationV06Hexed | UserOperationV07Hexed;\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Represents the filters for the \"UserOperationRevertReason\" event.\n */\nexport type UserOperationRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the UserOperationRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { userOperationRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  userOperationRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function userOperationRevertReasonEvent(\n  filters: UserOperationRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    filters,\n    signature:\n      \"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Represents the filters for the \"PostOpRevertReason\" event.\n */\nexport type PostOpRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the PostOpRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { postOpRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  postOpRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function postOpRevertReasonEvent(\n  filters: PostOpRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    filters,\n    signature:\n      \"event PostOpRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n  });\n}\n","import { type AbiEvent, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { encodeEventTopics, type Hex, toEventHash } from \"viem\";\nimport type { AbiEventParametersToPrimitiveTypes } from \"./types.js\";\nimport { isAbiEvent } from \"./utils.js\";\n\ntype ParseEvent<event extends AbiEvent | string> =\n  // if the method IS an AbiEvent, return it\n  event extends AbiEvent\n    ? event\n    : event extends string // we now know we are in \"string\" territory\n      ? // if the string starts with `function` then we can parse it\n        event extends `event ${string}`\n        ? ParseAbiItem<event>\n        : // do we have an ABI to check, check the length\n          AbiEvent\n      : // this means its neither have an AbiEvent NOR a string -> never\n        never;\n\ntype EventFilters<abiEvent extends AbiEvent> =\n  AbiEventParametersToPrimitiveTypes<abiEvent[\"inputs\"]>;\n\nexport type PrepareEventOptions<\n  TSignature extends `event ${string}` | AbiEvent,\n> = {\n  signature: TSignature;\n  filters?: Readonly<EventFilters<ParseEvent<TSignature>>>;\n};\n\nexport type PreparedEvent<abiEvent extends AbiEvent> = {\n  abiEvent: abiEvent;\n  hash: Hex;\n  topics: Hex[];\n};\n\n/**\n * Prepares an event by parsing the signature, generating the event hash, and encoding the event topics.\n * @param options - The options for preparing the event.\n * @returns The prepared event object.\n * @example\n * ```ts\n * import { prepareEvent } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n * ```\n * @contract\n */\nexport function prepareEvent<TSignature extends `event ${string}` | AbiEvent>(\n  options: PrepareEventOptions<TSignature>,\n): PreparedEvent<ParseEvent<TSignature>> {\n  const { signature } = options;\n  let resolvedSignature: ParseEvent<TSignature>;\n  if (isAbiEvent(signature)) {\n    resolvedSignature = signature as ParseEvent<TSignature>;\n  } else {\n    resolvedSignature = parseAbiItem(signature) as ParseEvent<TSignature>;\n  }\n\n  return {\n    abiEvent: resolvedSignature,\n    hash: toEventHash(resolvedSignature),\n    // @ts-expect-error - TODO: investiagte why this complains, it works fine however\n    topics: encodeEventTopics({\n      abi: [resolvedSignature],\n      args: options.filters,\n    }),\n  };\n}\n","import { decodeErrorResult } from \"viem\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { getContract } from \"../../../contract/contract.js\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport { postOpRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.js\";\nimport type { ExecuteWithSigParams } from \"../../../extensions/erc7702/__generated__/MinimalAccount/write/executeWithSig.js\";\nimport type { SignedAuthorization } from \"../../../transaction/actions/eip7702/authorization.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport type { SerializableTransaction } from \"../../../transaction/serialize-transaction.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { type Hex, hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport { toEther } from \"../../../utils/units.js\";\nimport type { Account } from \"../../interfaces/wallet.js\";\nimport { getEntrypointFromFactory } from \"../index.js\";\nimport {\n  type BundlerOptions,\n  type EstimationResult,\n  formatUserOperationReceipt,\n  type GasPriceResult,\n  type PmTransactionData,\n  type SmartWalletOptions,\n  type UserOperationReceipt,\n  type UserOperationV06,\n  type UserOperationV07,\n} from \"../types.js\";\nimport { predictSmartAccountAddress } from \"./calls.js\";\nimport {\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultBundlerUrl,\n  MANAGED_ACCOUNT_GAS_BUFFER,\n} from \"./constants.js\";\nimport { prepareUserOp } from \"./userop.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Bundle a user operation.\n * @param args - The options for bundling a user operation.\n * @returns The bundle hash of the user operation.\n * @example\n * ```ts\n * import { bundleUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOpHash = await bundleUserOp({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function bundleUserOp(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  options: BundlerOptions;\n}): Promise<Hex> {\n  return sendBundlerRequest({\n    ...args,\n    operation: \"eth_sendUserOperation\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n}\n\n/**\n * Estimate the gas cost of a user operation.\n * @param args - The options for estimating the gas cost of a user operation.\n * @returns The estimated gas cost of the user operation.\n * @example\n * ```ts\n * import { estimateUserOpGas } from \"thirdweb/wallets/smart\";\n *\n * const gasCost = await estimateUserOpGas({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function estimateUserOpGas(\n  args: {\n    userOp: UserOperationV06 | UserOperationV07;\n    options: BundlerOptions;\n  },\n  stateOverrides?: {\n    [x: string]: {\n      stateDiff: {\n        [x: string]: `0x${string}`;\n      };\n    };\n  },\n): Promise<EstimationResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_estimateUserOperationGas\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n      stateOverrides ?? {},\n    ],\n  });\n\n  // add gas buffer for managed account factory delegate calls\n  return {\n    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n    paymasterPostOpGasLimit:\n      res.paymasterPostOpGasLimit !== undefined\n        ? hexToBigInt(res.paymasterPostOpGasLimit)\n        : undefined,\n    paymasterVerificationGasLimit:\n      res.paymasterVerificationGasLimit !== undefined\n        ? hexToBigInt(res.paymasterVerificationGasLimit)\n        : undefined,\n    preVerificationGas: hexToBigInt(res.preVerificationGas),\n    verificationGas:\n      res.verificationGas !== undefined\n        ? hexToBigInt(res.verificationGas)\n        : undefined,\n    verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n  };\n}\n\n/**\n * Estimate the gas cost of a user operation.\n * @param args - The options for estimating the gas cost of a user operation.\n * @returns The estimated gas cost of the user operation.\n * @example\n * ```ts\n * import { estimateUserOpGasCost } from \"thirdweb/wallets/smart\";\n *\n * const gasCost = await estimateUserOpGasCost({\n *  transactions,\n *  adminAccount,\n *  client,\n *  smartWalletOptions,\n * });\n * ```\n * @walletUtils\n */\nexport async function estimateUserOpGasCost(args: {\n  transactions: PreparedTransaction[];\n  adminAccount: Account;\n  client: ThirdwebClient;\n  smartWalletOptions: SmartWalletOptions;\n}) {\n  // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n  if (\n    args.smartWalletOptions.factoryAddress &&\n    !args.smartWalletOptions.overrides?.entrypointAddress\n  ) {\n    const entrypointAddress = await getEntrypointFromFactory(\n      args.smartWalletOptions.factoryAddress,\n      args.client,\n      args.smartWalletOptions.chain,\n    );\n    if (entrypointAddress) {\n      args.smartWalletOptions.overrides = {\n        ...args.smartWalletOptions.overrides,\n        entrypointAddress,\n      };\n    }\n  }\n\n  const userOp = await prepareUserOp({\n    adminAccount: args.adminAccount,\n    client: args.client,\n    isDeployedOverride: await isContractDeployed(\n      getContract({\n        address: await predictSmartAccountAddress({\n          adminAddress: args.adminAccount.address,\n          chain: args.smartWalletOptions.chain,\n          client: args.client,\n          factoryAddress: args.smartWalletOptions.factoryAddress,\n        }),\n        chain: args.smartWalletOptions.chain,\n        client: args.client,\n      }),\n    ),\n    smartWalletOptions: args.smartWalletOptions,\n    transactions: args.transactions,\n    waitForDeployment: false,\n  });\n\n  let gasLimit = 0n;\n  if (\"paymasterVerificationGasLimit\" in userOp) {\n    // v0.7\n    gasLimit =\n      BigInt(userOp.paymasterVerificationGasLimit ?? 0) +\n      BigInt(userOp.paymasterPostOpGasLimit ?? 0) +\n      BigInt(userOp.verificationGasLimit ?? 0) +\n      BigInt(userOp.preVerificationGas ?? 0) +\n      BigInt(userOp.callGasLimit ?? 0);\n  } else {\n    // v0.6\n    gasLimit =\n      BigInt(userOp.verificationGasLimit ?? 0) +\n      BigInt(userOp.preVerificationGas ?? 0) +\n      BigInt(userOp.callGasLimit ?? 0);\n  }\n\n  const gasCost = gasLimit * (userOp.maxFeePerGas ?? 0n);\n\n  return {\n    ether: toEther(gasCost),\n    wei: gasCost,\n  };\n}\n\n/**\n * Get the gas fees of a user operation.\n * @param args - The options for getting the gas price of a user operation.\n * @returns The gas price of the user operation.\n * @example\n * ```ts\n * import { getUserOpGasPrice } from \"thirdweb/wallets/smart\";\n *\n * const fees = await getUserOpGasPrice({\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpGasFees(args: {\n  options: BundlerOptions;\n}): Promise<GasPriceResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"thirdweb_getUserOperationGasPrice\",\n    params: [],\n  });\n\n  return {\n    maxFeePerGas: hexToBigInt(res.maxFeePerGas),\n    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n  };\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceipt({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<TransactionReceipt | undefined> {\n  const res = await getUserOpReceiptRaw(args);\n\n  if (!res) {\n    return undefined;\n  }\n\n  if (res.success === false) {\n    // parse revert reason\n    const logs = parseEventLogs({\n      events: [userOperationRevertReasonEvent(), postOpRevertReasonEvent()],\n      logs: res.logs,\n    });\n    const revertReason = logs[0]?.args?.revertReason;\n    if (!revertReason) {\n      throw new Error(\n        `UserOp failed at txHash: ${res.receipt.transactionHash}`,\n      );\n    }\n    const revertMsg = decodeErrorResult({\n      data: revertReason,\n    });\n    throw new Error(\n      `UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${\n        res.receipt.transactionHash\n      }`,\n    );\n  }\n  return res.receipt;\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The raw receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceiptRaw } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceiptRaw({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceiptRaw(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<UserOperationReceipt | undefined> {\n  const res = await sendBundlerRequest({\n    operation: \"eth_getUserOperationReceipt\",\n    options: args,\n    params: [args.userOpHash],\n  });\n  if (!res) {\n    return undefined;\n  }\n  return formatUserOperationReceipt(res as UserOperationReceipt);\n}\n\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args: {\n  options: BundlerOptions;\n  transaction: SerializableTransaction;\n}): Promise<PmTransactionData> {\n  const res = await sendBundlerRequest({\n    operation: \"zk_paymasterData\",\n    options: args.options,\n    params: [args.transaction],\n  });\n\n  return {\n    paymaster: res.paymaster,\n    paymasterInput: res.paymasterInput,\n  };\n}\n\n/**\n * @internal\n */\nexport async function executeWithSignature(args: {\n  eoaAddress: `0x${string}`;\n  wrappedCalls: ExecuteWithSigParams[\"wrappedCalls\"];\n  signature: `0x${string}`;\n  authorization: SignedAuthorization | undefined;\n  options: BundlerOptions;\n}): Promise<{ transactionId: string }> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"tw_execute\",\n    params: [\n      args.eoaAddress,\n      args.wrappedCalls,\n      args.signature,\n      args.authorization,\n    ],\n  });\n\n  if (!res.queueId) {\n    throw new Error(`Error executing 7702 transaction: ${stringify(res)}`);\n  }\n\n  return {\n    transactionId: res.queueId,\n  };\n}\n\n/**\n * @internal\n */\nexport async function getQueuedTransactionHash(args: {\n  transactionId: string;\n  options: BundlerOptions;\n}): Promise<{ transactionHash: Hex }> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"tw_getTransactionHash\",\n    params: [args.transactionId],\n  });\n  return {\n    transactionHash: res.transactionHash,\n  };\n}\n\nexport async function broadcastZkTransaction(args: {\n  options: BundlerOptions;\n  transaction: SerializableTransaction;\n  signedTransaction: Hex;\n}): Promise<{ transactionHash: Hex }> {\n  const res = await sendBundlerRequest({\n    operation: \"zk_broadcastTransaction\",\n    options: args.options,\n    params: [\n      {\n        ...args.transaction,\n        signedTransaction: args.signedTransaction,\n      },\n    ],\n  });\n\n  return {\n    transactionHash: res.transactionHash,\n  };\n}\n\nasync function sendBundlerRequest(args: {\n  options: BundlerOptions;\n  operation:\n    | \"eth_estimateUserOperationGas\"\n    | \"eth_sendUserOperation\"\n    | \"eth_getUserOperationReceipt\"\n    | \"thirdweb_getUserOperationGasPrice\"\n    | \"zk_paymasterData\"\n    | \"zk_broadcastTransaction\"\n    | \"tw_execute\"\n    | \"tw_getTransactionHash\";\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  params: any[];\n}) {\n  const { options, operation, params } = args;\n\n  const bundlerUrl = options.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  const fetchWithHeaders = getClientFetch(options.client);\n  const response = await fetchWithHeaders(bundlerUrl, {\n    useAuthToken: true,\n    body: stringify({\n      id: 1,\n      jsonrpc: \"2.0\",\n      method: operation,\n      params,\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    method: \"POST\",\n  });\n  const res = await response.json();\n  if (!response.ok || res.error) {\n    let error = res.error || response.statusText;\n    if (typeof error === \"object\") {\n      error = stringify(error);\n    }\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  return res.result;\n}\n","import type { AbiEvent } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiEvent(item: unknown): item is AbiEvent {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"event\"\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[2,3,4,5,6,7,8,9,10,11,12,13,14]}