{"version":3,"sources":["../../../../node_modules/viem/utils/formatters/transactionRequest.ts","../../../../node_modules/viem/constants/solidity.ts","../../../../node_modules/viem/utils/hash/hashSignature.ts","../../../../node_modules/viem/node_modules/abitype/src/regex.ts","../../../../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiParameter.ts","../../../../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiParameters.ts","../../../../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiItem.ts","../../../../node_modules/viem/utils/hash/normalizeSignature.ts","../../../../node_modules/viem/utils/hash/toSignature.ts","../../../../node_modules/viem/utils/hash/toSignatureHash.ts","../../../../node_modules/viem/utils/hash/toFunctionSelector.ts","../../../../node_modules/viem/errors/cursor.ts","../../../../node_modules/viem/utils/cursor.ts","../../../../node_modules/viem/utils/abi/decodeAbiParameters.ts","../../../../node_modules/viem/utils/encoding/fromBytes.ts","../../../../node_modules/viem/utils/abi/decodeErrorResult.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { AuthorizationList } from '../../types/authorization.js'\nimport type {\n  Chain,\n  ExtractChainFormatterParameters,\n} from '../../types/chain.js'\nimport type { ByteArray } from '../../types/misc.js'\nimport type {\n  RpcAuthorizationList,\n  RpcTransactionRequest,\n} from '../../types/rpc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { bytesToHex, numberToHex } from '../encoding/toHex.js'\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\n\nexport type FormattedTransactionRequest<\n  chain extends Chain | undefined = Chain | undefined,\n> = ExtractChainFormatterParameters<\n  chain,\n  'transactionRequest',\n  TransactionRequest\n>\n\nexport const rpcTransactionType = {\n  legacy: '0x0',\n  eip2930: '0x1',\n  eip1559: '0x2',\n  eip4844: '0x3',\n  eip7702: '0x4',\n} as const\n\nexport type FormatTransactionRequestErrorType = ErrorType\n\nexport function formatTransactionRequest(\n  request: ExactPartial<TransactionRequest> & { account?: Account | undefined },\n  _?: string | undefined,\n) {\n  const rpcRequest = {} as RpcTransactionRequest\n\n  if (typeof request.authorizationList !== 'undefined')\n    rpcRequest.authorizationList = formatAuthorizationList(\n      request.authorizationList,\n    )\n  if (typeof request.accessList !== 'undefined')\n    rpcRequest.accessList = request.accessList\n  if (typeof request.blobVersionedHashes !== 'undefined')\n    rpcRequest.blobVersionedHashes = request.blobVersionedHashes\n  if (typeof request.blobs !== 'undefined') {\n    if (typeof request.blobs[0] !== 'string')\n      rpcRequest.blobs = (request.blobs as ByteArray[]).map((x) =>\n        bytesToHex(x),\n      )\n    else rpcRequest.blobs = request.blobs\n  }\n  if (typeof request.data !== 'undefined') rpcRequest.data = request.data\n  if (request.account) rpcRequest.from = request.account.address\n  if (typeof request.from !== 'undefined') rpcRequest.from = request.from\n  if (typeof request.gas !== 'undefined')\n    rpcRequest.gas = numberToHex(request.gas)\n  if (typeof request.gasPrice !== 'undefined')\n    rpcRequest.gasPrice = numberToHex(request.gasPrice)\n  if (typeof request.maxFeePerBlobGas !== 'undefined')\n    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas)\n  if (typeof request.maxFeePerGas !== 'undefined')\n    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas)\n  if (typeof request.maxPriorityFeePerGas !== 'undefined')\n    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas)\n  if (typeof request.nonce !== 'undefined')\n    rpcRequest.nonce = numberToHex(request.nonce)\n  if (typeof request.to !== 'undefined') rpcRequest.to = request.to\n  if (typeof request.type !== 'undefined')\n    rpcRequest.type = rpcTransactionType[request.type]\n  if (typeof request.value !== 'undefined')\n    rpcRequest.value = numberToHex(request.value)\n\n  return rpcRequest\n}\n\nexport type DefineTransactionRequestErrorType =\n  | DefineFormatterErrorType\n  | ErrorType\n\nexport const defineTransactionRequest = /*#__PURE__*/ defineFormatter(\n  'transactionRequest',\n  formatTransactionRequest,\n)\n\n//////////////////////////////////////////////////////////////////////////////\n\nfunction formatAuthorizationList(\n  authorizationList: AuthorizationList<number, boolean>,\n): RpcAuthorizationList {\n  return authorizationList.map(\n    (authorization) =>\n      ({\n        address: authorization.address,\n        r: authorization.r\n          ? numberToHex(BigInt(authorization.r))\n          : authorization.r,\n        s: authorization.s\n          ? numberToHex(BigInt(authorization.s))\n          : authorization.s,\n        chainId: numberToHex(authorization.chainId),\n        nonce: numberToHex(authorization.nonce),\n        ...(typeof authorization.yParity !== 'undefined'\n          ? { yParity: numberToHex(authorization.yParity) }\n          : {}),\n        ...(typeof authorization.v !== 'undefined' &&\n        typeof authorization.yParity === 'undefined'\n          ? { v: numberToHex(authorization.v) }\n          : {}),\n      }) as any,\n  ) as RpcAuthorizationList\n}\n","import type { AbiError } from 'abitype'\n\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n  1: 'An `assert` condition failed.',\n  17: 'Arithmetic operation resulted in underflow or overflow.',\n  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n  33: 'Attempted to convert to an invalid type.',\n  34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n  49: 'Performed `.pop()` on an empty array',\n  50: 'Array index is out of bounds.',\n  65: 'Allocated too much memory or created an array which is too large.',\n  81: 'Attempted to call a zero-initialized variable of internal function type.',\n} as const\n\nexport const solidityError: AbiError = {\n  inputs: [\n    {\n      name: 'message',\n      type: 'string',\n    },\n  ],\n  name: 'Error',\n  type: 'error',\n}\nexport const solidityPanic: AbiError = {\n  inputs: [\n    {\n      name: 'reason',\n      type: 'uint256',\n    },\n  ],\n  name: 'Panic',\n  type: 'error',\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport type HashSignatureErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashSignature(sig: string) {\n  return hash(sig)\n}\n","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<abiParameters>\n}\n","import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<abiItem extends Abi[number]> =\n  Abi[number] extends abiItem\n    ? string\n    :\n        | (abiItem extends AbiFunction\n            ? AbiFunction extends abiItem\n              ? string\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${abiItem['stateMutability']}`\n                  : ''}${abiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\n            : never)\n        | (abiItem extends AbiEvent\n            ? AbiEvent extends abiItem\n              ? string\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiError\n            ? AbiError extends abiItem\n              ? string\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiConstructor\n            ? AbiConstructor extends abiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiFallback\n            ? AbiFallback extends abiItem\n              ? string\n              : `fallback() external${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiReceive\n            ? AbiReceive extends abiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = abiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      abiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? abiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const abiItem extends Abi[number]>(\n  abiItem: abiItem,\n): FormatAbiItem<abiItem> {\n  type Result = FormatAbiItem<abiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs?.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  if (abiItem.type === 'fallback')\n    return `fallback() external${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }` as Result\n  return 'receive() external payable' as Result\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\ntype NormalizeSignatureParameters = string\ntype NormalizeSignatureReturnType = string\nexport type NormalizeSignatureErrorType = ErrorType\n\nexport function normalizeSignature(\n  signature: NormalizeSignatureParameters,\n): NormalizeSignatureReturnType {\n  let active = true\n  let current = ''\n  let level = 0\n  let result = ''\n  let valid = false\n\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i]\n\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true\n\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++\n    if (char === ')') level--\n\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue\n\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', ''].includes(result))\n        result = ''\n      else {\n        result += char\n\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true\n          break\n        }\n      }\n\n      continue\n    }\n\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = ''\n        active = false\n      }\n      continue\n    }\n\n    result += char\n    current += char\n  }\n\n  if (!valid) throw new BaseError('Unable to normalize signature.')\n\n  return result\n}\n","import { type AbiEvent, type AbiFunction, formatAbiItem } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type NormalizeSignatureErrorType,\n  normalizeSignature,\n} from './normalizeSignature.js'\n\nexport type ToSignatureErrorType = NormalizeSignatureErrorType | ErrorType\n\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def: string | AbiFunction | AbiEvent) => {\n  const def_ = (() => {\n    if (typeof def === 'string') return def\n    return formatAbiItem(def)\n  })()\n  return normalizeSignature(def_)\n}\n","import type { AbiEvent, AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type HashSignatureErrorType, hashSignature } from './hashSignature.js'\nimport { type ToSignatureErrorType, toSignature } from './toSignature.js'\n\nexport type ToSignatureHashErrorType =\n  | HashSignatureErrorType\n  | ToSignatureErrorType\n  | ErrorType\n\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn: string | AbiFunction | AbiEvent) {\n  return hashSignature(toSignature(fn))\n}\n","import type { AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToFunctionSelectorErrorType =\n  | ToSignatureHashErrorType\n  | SliceErrorType\n  | ErrorType\n\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn: string | AbiFunction) =>\n  slice(toSignatureHash(fn), 0, 4)\n","import { BaseError } from './base.js'\n\nexport type NegativeOffsetErrorType = NegativeOffsetError & {\n  name: 'NegativeOffsetError'\n}\nexport class NegativeOffsetError extends BaseError {\n  constructor({ offset }: { offset: number }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`, {\n      name: 'NegativeOffsetError',\n    })\n  }\n}\n\nexport type PositionOutOfBoundsErrorType = PositionOutOfBoundsError & {\n  name: 'PositionOutOfBoundsError'\n}\nexport class PositionOutOfBoundsError extends BaseError {\n  constructor({ length, position }: { length: number; position: number }) {\n    super(\n      `Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`,\n      { name: 'PositionOutOfBoundsError' },\n    )\n  }\n}\n\nexport type RecursiveReadLimitExceededErrorType =\n  RecursiveReadLimitExceededError & {\n    name: 'RecursiveReadLimitExceededError'\n  }\nexport class RecursiveReadLimitExceededError extends BaseError {\n  constructor({ count, limit }: { count: number; limit: number }) {\n    super(\n      `Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`,\n      { name: 'RecursiveReadLimitExceededError' },\n    )\n  }\n}\n","import {\n  NegativeOffsetError,\n  type NegativeOffsetErrorType,\n  PositionOutOfBoundsError,\n  type PositionOutOfBoundsErrorType,\n  RecursiveReadLimitExceededError,\n  type RecursiveReadLimitExceededErrorType,\n} from '../errors/cursor.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { ByteArray } from '../types/misc.js'\n\nexport type Cursor = {\n  bytes: ByteArray\n  dataView: DataView\n  position: number\n  positionReadCount: Map<number, number>\n  recursiveReadCount: number\n  recursiveReadLimit: number\n  remaining: number\n  assertReadLimit(position?: number): void\n  assertPosition(position: number): void\n  decrementPosition(offset: number): void\n  getReadCount(position?: number): number\n  incrementPosition(offset: number): void\n  inspectByte(position?: number): ByteArray[number]\n  inspectBytes(length: number, position?: number): ByteArray\n  inspectUint8(position?: number): number\n  inspectUint16(position?: number): number\n  inspectUint24(position?: number): number\n  inspectUint32(position?: number): number\n  pushByte(byte: ByteArray[number]): void\n  pushBytes(bytes: ByteArray): void\n  pushUint8(value: number): void\n  pushUint16(value: number): void\n  pushUint24(value: number): void\n  pushUint32(value: number): void\n  readByte(): ByteArray[number]\n  readBytes(length: number, size?: number): ByteArray\n  readUint8(): number\n  readUint16(): number\n  readUint24(): number\n  readUint32(): number\n  setPosition(position: number): () => void\n  _touch(): void\n}\n\ntype CursorErrorType =\n  | CursorAssertPositionErrorType\n  | CursorDecrementPositionErrorType\n  | CursorIncrementPositionErrorType\n  | ErrorType\n\ntype CursorAssertPositionErrorType = PositionOutOfBoundsErrorType | ErrorType\n\ntype CursorDecrementPositionErrorType = NegativeOffsetErrorType | ErrorType\n\ntype CursorIncrementPositionErrorType = NegativeOffsetErrorType | ErrorType\n\ntype StaticCursorErrorType =\n  | NegativeOffsetErrorType\n  | RecursiveReadLimitExceededErrorType\n\nconst staticCursor: Cursor = {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit)\n      throw new RecursiveReadLimitExceededError({\n        count: this.recursiveReadCount + 1,\n        limit: this.recursiveReadLimit,\n      })\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1)\n      throw new PositionOutOfBoundsError({\n        length: this.bytes.length,\n        position,\n      })\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position - offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position + offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + length - 1)\n    return this.bytes.subarray(position, position + length)\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 1)\n    return this.dataView.getUint16(position)\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 2)\n    return (\n      (this.dataView.getUint16(position) << 8) +\n      this.dataView.getUint8(position + 2)\n    )\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 3)\n    return this.dataView.getUint32(position)\n  },\n  pushByte(byte: ByteArray[number]) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = byte\n    this.position++\n  },\n  pushBytes(bytes: ByteArray) {\n    this.assertPosition(this.position + bytes.length - 1)\n    this.bytes.set(bytes, this.position)\n    this.position += bytes.length\n  },\n  pushUint8(value: number) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = value\n    this.position++\n  },\n  pushUint16(value: number) {\n    this.assertPosition(this.position + 1)\n    this.dataView.setUint16(this.position, value)\n    this.position += 2\n  },\n  pushUint24(value: number) {\n    this.assertPosition(this.position + 2)\n    this.dataView.setUint16(this.position, value >> 8)\n    this.dataView.setUint8(this.position + 2, value & ~4294967040)\n    this.position += 3\n  },\n  pushUint32(value: number) {\n    this.assertPosition(this.position + 3)\n    this.dataView.setUint32(this.position, value)\n    this.position += 4\n  },\n  readByte() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectByte()\n    this.position++\n    return value\n  },\n  readBytes(length, size) {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectBytes(length)\n    this.position += size ?? length\n    return value\n  },\n  readUint8() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint8()\n    this.position += 1\n    return value\n  },\n  readUint16() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint16()\n    this.position += 2\n    return value\n  },\n  readUint24() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint24()\n    this.position += 3\n    return value\n  },\n  readUint32() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint32()\n    this.position += 4\n    return value\n  },\n  get remaining() {\n    return this.bytes.length - this.position\n  },\n  setPosition(position) {\n    const oldPosition = this.position\n    this.assertPosition(position)\n    this.position = position\n    return () => (this.position = oldPosition)\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return\n    const count = this.getReadCount()\n    this.positionReadCount.set(this.position, count + 1)\n    if (count > 0) this.recursiveReadCount++\n  },\n}\n\ntype CursorConfig = { recursiveReadLimit?: number | undefined }\n\nexport type CreateCursorErrorType =\n  | CursorErrorType\n  | StaticCursorErrorType\n  | ErrorType\n\nexport function createCursor(\n  bytes: ByteArray,\n  { recursiveReadLimit = 8_192 }: CursorConfig = {},\n): Cursor {\n  const cursor: Cursor = Object.create(staticCursor)\n  cursor.bytes = bytes\n  cursor.dataView = new DataView(\n    bytes.buffer,\n    bytes.byteOffset,\n    bytes.byteLength,\n  )\n  cursor.positionReadCount = new Map()\n  cursor.recursiveReadLimit = recursiveReadLimit\n  return cursor\n}\n","import type { AbiParameter, AbiParametersToPrimitiveTypes } from 'abitype'\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n  type InvalidAbiDecodingTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../address/getAddress.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceBytesErrorType, sliceBytes } from '../data/slice.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\nimport {\n  type BytesToBigIntErrorType,\n  type BytesToBoolErrorType,\n  type BytesToNumberErrorType,\n  type BytesToStringErrorType,\n  bytesToBigInt,\n  bytesToBool,\n  bytesToNumber,\n  bytesToString,\n} from '../encoding/fromBytes.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  params extends readonly AbiParameter[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  params extends readonly AbiParameter[] ? params : AbiParameter[]\n>\n\nexport type DecodeAbiParametersErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | DecodeParameterErrorType\n  | SizeErrorType\n  | CreateCursorErrorType\n  | ErrorType\n\nexport function decodeAbiParameters<\n  const params extends readonly AbiParameter[],\n>(\n  params: params,\n  data: ByteArray | Hex,\n): DecodeAbiParametersReturnType<params> {\n  const bytes = typeof data === 'string' ? hexToBytes(data) : data\n  const cursor = createCursor(bytes)\n\n  if (size(bytes) === 0 && params.length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data: typeof data === 'string' ? data : bytesToHex(data),\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n\n  let consumed = 0\n  const values = []\n  for (let i = 0; i < params.length; ++i) {\n    const param = params[i]\n    cursor.setPosition(consumed)\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: 0,\n    })\n    consumed += consumed_\n    values.push(data)\n  }\n  return values as DecodeAbiParametersReturnType<params>\n}\n\ntype DecodeParameterErrorType =\n  | DecodeArrayErrorType\n  | DecodeTupleErrorType\n  | DecodeAddressErrorType\n  | DecodeBoolErrorType\n  | DecodeBytesErrorType\n  | DecodeNumberErrorType\n  | DecodeStringErrorType\n  | InvalidAbiDecodingTypeErrorType\n\nfunction decodeParameter(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(cursor, { ...param, type }, { length, staticPosition })\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, { staticPosition })\n\n  if (param.type === 'address') return decodeAddress(cursor)\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n// Type Decoders\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\ntype DecodeAddressErrorType =\n  | ChecksumAddressErrorType\n  | BytesToHexErrorType\n  | SliceBytesErrorType\n  | ErrorType\n\nfunction decodeAddress(cursor: Cursor) {\n  const value = cursor.readBytes(32)\n  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32]\n}\n\ntype DecodeArrayErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeArray(\n  cursor: Cursor,\n  param: AbiParameter,\n  { length, staticPosition }: { length: number | null; staticPosition: number },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = bytesToNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\ntype DecodeBoolErrorType = BytesToBoolErrorType | ErrorType\n\nfunction decodeBool(cursor: Cursor) {\n  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32]\n}\n\ntype DecodeBytesErrorType =\n  | BytesToNumberErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nfunction decodeBytes(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = bytesToNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = bytesToNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [bytesToHex(data), 32]\n  }\n\n  const value = bytesToHex(cursor.readBytes(Number.parseInt(size, 10), 32))\n  return [value, 32]\n}\n\ntype DecodeNumberErrorType =\n  | BytesToNumberErrorType\n  | BytesToBigIntErrorType\n  | ErrorType\n\nfunction decodeNumber(cursor: Cursor, param: AbiParameter) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256', 10)\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? bytesToBigInt(value, { signed })\n      : bytesToNumber(value, { signed }),\n    32,\n  ]\n}\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\ntype DecodeTupleErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeTuple(\n  cursor: Cursor,\n  param: TupleAbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\ntype DecodeStringErrorType =\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | TrimErrorType\n  | ErrorType\n\nfunction decodeString(\n  cursor: Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = bytesToNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = bytesToNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = bytesToString(trim(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n","import { InvalidBytesBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport {\n  type AssertSizeErrorType,\n  assertSize,\n  type HexToBigIntErrorType,\n  type HexToNumberErrorType,\n  hexToBigInt,\n  hexToNumber,\n} from './fromHex.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type FromBytesParameters<\n  to extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n> =\n  | to\n  | {\n      /** Size of the bytes. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromBytesReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'hex'\n    ? Hex\n    : to extends 'bigint'\n      ? bigint\n      : to extends 'number'\n        ? number\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromBytesErrorType =\n  | BytesToHexErrorType\n  | BytesToBigIntErrorType\n  | BytesToBoolErrorType\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes\n * - Example: https://viem.sh/docs/utilities/fromBytes#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes<\n  to extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n>(\n  bytes: ByteArray,\n  toOrOpts: FromBytesParameters<to>,\n): FromBytesReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number')\n    return bytesToNumber(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'bigint')\n    return bytesToBigInt(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'boolean')\n    return bytesToBool(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'string')\n    return bytesToString(bytes, opts) as FromBytesReturnType<to>\n  return bytesToHex(bytes, opts) as FromBytesReturnType<to>\n}\n\nexport type BytesToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBigIntErrorType =\n  | BytesToHexErrorType\n  | HexToBigIntErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigInt } from 'viem'\n * const data = bytesToBigInt(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigInt(\n  bytes: ByteArray,\n  opts: BytesToBigIntOpts = {},\n): bigint {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToBigInt(hex, opts)\n}\n\nexport type BytesToBoolOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBoolErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(\n  bytes_: ByteArray,\n  opts: BytesToBoolOpts = {},\n): boolean {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes)\n  }\n  if (bytes.length > 1 || bytes[0] > 1)\n    throw new InvalidBytesBooleanError(bytes)\n  return Boolean(bytes[0])\n}\n\nexport type BytesToNumberOpts = BytesToBigIntOpts\n\nexport type BytesToNumberErrorType =\n  | BytesToHexErrorType\n  | HexToNumberErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(\n  bytes: ByteArray,\n  opts: BytesToNumberOpts = {},\n): number {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToNumber(hex, opts)\n}\n\nexport type BytesToStringOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToStringErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(\n  bytes_: ByteArray,\n  opts: BytesToStringOpts = {},\n): string {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import type { Abi, ExtractAbiError } from 'abitype'\n\nimport { solidityError, solidityPanic } from '../../constants/solidity.js'\nimport {\n  AbiDecodingZeroDataError,\n  type AbiDecodingZeroDataErrorType,\n  AbiErrorSignatureNotFoundError,\n  type AbiErrorSignatureNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  ContractErrorArgs,\n  ContractErrorName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { slice } from '../data/slice.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeErrorResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n> = { abi?: abi | undefined; data: Hex }\n\nexport type DecodeErrorResultReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  ///\n  allErrorNames extends ContractErrorName<abi> = ContractErrorName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? UnionEvaluate<\n      {\n        [errorName in allErrorNames]: {\n          abiItem: abi extends Abi\n            ? Abi extends abi\n              ? AbiItem\n              : ExtractAbiError<abi, errorName>\n            : AbiItem\n          args: ContractErrorArgs<abi, errorName>\n          errorName: errorName\n        }\n      }[allErrorNames]\n    >\n  : {\n      abiItem: AbiItem\n      args: readonly unknown[] | undefined\n      errorName: string\n    }\n\nexport type DecodeErrorResultErrorType =\n  | AbiDecodingZeroDataErrorType\n  | AbiErrorSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function decodeErrorResult<const abi extends Abi | readonly unknown[]>(\n  parameters: DecodeErrorResultParameters<abi>,\n): DecodeErrorResultReturnType<abi> {\n  const { abi, data } = parameters as DecodeErrorResultParameters\n\n  const signature = slice(data, 0, 4)\n  if (signature === '0x') throw new AbiDecodingZeroDataError()\n\n  const abi_ = [...(abi || []), solidityError, solidityPanic]\n  const abiItem = abi_.find(\n    (x) =>\n      x.type === 'error' && signature === toFunctionSelector(formatAbiItem(x)),\n  )\n  if (!abiItem)\n    throw new AbiErrorSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeErrorResult',\n    })\n  return {\n    abiItem,\n    args:\n      'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0\n        ? decodeAbiParameters(abiItem.inputs, slice(data, 4))\n        : undefined,\n    errorName: (abiItem as { name: string }).name,\n  } as DecodeErrorResultReturnType<abi>\n}\n"],"names":[],"mappings":"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","ignoreList":[4,5,6,7,8,9,10,11,12,13,14]}