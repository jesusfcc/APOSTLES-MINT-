{"version":3,"sources":["../../../../node_modules/ox/core/TypedData.ts","../../../../node_modules/abitype/src/human-readable/parseAbiParameters.ts","../../../../node_modules/ox/core/internal/abiParameters.ts","../../../../node_modules/ox/core/AbiParameters.ts"],"sourcesContent":["import type * as abitype from 'abitype'\nimport * as AbiParameters from './AbiParameters.js'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\nimport type { Compute } from './internal/types.js'\n\nexport type TypedData = abitype.TypedData\nexport type Domain = abitype.TypedDataDomain\nexport type Parameter = abitype.TypedDataParameter\n\n// TODO: Make reusable for Viem?\nexport type Definition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = primaryType extends 'EIP712Domain'\n  ? EIP712DomainDefinition<typedData, primaryType>\n  : MessageDefinition<typedData, primaryType, primaryTypes>\n\nexport type EIP712DomainDefinition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends 'EIP712Domain' = 'EIP712Domain',\n  ///\n  schema extends Record<string, unknown> = typedData extends TypedData\n    ? abitype.TypedDataToPrimitiveTypes<typedData>\n    : Record<string, unknown>,\n> = {\n  types?: typedData | undefined\n} & {\n  primaryType:\n    | 'EIP712Domain'\n    | (primaryType extends 'EIP712Domain' ? primaryType : never)\n  domain: schema extends { EIP712Domain: infer domain }\n    ? domain\n    : Compute<Domain>\n  message?: undefined\n}\n\nexport type MessageDefinition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n  schema extends Record<string, unknown> = typedData extends TypedData\n    ? abitype.TypedDataToPrimitiveTypes<typedData>\n    : Record<string, unknown>,\n  message = schema[primaryType extends keyof schema\n    ? primaryType\n    : keyof schema],\n> = {\n  types: typedData\n} & {\n  primaryType:\n    | primaryTypes // show all values\n    | (primaryType extends primaryTypes ? primaryType : never) // infer value\n  domain?:\n    | (schema extends { EIP712Domain: infer domain } ? domain : Compute<Domain>)\n    | undefined\n  message: { [_: string]: any } extends message // Check if message was inferred\n    ? Record<string, unknown>\n    : message\n}\n\n/**\n * Asserts that [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.assert({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function assert<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: assert.Value<typedData, primaryType>): void {\n  const { domain, message, primaryType, types } =\n    value as unknown as assert.Value\n\n  const validateData = (\n    struct: readonly Parameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(Solidity.integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        Hex.fromNumber(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_ ?? '') / 8,\n        })\n      }\n\n      if (\n        type === 'address' &&\n        typeof value === 'string' &&\n        !Address.validate(value)\n      )\n        throw new Address.InvalidAddressError({\n          address: value,\n          cause: new Address.InvalidInputError(),\n        })\n\n      const bytesMatch = type.match(Solidity.bytesRegex)\n      if (bytesMatch) {\n        const [, size] = bytesMatch\n        if (size && Hex.size(value as Hex.Hex) !== Number.parseInt(size))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size),\n            givenSize: Hex.size(value as Hex.Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport declare namespace assert {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType =\n    | Address.InvalidAddressError\n    | BytesSizeMismatchError\n    | InvalidPrimaryTypeError\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Creates [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) [`domainSeparator`](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator) for the provided domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.domainSeparator({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: '0x9911ee4f58a7059a8f5385248040e6984d80e2c849500fe6a4d11c4fa98c2af3'\n * ```\n *\n * @param domain - The domain for which to create the domain separator.\n * @returns The domain separator.\n */\nexport function domainSeparator(domain: Domain): Hex.Hex {\n  return hashDomain({\n    domain,\n  })\n}\n\nexport declare namespace domainSeparator {\n  type ErrorType = hashDomain.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712): `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`.\n *\n * @example\n * ```ts twoslash\n * import { TypedData, Hash } from 'ox'\n *\n * const data = TypedData.encode({ // [!code focus:33]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n * // @log: '0x19012fdf3441fcaf4f30c7e16292b258a5d7054a4e2e00dbd7b7d2f467f2b8fb9413c52c0ee5d84264471806290a3f2c4cecfc5490626bf912d01f240d7a274b371e'\n * // @log: (0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message))\n *\n * const hash = Hash.keccak256(data)\n * ```\n *\n * @param value - The Typed Data to encode.\n * @returns The encoded Typed Data.\n */\nexport function encode<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: encode.Value<typedData, primaryType>): Hex.Hex {\n  const { domain = {}, message, primaryType } = value as encode.Value\n\n  const types = {\n    EIP712Domain: extractEip712DomainTypes(domain),\n    ...value.types,\n  } as TypedData\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  assert({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  // Typed Data Format: `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`\n  const parts: Hex.Hex[] = ['0x19', '0x01']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types,\n      }),\n    )\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types,\n      }),\n    )\n\n  return Hex.concat(...parts)\n}\n\nexport declare namespace encode {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType =\n    | extractEip712DomainTypes.ErrorType\n    | hashDomain.ErrorType\n    | hashStruct.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for the provided primaryType.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.encodeType({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n * })\n * // @log: 'Foo(address address,string name,string foo)'\n * ```\n *\n * @param value - The Typed Data schema.\n * @returns The encoded type.\n */\nexport function encodeType(value: encodeType.Value): string {\n  const { primaryType, types } = value\n\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${(types[type] ?? [])\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\nexport declare namespace encodeType {\n  type Value = {\n    primaryType: string\n    types: TypedData\n  }\n\n  type ErrorType = findTypeDependencies.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Gets [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for EIP-721 domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.extractEip712DomainTypes({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: [\n * // @log:   { 'name': 'name', 'type': 'string' },\n * // @log:   { 'name': 'version', 'type': 'string' },\n * // @log:   { 'name': 'chainId', 'type': 'uint256' },\n * // @log:   { 'name': 'verifyingContract', 'type': 'address' },\n * // @log: ]\n * ```\n *\n * @param domain - The EIP-712 domain.\n * @returns The EIP-712 domain schema.\n */\nexport function extractEip712DomainTypes(\n  domain: Domain | undefined,\n): Parameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as Parameter[]\n}\n\nexport declare namespace extractEip712DomainTypes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Gets the payload to use for signing typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The typed data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: encode.Value<typedData, primaryType>): Hex.Hex {\n  return Hash.keccak256(encode(value))\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashDomain({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n * })\n * // @log: '0x6192106f129ce05c9075d319c1fa6ea9b3ae37cbd0c1ef92e2be7137bb07baa1'\n * ```\n *\n * @param value - The Typed Data domain and types.\n * @returns The hashed domain.\n */\nexport function hashDomain(value: hashDomain.Value): Hex.Hex {\n  const { domain, types } = value\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types: {\n      ...types,\n      EIP712Domain: types?.EIP712Domain || extractEip712DomainTypes(domain),\n    },\n  })\n}\n\nexport declare namespace hashDomain {\n  type Value = {\n    /** The Typed Data domain. */\n    domain: Domain\n    /** The Typed Data types. */\n    types?:\n      | {\n          EIP712Domain?: readonly Parameter[] | undefined\n          [key: string]: readonly Parameter[] | undefined\n        }\n      | undefined\n  }\n\n  type ErrorType = hashStruct.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) struct.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashStruct({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n *   data: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: '0x996fb3b6d48c50312d69abdd4c1b6fb02057c85aa86bb8d04c6f023326a168ce'\n * ```\n *\n * @param value - The Typed Data struct to hash.\n * @returns The hashed Typed Data struct.\n */\nexport function hashStruct(value: hashStruct.Value): Hex.Hex {\n  const { data, primaryType, types } = value\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return Hash.keccak256(encoded)\n}\n\nexport declare namespace hashStruct {\n  type Value = {\n    /** The Typed Data struct to hash. */\n    data: Record<string, unknown>\n    /** The primary type of the Typed Data struct. */\n    primaryType: string\n    /** The types of the Typed Data struct. */\n    types: TypedData\n  }\n\n  type ErrorType =\n    | encodeData.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema into string.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.serialize({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: \"{\"domain\":{},\"message\":{\"address\":\"0xb9cab4f0e46f7f6b1024b5a7463734fa68e633f9\",\"name\":\"jxom\",\"foo\":\"0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9\"},\"primaryType\":\"Foo\",\"types\":{\"Foo\":[{\"name\":\"address\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"foo\",\"type\":\"string\"}]}}\"\n * ```\n *\n * @param value - The Typed Data schema to serialize.\n * @returns The serialized Typed Data schema. w\n */\nexport function serialize<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: serialize.Value<typedData, primaryType>): string {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = value as unknown as serialize.Value\n\n  const normalizeData = (\n    struct: readonly Parameter[],\n    value: Record<string, unknown>,\n  ) => {\n    const data = { ...value }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!domain_) return {}\n    const type = types.EIP712Domain ?? extractEip712DomainTypes(domain_)\n    return normalizeData(type, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    if (!types[primaryType]) return {}\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return Json.stringify({ domain, message, primaryType, types }, (_, value) => {\n    if (typeof value === 'bigint') return value.toString()\n    return value\n  })\n}\n\nexport declare namespace serialize {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType = Json.stringify.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * const valid = TypedData.validate({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: true\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function validate<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: assert.Value<typedData, primaryType>): boolean {\n  try {\n    assert(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/** Thrown when the bytes size of a typed data value does not match the expected size. */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  override readonly name = 'TypedData.BytesSizeMismatchError'\n\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\n/** Thrown when the domain is invalid. */\nexport class InvalidDomainError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidDomainError'\n\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${Json.stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\n/** Thrown when the primary type of a typed data value is invalid. */\nexport class InvalidPrimaryTypeError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidPrimaryTypeError'\n\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\n/** Thrown when the struct type is not a valid type. */\nexport class InvalidStructTypeError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidStructTypeError'\n\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n    })\n  }\n}\n\n/** @internal */\nexport function encodeData(value: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: TypedData\n}): Hex.Hex {\n  const { data, primaryType, types } = value\n  const encodedTypes: AbiParameters.Parameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType] ?? []) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return AbiParameters.encode(encodedTypes, encodedValues)\n}\n\n/** @internal */\nexport declare namespace encodeData {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | encodeField.ErrorType\n    | hashType.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function hashType(value: {\n  primaryType: string\n  types: TypedData\n}): Hex.Hex {\n  const { primaryType, types } = value\n  const encodedHashType = Hex.fromString(encodeType({ primaryType, types }))\n  return Hash.keccak256(encodedHashType)\n}\n\n/** @internal */\nexport declare namespace hashType {\n  type ErrorType =\n    | Hex.fromString.ErrorType\n    | encodeType.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeField(properties: {\n  types: TypedData\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameters.Parameter, value: Hex.Hex] {\n  let { types, name, type, value } = properties\n\n  if (types[type] !== undefined)\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, Hash.keccak256(value, { as: 'Hex' })]\n  }\n\n  if (type === 'string')\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(Bytes.fromString(value), { as: 'Hex' }),\n    ]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameters.Parameter, any][]).map(\n      (item) =>\n        encodeField({\n          name,\n          type: parsedType,\n          types,\n          value: item,\n        }),\n    )\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(\n        AbiParameters.encode(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n\n/** @internal */\nexport declare namespace encodeField {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function findTypeDependencies(\n  value: {\n    primaryType: string\n    types: TypedData\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const { primaryType: primaryType_, types } = value\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined)\n    return results\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType])\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  return results\n}\n\n/** @internal */\nexport declare namespace findTypeDependencies {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n","import type { AbiParameter } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiParametersError } from './errors/abiParameter.js'\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { splitParameters } from './runtime/utils.js'\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { SplitParameters } from './types/utils.js'\nimport type { ParseAbiParameters as ParseAbiParameters_ } from './types/utils.js'\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * type Result = ParseAbiParameters('address from, address to, uint256 amount')\n * //   ^? type Result: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * type Result = ParseAbiParameters<\n *   // ^? type Result: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   ['Baz bar', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n> =\n  | (params extends string\n      ? params extends ''\n        ? never\n        : string extends params\n          ? readonly AbiParameter[]\n          : ParseAbiParameters_<SplitParameters<params>, { modifier: Modifier }>\n      : never)\n  | (params extends readonly string[]\n      ? string[] extends params\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\n        : ParseStructs<params> extends infer structs\n          ? {\n              [key in keyof params]: params[key] extends string\n                ? IsStructSignature<params[key]> extends true\n                  ? never\n                  : ParseAbiParameters_<\n                      SplitParameters<params[key]>,\n                      { modifier: Modifier; structs: structs }\n                    >\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never> extends readonly [...infer content]\n              ? content['length'] extends 0\n                ? never\n                : DeepFlatten<content>\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Flatten all members of {@link T}\n *\n * @param T - List of items to flatten\n * @param Acc - The accumulator used while recursing\n * @returns The flattened array\n *\n * @example\n * type Result = DeepFlatten<[['a', 'b'], [['c']]]>\n * //   ^? type Result = ['a', 'b', 'c']\n */\ntype DeepFlatten<\n  T extends readonly unknown[],\n  Acc extends readonly unknown[] = readonly [],\n> = T extends readonly [infer head, ...infer tail]\n  ? tail extends undefined\n    ? never\n    : head extends readonly unknown[]\n      ? DeepFlatten<tail, readonly [...Acc, ...DeepFlatten<head>]>\n      : DeepFlatten<tail, readonly [...Acc, head]>\n  : Acc\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n>(\n  params: Narrow<params> &\n    (\n      | (params extends string\n          ? params extends ''\n            ? Error<'Empty string is not allowed.'>\n            : unknown\n          : never)\n      | (params extends readonly string[]\n          ? params extends readonly [] // empty array\n            ? Error<'At least one parameter required.'>\n            : string[] extends params\n              ? unknown\n              : unknown // TODO: Validate param string\n          : never)\n    ),\n): ParseAbiParameters<params> {\n  const abiParameters: AbiParameter[] = []\n  if (typeof params === 'string') {\n    const parameters = splitParameters(params)\n    const length = parameters.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter_(parameters[i]!, { modifiers }))\n    }\n  } else {\n    const structs = parseStructs(params as readonly string[])\n    const length = params.length as number\n    for (let i = 0; i < length; i++) {\n      const signature = (params as readonly string[])[i]!\n      if (isStructSignature(signature)) continue\n      const parameters = splitParameters(signature)\n      const length = parameters.length\n      for (let k = 0; k < length; k++) {\n        abiParameters.push(\n          parseAbiParameter_(parameters[k]!, { modifiers, structs }),\n        )\n      }\n    }\n  }\n\n  if (abiParameters.length === 0)\n    throw new InvalidAbiParametersError({ params })\n\n  return abiParameters as ParseAbiParameters<params>\n}\n","import type {\n  AbiParameter,\n  AbiParameterKind,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\nimport * as AbiParameters from '../AbiParameters.js'\nimport * as Address from '../Address.js'\nimport * as Bytes from '../Bytes.js'\nimport * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport { integerRegex } from '../Solidity.js'\nimport type * as Cursor from './cursor.js'\nimport type { Compute, IsNarrowable, UnionToIntersection } from './types.js'\n\n/** @internal */\nexport type ParameterToPrimitiveType<\n  abiParameter extends AbiParameter | { name: string; type: unknown },\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParameterToPrimitiveType<abiParameter, abiParameterKind>\n\n/** @internal */\nexport type PreparedParameter = { dynamic: boolean; encoded: Hex.Hex }\n\n/** @internal */\nexport type ToObject<\n  parameters extends readonly AbiParameter[],\n  kind extends AbiParameterKind = AbiParameterKind,\n> = IsNarrowable<parameters, AbiParameters.AbiParameters> extends true\n  ? Compute<\n      UnionToIntersection<\n        {\n          [index in keyof parameters]: parameters[index] extends {\n            name: infer name extends string\n          }\n            ? {\n                [key in name]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n            : {\n                [key in index]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n        }[number]\n      >\n    >\n  : unknown\n\n/** @internal */\nexport type ToPrimitiveTypes<\n  abiParameters extends readonly AbiParameter[],\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParametersToPrimitiveTypes<abiParameters, abiParameterKind>\n\n/** @internal */\nexport type Tuple = ParameterToPrimitiveType<TupleAbiParameter>\n\n/** @internal */\nexport function decodeParameter(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(\n      cursor,\n      { ...param, type },\n      { checksumAddress, length, staticPosition },\n    )\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, {\n      checksumAddress,\n      staticPosition,\n    })\n  if (param.type === 'address')\n    return decodeAddress(cursor, { checksum: checksumAddress })\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new AbiParameters.InvalidTypeError(param.type)\n}\n\nexport declare namespace decodeParameter {\n  type ErrorType =\n    | decodeArray.ErrorType\n    | decodeTuple.ErrorType\n    | decodeAddress.ErrorType\n    | decodeBool.ErrorType\n    | decodeBytes.ErrorType\n    | decodeNumber.ErrorType\n    | decodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\n/** @internal */\nexport function decodeAddress(\n  cursor: Cursor.Cursor,\n  options: { checksum?: boolean | undefined } = {},\n) {\n  const { checksum = false } = options\n  const value = cursor.readBytes(32)\n  const wrap = (address: Hex.Hex) =>\n    checksum ? Address.checksum(address) : address\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32]\n}\n\nexport declare namespace decodeAddress {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeArray(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    staticPosition: number\n  },\n) {\n  const { checksumAddress, length, staticPosition } = options\n\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeArray {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBool(cursor: Cursor.Cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32]\n}\n\nexport declare namespace decodeBool {\n  type ErrorType = Bytes.toBoolean.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBytes(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = Bytes.toNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = Bytes.toNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [Hex.fromBytes(data), 32]\n  }\n\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size), 32))\n  return [value, 32]\n}\n\nexport declare namespace decodeBytes {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.toNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeNumber(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256')\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? Bytes.toBigInt(value, { signed })\n      : Bytes.toNumber(value, { signed }),\n    32,\n  ]\n}\n\nexport declare namespace decodeNumber {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toBigInt.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport type TupleAbiParameter = AbiParameters.Parameter & {\n  components: readonly AbiParameters.Parameter[]\n}\n\n/** @internal */\nexport function decodeTuple(\n  cursor: Cursor.Cursor,\n  param: TupleAbiParameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]!\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]!\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeTuple {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeString(\n  cursor: Cursor.Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = Bytes.toNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = Bytes.toNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = Bytes.toString(Bytes.trimLeft(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nexport declare namespace decodeString {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toString.ErrorType\n    | Bytes.trimLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameters<\n  const parameters extends AbiParameters.AbiParameters,\n>({\n  checksumAddress,\n  parameters,\n  values,\n}: {\n  checksumAddress?: boolean | undefined\n  parameters: parameters\n  values: parameters extends AbiParameters.AbiParameters\n    ? ToPrimitiveTypes<parameters>\n    : never\n}) {\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(\n      prepareParameter({\n        checksumAddress,\n        parameter: parameters[i]!,\n        value: values[i],\n      }),\n    )\n  }\n  return preparedParameters\n}\n\n/** @internal */\nexport declare namespace prepareParameters {\n  type ErrorType = prepareParameter.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameter<\n  const parameter extends AbiParameters.Parameter,\n>({\n  checksumAddress = false,\n  parameter: parameter_,\n  value,\n}: {\n  parameter: parameter\n  value: parameter extends AbiParameters.Parameter\n    ? ParameterToPrimitiveType<parameter>\n    : never\n  checksumAddress?: boolean | undefined\n}): PreparedParameter {\n  const parameter = parameter_ as AbiParameters.Parameter\n\n  const arrayComponents = getArrayComponents(parameter.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: {\n        ...parameter,\n        type,\n      },\n    })\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      checksumAddress,\n      parameter: parameter as TupleAbiParameter,\n    })\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value as unknown as Hex.Hex, {\n      checksum: checksumAddress,\n    })\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value as unknown as boolean)\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    const signed = parameter.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(parameter.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex.Hex, { type: parameter.type })\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type)\n}\n\n/** @internal */\nexport declare namespace prepareParameter {\n  type ErrorType =\n    | encodeArray.ErrorType\n    | encodeTuple.ErrorType\n    | encodeAddress.ErrorType\n    | encodeBoolean.ErrorType\n    | encodeBytes.ErrorType\n    | encodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encode(preparedParameters: PreparedParameter[]): Hex.Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) staticSize += 32\n    else staticSize += Hex.size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParameters: Hex.Hex[] = []\n  const dynamicParameters: Hex.Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) {\n      staticParameters.push(\n        Hex.fromNumber(staticSize + dynamicSize, { size: 32 }),\n      )\n      dynamicParameters.push(encoded)\n      dynamicSize += Hex.size(encoded)\n    } else {\n      staticParameters.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return Hex.concat(...staticParameters, ...dynamicParameters)\n}\n\n/** @internal */\nexport declare namespace encode {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeAddress(\n  value: Hex.Hex,\n  options: { checksum: boolean },\n): PreparedParameter {\n  const { checksum = false } = options\n  Address.assert(value, { strict: checksum })\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase() as Hex.Hex),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeAddress {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | Hex.padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeArray<const parameter extends AbiParameters.Parameter>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, length, parameter } = options\n\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiParameters.ArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${parameter.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i],\n    })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParameters.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters)\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded:\n          preparedParameters.length > 0 ? Hex.concat(length, data) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeArray {\n  type ErrorType =\n    | AbiParameters.InvalidArrayError\n    | AbiParameters.ArrayLengthMismatchError\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBytes(\n  value: Hex.Hex,\n  { type }: { type: string },\n): PreparedParameter {\n  const [, parametersize] = type.split('bytes')\n  const bytesSize = Hex.size(value)\n  if (!parametersize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32)\n    return {\n      dynamic: true,\n      encoded: Hex.concat(\n        Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })),\n        value_,\n      ),\n    }\n  }\n  if (bytesSize !== Number.parseInt(parametersize))\n    throw new AbiParameters.BytesSizeMismatchError({\n      expectedSize: Number.parseInt(parametersize),\n      value,\n    })\n  return { dynamic: false, encoded: Hex.padRight(value) }\n}\n\n/** @internal */\nexport declare namespace encodeBytes {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBoolean(value: boolean): PreparedParameter {\n  if (typeof value !== 'boolean')\n    throw new Errors.BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) }\n}\n\n/** @internal */\nexport declare namespace encodeBoolean {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.fromBoolean.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeNumber(\n  value: number,\n  { signed, size }: { signed: boolean; size: number },\n): PreparedParameter {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new Hex.IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeNumber {\n  type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeString(value: string): PreparedParameter {\n  const hexValue = Hex.fromString(value)\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32)\n  const parts: Hex.Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)))\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(\n      Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })),\n      ...parts,\n    ),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeString {\n  type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.slice.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeTuple<\n  const parameter extends AbiParameters.Parameter & {\n    components: readonly AbiParameters.Parameter[]\n  },\n>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, parameter } = options\n\n  let dynamic = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i]!\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParameters.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encode(preparedParameters)\n      : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeTuple {\n  type ErrorType = Hex.concat.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2]! ? Number(matches[2]!) : null, matches[1]!]\n    : undefined\n}\n\n/** @internal */\nexport function hasDynamicChild(param: AbiParameters.Parameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({\n      ...param,\n      type: arrayComponents[1],\n    } as AbiParameters.Parameter)\n  )\n    return true\n\n  return false\n}\n","import * as abitype from 'abitype'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Solidity from './Solidity.js'\nimport * as internal from './internal/abiParameters.js'\nimport * as Cursor from './internal/cursor.js'\n\n/** Root type for ABI parameters. */\nexport type AbiParameters = readonly abitype.AbiParameter[]\n\n/** A parameter on an {@link ox#AbiParameters.AbiParameters}. */\nexport type Parameter = abitype.AbiParameter\n\n/** A packed ABI type. */\nexport type PackedAbiType =\n  | abitype.SolidityAddress\n  | abitype.SolidityBool\n  | abitype.SolidityBytes\n  | abitype.SolidityInt\n  | abitype.SolidityString\n  | abitype.SolidityArrayWithoutTuple\n\n/**\n * Decodes ABI-encoded data into its respective primitive values based on ABI Parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.decode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000',\n * )\n * // @log: ['wagmi', 420n, true]\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * You can pass **JSON ABI** Parameters:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.decode(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' },\n *   ],\n *   '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000',\n * )\n * // @log: ['wagmi', 420n, true]\n * ```\n *\n * @param parameters - The set of ABI parameters to decode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param data - ABI encoded data.\n * @param options - Decoding options.\n * @returns Array of decoded values.\n */\nexport function decode<\n  const parameters extends AbiParameters,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  parameters: parameters,\n  data: Bytes.Bytes | Hex.Hex,\n  options?: decode.Options<as>,\n): decode.ReturnType<parameters, as>\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(\n  parameters: AbiParameters,\n  data: Bytes.Bytes | Hex.Hex,\n  options: {\n    as?: 'Array' | 'Object' | undefined\n    checksumAddress?: boolean | undefined\n  } = {},\n): readonly unknown[] | Record<string, unknown> {\n  const { as = 'Array', checksumAddress = false } = options\n\n  const bytes = typeof data === 'string' ? Bytes.fromHex(data) : data\n  const cursor = Cursor.create(bytes)\n\n  if (Bytes.size(bytes) === 0 && parameters.length > 0)\n    throw new ZeroDataError()\n  if (Bytes.size(bytes) && Bytes.size(bytes) < 32)\n    throw new DataSizeTooSmallError({\n      data: typeof data === 'string' ? data : Hex.fromBytes(data),\n      parameters: parameters as readonly Parameter[],\n      size: Bytes.size(bytes),\n    })\n\n  let consumed = 0\n  const values: any = as === 'Array' ? [] : {}\n  for (let i = 0; i < parameters.length; ++i) {\n    const param = parameters[i] as Parameter\n    cursor.setPosition(consumed)\n    const [data, consumed_] = internal.decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: 0,\n    })\n    consumed += consumed_\n    if (as === 'Array') values.push(data)\n    else values[param.name ?? i] = data\n  }\n  return values\n}\n\nexport declare namespace decode {\n  type Options<as extends 'Object' | 'Array'> = {\n    /**\n     * Whether the decoded values should be returned as an `Object` or `Array`.\n     *\n     * @default \"Array\"\n     */\n    as?: as | 'Object' | 'Array' | undefined\n    /**\n     * Whether decoded addresses should be checksummed.\n     *\n     * @default false\n     */\n    checksumAddress?: boolean | undefined\n  }\n\n  type ReturnType<\n    parameters extends AbiParameters = AbiParameters,\n    as extends 'Object' | 'Array' = 'Array',\n  > = parameters extends readonly []\n    ? as extends 'Object'\n      ? {}\n      : []\n    : as extends 'Object'\n      ? internal.ToObject<parameters>\n      : internal.ToPrimitiveTypes<parameters>\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | internal.decodeParameter.ErrorType\n    | ZeroDataError\n    | DataSizeTooSmallError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nexport function encode<\n  const parameters extends AbiParameters | readonly unknown[],\n>(\n  parameters: parameters,\n  values: parameters extends AbiParameters\n    ? internal.ToPrimitiveTypes<parameters>\n    : never,\n  options?: encode.Options,\n): Hex.Hex {\n  const { checksumAddress = false } = options ?? {}\n\n  if (parameters.length !== values.length)\n    throw new LengthMismatchError({\n      expectedLength: parameters.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParameters = internal.prepareParameters({\n    checksumAddress,\n    parameters: parameters as readonly Parameter[],\n    values: values as any,\n  })\n  const data = internal.encode(preparedParameters)\n  if (data.length === 0) return '0x'\n  return data\n}\n\nexport declare namespace encode {\n  type ErrorType =\n    | LengthMismatchError\n    | internal.encode.ErrorType\n    | internal.prepareParameters.ErrorType\n    | Errors.GlobalErrorType\n\n  type Options = {\n    /**\n     * Whether addresses should be checked against their checksum.\n     *\n     * @default false\n     */\n    checksumAddress?: boolean | undefined\n  }\n}\n\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nexport function encodePacked<\n  const packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n>(types: packedAbiTypes, values: encodePacked.Values<packedAbiTypes>): Hex.Hex {\n  if (types.length !== values.length)\n    throw new LengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex.Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encodePacked.encode(type, value))\n  }\n  return Hex.concat(...data)\n}\n\nexport namespace encodePacked {\n  export type ErrorType =\n    | Hex.concat.ErrorType\n    | LengthMismatchError\n    | Errors.GlobalErrorType\n\n  export type Values<\n    packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n  > = {\n    [key in keyof packedAbiTypes]: packedAbiTypes[key] extends abitype.AbiType\n      ? abitype.AbiParameterToPrimitiveType<{ type: packedAbiTypes[key] }>\n      : unknown\n  }\n\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  export function encode<const packedAbiType extends PackedAbiType | unknown>(\n    type: packedAbiType,\n    value: Values<[packedAbiType]>[0],\n    isArray = false,\n  ): Hex.Hex {\n    if (type === 'address') {\n      const address = value as Address.Address\n      Address.assert(address)\n      return Hex.padLeft(\n        address.toLowerCase() as Hex.Hex,\n        isArray ? 32 : 0,\n      ) as Address.Address\n    }\n    if (type === 'string') return Hex.fromString(value as string)\n    if (type === 'bytes') return value as Hex.Hex\n    if (type === 'bool')\n      return Hex.padLeft(Hex.fromBoolean(value as boolean), isArray ? 32 : 1)\n\n    const intMatch = (type as string).match(Solidity.integerRegex)\n    if (intMatch) {\n      const [_type, baseType, bits = '256'] = intMatch\n      const size = Number.parseInt(bits) / 8\n      return Hex.fromNumber(value as number, {\n        size: isArray ? 32 : size,\n        signed: baseType === 'int',\n      })\n    }\n\n    const bytesMatch = (type as string).match(Solidity.bytesRegex)\n    if (bytesMatch) {\n      const [_type, size] = bytesMatch\n      if (Number.parseInt(size!) !== ((value as Hex.Hex).length - 2) / 2)\n        throw new BytesSizeMismatchError({\n          expectedSize: Number.parseInt(size!),\n          value: value as Hex.Hex,\n        })\n      return Hex.padRight(value as Hex.Hex, isArray ? 32 : 0) as Hex.Hex\n    }\n\n    const arrayMatch = (type as string).match(Solidity.arrayRegex)\n    if (arrayMatch && Array.isArray(value)) {\n      const [_type, childType] = arrayMatch\n      const data: Hex.Hex[] = []\n      for (let i = 0; i < value.length; i++) {\n        data.push(encode(childType, value[i], true))\n      }\n      if (data.length === 0) return '0x'\n      return Hex.concat(...data)\n    }\n\n    throw new InvalidTypeError(type as string)\n  }\n}\n\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nexport function format<\n  const parameters extends readonly [\n    Parameter | abitype.AbiEventParameter,\n    ...(readonly (Parameter | abitype.AbiEventParameter)[]),\n  ],\n>(\n  parameters:\n    | parameters\n    | readonly [\n        Parameter | abitype.AbiEventParameter,\n        ...(readonly (Parameter | abitype.AbiEventParameter)[]),\n      ],\n): abitype.FormatAbiParameters<parameters> {\n  return abitype.formatAbiParameters(parameters)\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nexport function from<\n  const parameters extends AbiParameters | string | readonly string[],\n>(\n  parameters: parameters | AbiParameters | string | readonly string[],\n): from.ReturnType<parameters> {\n  if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n    return abitype.parseAbiParameters(parameters) as never\n  if (typeof parameters === 'string')\n    return abitype.parseAbiParameters(parameters) as never\n  return parameters as never\n}\n\nexport declare namespace from {\n  type ReturnType<\n    parameters extends AbiParameters | string | readonly string[],\n  > = parameters extends string\n    ? abitype.ParseAbiParameters<parameters>\n    : parameters extends readonly string[]\n      ? abitype.ParseAbiParameters<parameters>\n      : parameters\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                             ↑ ❌ 2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nexport class DataSizeTooSmallError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.DataSizeTooSmallError'\n  constructor({\n    data,\n    parameters,\n    size,\n  }: { data: Hex.Hex; parameters: readonly Parameter[]; size: number }) {\n    super(`Data size of ${size} bytes is too small for given parameters.`, {\n      metaMessages: [\n        `Params: (${abitype.formatAbiParameters(parameters as readonly [Parameter])})`,\n        `Data:   ${data} (${size} bytes)`,\n      ],\n    })\n  }\n}\n\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                           ↑ ❌ zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nexport class ZeroDataError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.ZeroDataError'\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.')\n  }\n}\n\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                               ↑ expected: 3  ↑ ❌ length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                         ↑ ✅ length: 3\n * ```\n */\nexport class ArrayLengthMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.ArrayLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      `Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`,\n    )\n  }\n}\n\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                            ↑ expected: 8 bytes  ↑ ❌ size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                       ↑ ✅ size: 8 bytes\n * ```\n */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.BytesSizeMismatchError'\n  constructor({\n    expectedSize,\n    value,\n  }: { expectedSize: number; value: Hex.Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${Hex.size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n    )\n  }\n}\n\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nexport class LengthMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.LengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding parameters/values length mismatch.',\n        `Expected length (parameters): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nexport class InvalidArrayError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.InvalidArrayError'\n  constructor(value: unknown) {\n    super(`Value \\`${value}\\` is not a valid array.`)\n  }\n}\n\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                             ↑ ❌ invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nexport class InvalidTypeError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.InvalidTypeError'\n  constructor(type: string) {\n    super(`Type \\`${type}\\` is not a valid ABI Type.`)\n  }\n}\n"],"names":[],"mappings":"6KEwfM,SAAU,EAAO,CAAuC,EAE5D,CAFoB,GAEhB,EAAa,CAAC,CAAA,AAClB,IAAK,EADS,EACL,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAmB,MAAM,CAAE,CAAC,EAAE,CAAE,CAAC,AACnD,GAAM,CAD8B,QAC5B,CAAO,CAAE,SAAO,CAAE,CAAG,CAAkB,CAAC,CAAC,CAAE,CAAA,AAC/C,EAAS,GAAc,EAAhB,AAAkB,CAAA,AACxB,GAAc,CADI,CACA,CAAD,CAAC,EAAI,CAAZ,AAAa,EAC9B,CAAC,AAGD,IAJqC,AAI/B,CAJgC,CAAA,AAIF,EAAE,CAAA,AAChC,EAA+B,EAAE,CAAA,AACnC,EAAc,CAAC,CAAA,AACnB,EAHsB,ACtDlB,EDyDC,GADU,CADQ,AAEd,CAAC,CAAG,CAAC,CAAA,EAAM,EAAmB,MAAM,CAAE,CAAC,EAAE,CAAE,CAAC,AACnD,GAAM,ECrDC,ODqDC,CAAO,CAAE,SAAA,CAAS,CAAG,CAAkB,CAAC,EAAG,CAAA,AAC/C,GACF,EAAiB,IADN,AACU,CACnB,AAFU,ACrDA,CAAC,CDuDP,CAAD,CCtDyB,ADsDxB,QAAU,CAAC,EAAa,EAAa,CAAE,CCvDd,GDuDkB,CAAtB,AAAwB,EAAE,CAAZ,AAAc,CAAC,CACvD,CAAA,AACD,EAAkB,IAAI,CAAC,GACvB,GCxD+B,ADwDhB,EAAI,CAAD,CAAC,ECvDG,ADuDC,CCvDD,ADuDE,CAAb,GAEX,EAAiB,CAFc,CAAC,CAAA,CAEX,CAAC,EAE1B,CAAC,AAGD,IALiC,CAAC,CAAA,AAAd,CAKb,EAAI,CAAD,CAAC,IAAM,CAAC,GAAG,KAAqB,EAC5C,CAAC,AChWK,QD+ViC,CC/VvB,CD+VyB,CC5VvC,CHjCgB,CGkChB,CAES,ADyVkD,CF7X9B,AE6X+B,ACxV5D,CDwV4D,ACxVpC,KAElB,CAAA,gBAAA,GAAoB,CAAK,CAAE,CAAG,GAAW,CAAA,CAAE,CAAA,CAAN,EAEvC,EAAW,MAAM,GAAK,EAAO,CHvCV,AAAK,CAAC,CAAA,GGuCU,CAAA,MAC/B,IAAI,EAAoB,GDbb,CF1BwC,CAAC,CAAA,UGwCxC,EAAW,MAAgB,CAC3C,CAD0B,WACb,EAAO,CDbF,CAAC,ECaA,EAAC,OAQlB,EAAO,EDsMT,AC3MuB,AAKjB,KH3CsB,AG2CH,CAAR,CAAC,EDsMR,AAEd,cCxM+C,CAAC,CAAA,CDsMjB,AAG/B,CAAe,CACf,YAAU,QACV,CAAM,CAOP,EACC,IAAM,EAA0C,EAAE,CAAA,AAClD,IAAK,IAAI,CAAC,CAAG,CAAC,CAAE,CADQ,AACP,CAAG,EAAW,MAAM,CAAE,CAAT,AAAU,EAAE,CACxC,AAD0C,CAAC,CAC3C,IAAuB,CAAA,AAiBrB,SAAU,EAEd,iBACA,GAAkB,CAAK,CACvB,SAAS,CADM,AACJ,CAAU,OACrB,CAAK,CAON,MAmVO,EAhVA,EAiVC,GAjVoC,AAgV3B,EAhVqC,IAAI,CAgVpC,AAhVqC,CAAA,CAAN,GAgV1B,CAAC,AAhVH,WF+LY,OE/LM,AAgVG,CAAC,CAAA,CACvC,CAEF,CAAA,CAAA,EAAW,CAAC,AAAE,CAAD,KAAO,CAAC,CAAO,CAAC,CAAC,CAAE,CAAC,CAAC,AAAE,CAAD,GAAK,CAAE,CAAO,CAAC,CAAC,CAAE,CAAC,MACvD,EAnVJ,GAAI,EAAiB,CAAC,AACpB,GAAM,CAAC,EAAQ,EAAK,CAAG,CAAJ,AAAN,CACb,CAFiB,MAEV,AAmHL,MApHoC,CAAA,EAqHxC,AADc,CAC4B,CAC1C,AArHoB,CAyHnB,EAED,GAAM,GARmB,cAQjB,CAAe,QAAE,CAAM,WAAE,CAAS,CAAE,CAAG,EAEzC,EAAqB,GAF2B,CAAA,AAEvB,CAAlB,AAAkB,EAAf,EAEhB,GAAI,CAFkB,AAEjB,KAAK,CAAC,OAAO,CAAC,GAAQ,EAAH,CAAC,GAAQ,IAAI,EAAgC,GACrE,EAD0E,AFxHtE,CEyHA,AADuE,CAAA,AACtE,GAAW,CADkC,CAC5B,AAD6B,CAAiB,EAC/C,CFzHO,EEyHA,GAAK,EAC/B,IADqC,EAC/B,CFtHG,CAAC,EEsHA,EAAuC,CAC/C,cAAc,CAAE,EAChB,IADuB,QACV,EAAM,GAAD,ACxEW,GDwEJ,CACzB,KAAA,CAAA,EAAS,EAAU,IAAI,CAAA,CAAA,EAAI,EAAM,CAAA,CAAG,GAGxC,IAAI,GAAe,CCpEH,CDqEV,EAA0C,EAAE,CAAA,AAClD,CCrEyB,CAAC,EDqErB,IAAI,CAAC,CAAA,EAAM,CAAC,CAAG,EAAM,CCpEL,KAAA,CDoEa,CAAC,CCpEL,EDoES,CAAC,AACtC,IAAM,EAAgB,EAAiB,SAApB,KAAmB,GACpC,YACA,GADe,KAER,CAAA,CAAM,CAAC,CAAC,CAChB,CAAC,CAAA,AACE,EAAc,OAAO,EAAA,CAAA,GAAiB,CAAA,CAAI,CAAA,EAC3B,IAAI,CAAC,EAC1B,CAAC,ACzEA,AD2ED,GAAI,GAAW,EAAc,CAC3B,AAD4B,CAHS,AAG5B,CAH6B,CAAA,CAIhC,CCxFsD,CDwF/C,EAAH,AAAU,CADK,EAEzB,CADmB,EACf,EAAS,CAAC,AACZ,IADS,AACH,EAAS,EAAI,CAAD,AAFkB,CAExB,AAFyB,AAElB,CAFkB,OAER,CAAC,EAAmB,MAAM,CAAE,CAAE,IAAI,CAAE,EAAE,CAAnB,AAAqB,CAAC,CAAA,AACtE,MAAO,CACL,OAAO,CAAE,IAAI,OAEX,CFhHgB,CEgHG,MAAM,CAAG,CAAC,CAAC,AAAE,CAAD,CAAK,CAAD,CAAC,IAAM,CAAC,EAAQ,GAAQ,CAAV,AAAM,CAAC,AAE9D,CAF+D,AAE9D,CAF+D,EAAO,EAGrD,MAAA,UAAkB,EAAM,EAAF,CF/Gb,IE+GsB,CAAE,CAAI,CAAE,AAC3D,CAD2D,AAC1D,AACD,CAFyD,KAElD,CACL,SAAS,EACT,CF/GC,EE8Ga,EF/GA,EEgHP,CAAE,EAAI,CAAD,CAAC,IAAM,CAAC,GAAG,EAAmB,GAAG,CAAC,CAAC,SAAE,CAAO,CAAf,AAAiB,EAAE,CAAG,CAAD,KAjK3C,CAiKmD,CAjK5C,AAiK6C,CAAC,EAjKhD,cACtB,SACA,EACA,IAFe,AACT,KACG,CAAE,CARwC,CAAA,GASjD,GAAG,GACH,EACD,CACF,CAFO,AAEN,AACJ,CADI,AACH,AACD,CALkB,EAKd,AAAmB,OAAO,EAAjB,AAAmB,CAAC,EAAnB,IAAI,CAChB,OAwRE,AAxRK,SA6RT,AALc,CAK4B,CAC1C,AA9RoB,CAiSnB,EAED,GAAM,GAXmB,cAWjB,CAAe,WAAE,CAAS,CAAE,CAAG,EAEnC,GAAU,EAFgC,AAGxC,CAHwC,CAEnC,AACqC,CAD7B,CAAA,AAC+B,CAAA,AAClD,IAAK,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,AADO,CACJ,EAAU,OAAD,GAAW,CAAC,MAAM,CAAE,CAAC,EAAE,CAAE,CAAC,AACrD,IAAM,EAAS,EAAU,EAAb,KAAY,GAAW,CAAC,CAAC,CAAE,CAAA,AACjC,EAAQ,GAAH,EAAQ,CAAC,OAAO,CAAC,GAAS,CAAC,CAAL,AAAM,AAAE,CAAD,AAAN,CAAC,AAAa,CAAZ,GAAW,AAAK,CAAA,AAC9C,EAAgB,EAAiB,mBAErC,SAAS,CAAA,EACT,MAAQ,CAAa,CAAC,EAAA,GAExB,EAAmB,IAAI,CAAA,GACvB,EAAkB,OAAO,CF1ID,EE0IG,GAAU,CF1IF,CE2IrC,CAAC,AACD,MAAO,SACL,EACA,KADO,GACE,EACL,EAAO,GACP,CADM,AFzIE,CE0IR,MAAU,CAAC,ECpJiB,CDoJd,EAAmB,CADR,CAAC,CACU,CAAC,CAAC,SAAE,CAAO,CAAE,EAAE,CAAG,CAAD,GAC1D,AACH,CADG,AACF,CAxTsB,CAsT8C,CAAC,AAtTpB,CAsTqB,EAtTvB,cAC1C,EACA,SAAS,EAAE,CACZ,CAFgB,AAEf,CAAA,AAEJ,GAAuB,GAHsB,MAGb,EAAE,CAA9B,AAA+B,EAArB,IAAI,CAChB,EADW,KA+ET,AA9EK,SA8EK,AACd,CAAc,CACd,CAA8B,CAhFR,CAkFtB,GAAM,KAJqB,KAInB,GAAW,CAAK,CAAE,CAAG,EAE7B,AAFgB,KAAoB,CAAA,CACpC,EAAQ,KAAD,CAAC,AAAM,CAAC,EAAO,CAAE,EAAJ,IAAU,CAAE,CAAQ,CAAE,CAAC,CAAA,AACpC,CACL,GAFsC,IAE/B,EAAE,EACT,GADc,IACP,CAAE,EAAI,CAAD,CAAC,KAAO,CAAC,EAAM,GAAD,QAAY,EAAa,CAAC,CACrD,AACH,CADG,AACF,CAxFwB,EAA6B,CAChD,EAD8C,MACtC,CAAE,EACX,CAAC,CAAA,AAEJ,GAAuB,MAAM,EAAE,AAHF,CAtBX,AAyBd,AAA4B,EAAlB,IAAI,CACT,EADI,GAmMe,EAlML,EAmMvB,CAD0C,EACrB,CAnMC,QAmMQ,EAA1B,OAAO,EACT,GADc,GACR,IAAI,EAAO,IAAD,CAAC,IAAS,CACxB,CAAA,wBAAA,EAA2B,EAAK,GAAA,MAAA,EAAY,OAAO,EAAK,GAAA,gCAAA,CAAqC,CAC9F,CAAA,AACH,MAAO,CAAE,OAAO,CAAE,GAAO,EAAF,KAAS,CAAE,EAAI,CAAD,CAAC,KAAO,CAAC,EAAI,CAAD,CAAC,SAAW,CAAC,GAAO,CAAE,AAvMrB,CAuMiB,AAAI,AAvMpB,AAEnD,CAqMoE,AAvMjB,CAuMkB,AFxRjE,CEmFA,EAAU,IAAI,CAAC,UAAU,CAAC,MAAM,AFnFE,GEmFG,EAAU,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAE,CAAC,AAC1E,IAAM,EAAS,EAAU,EAAb,EAAiB,CAAC,EAAN,QAAgB,CAAC,KAAK,CAAC,CAAA,AACzC,GAAK,EFjFE,AEiFK,CFjFC,IEiFI,CAAA,CAAI,EFjFK,GAAA,SEiFO,CAAC,EFjFE,EAAA,CEiFG,EAAU,CFjFC,EAAN,CEiFS,CAAC,EAAI,EAAA,QACzD,AA8ML,SAAA,CACS,CAAA,CAAA,OAAA,CACL,CAAA,KAAA,CAAM,CAAqC,KAE/B,MFxIM,IEwItB,OAAO,EFxIE,AEwIiB,CAAC,CAAhB,GACP,GAAG,AAAG,CAAE,GAAK,CAAD,KAAO,CAAC,IAAI,AAAK,CAAJ,EAAa,CAAE,AAAZ,CAAa,CAAN,AAAO,AAAC,CAAP,AAAO,CAAN,AAAQ,CAAC,CAAC,CAAG,CAAE,CAAA,AACpD,EAAM,CAAH,CAAY,CFxIV,AEwIW,EAAM,CAAV,AAAO,AAAK,CAAX,AAAY,CAAX,AAAY,AAAC,EAAE,CAAA,GAC/B,CFxIC,CEwIO,GAAH,AAAM,AAAI,EAAQ,EACzB,CADsB,AAAM,KACtB,IAAI,EAAI,CAAD,CAAC,oBAAsB,CAAC,KAC9B,EAAG,CAAA,OAAA,GACR,GAAG,CAAE,EAAI,CAAD,OAAS,EAAE,QACnB,EACA,IAAI,AADE,CACA,EAAO,CAAC,CAAJ,AACV,KAAK,CAAE,EAAM,GAAD,KAAS,EAAE,CACxB,CAAC,AACN,CADM,AACL,AACD,MAAO,CACL,OAAO,EAAE,EACT,GADc,IACP,CAAE,EAAI,CAAD,CAAC,QAAU,CAAC,EAAO,CAC7B,EAD2B,EACvB,CAAE,EAAE,QACR,IAEH,AACH,CADG,AACF,CArOuB,EAAA,QAClB,cACa,EFjFE,CEkFhB,CADkB,AACjB,AACJ,CAFsB,AAClB,AACH,AACD,GAAA,EAAc,IAAI,CAAC,UAAA,CAAW,SAC5B,CADsC,CAAC,KAChC,AAgJL,CFjOI,QEiOM,AACd,CAAc,CACd,MAAE,CAAI,CAAoB,CAFD,CAIzB,GAAM,CAAC,CAAE,EAAc,CAAG,EAAK,EAAD,GAAM,CAAC,EAAf,KAAsB,CAAC,CAAA,AACvC,EAAY,EAAI,CAAD,CAAC,EAAI,CAAX,AAAY,GAC3B,EADgC,CAAC,AAC7B,CAD6B,AAC5B,EAAe,CAClB,AADmB,IACf,EAAS,EAKb,EANgB,AACN,CAAQ,CAAA,GAGd,EAAY,EAAE,EAAK,CAAC,EAAX,CACX,EAAS,ECvFY,CDuFT,CAAC,CCvFQ,KDuFA,CAAC,EAAiD,AAAjD,GAAA,KAAa,IAAA,CAAK,CAAC,EAAM,GAAD,GAAO,CAAG,CAAC,CAAC,CAAG,CAAC,CAAG,EAAE,CAAC,CAAK,CAAC,CAAA,AACrE,CACL,SAAS,EACT,EADa,MACJ,EAAI,CAAD,CAAC,IAAM,CACjB,EAAA,OAAW,CAAC,EAAI,CAAD,CAAC,QAAU,CAAC,EAAW,CAAE,CCxFe,CAAC,CAAA,CDwFZ,CAAE,CAAV,CAAY,CAAE,CAAC,CAAC,CACpD,GAEH,AACH,CADG,AACF,AACD,EAJY,CACP,AAGD,IAAA,OAAqB,QAAQ,CAAC,GAChC,MAAM,IADuC,AACnC,CADoC,CACC,CAC7C,YAAY,CAAE,MAAM,CAAC,QAAQ,CAAC,SAC9B,IAD2C,AAG/C,CAHgD,AACvC,KAEF,CAAE,OAAO,EAAE,EAAO,GAAF,IAAS,CAAE,EAAI,CAAD,CAAC,MAAQ,CAAC,EAAM,CAAE,AACzD,CADyD,AACxD,CA1KsB,AAyK+B,CAAC,CAzKH,CAAE,CFjFvB,CEiFmB,EAAQ,CAAE,EAAU,IAAI,CAAE,CAAC,CAAR,AAAQ,AAE3E,GAAuB,AAAnB,CFjFD,OEiF4B,CAAlB,CAAoB,CAAC,EAApB,IAAI,CACT,KAoOkB,EApOL,EFjFE,AEsTxB,CADwC,GAClC,EAAW,EAAA,UAAc,CAAC,GAC1B,EAAc,AADiB,CAAC,CAAA,EACd,CAAC,IAAI,CAAC,EAAI,CAAD,CAAC,EAAI,CAAC,GAAY,EAAE,CAAC,CAAA,ACnIW,ADoI3D,CADyC,ACnIkB,CDmIjB,AACvB,EAAE,CAAhB,AAAgB,IACtB,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAa,CAAC,EAAE,CAAE,AACpC,CADqC,CAC/B,GAAD,AADwB,CACnB,CAAC,EAAI,CAAD,CAAC,MAAQ,CAAC,EAAI,CAAD,CAAC,GAAK,CAAC,EAAc,EAAE,CAAN,CAAC,CAAO,CAAV,AAAW,CAAC,EAAG,CAAC,CAAC,AAAG,EAAE,CAAC,CAAC,CAAC,CAAA,AAErE,MAAO,CACL,OAAO,EAAE,EACT,EADa,KACN,CAAE,EAAI,CAAD,CAAC,IAAM,CACjB,EAAI,CAAD,CAAC,MAAQ,CAAC,EAAI,CAAD,CAAC,QAAU,CAAC,EAAI,CAAD,CAAC,EAAI,CAAC,GAAW,CAAE,IAAL,AAAS,CAAR,AAAU,EAAE,CAAE,CAAC,CAAC,EAC9D,EAAG,GAEN,AFlUuB,CEmFxB,AA+OC,CAFW,CACT,IA9OG,IAAI,EAA+B,EAAU,GAAX,CAAe,CACzD,AAD0D,CACzD,AADyD,CAvEnC,AAuE6B,EAA3B,CAAC,gBArElB,EF3EI,QE2EO,CAAU,CAAC,CAAC,CAAE,CACzB,KAAK,CAAE,CF3EK,CE2EE,CF3EF,AE2EG,CAAC,WAIf,CACT,CAAC,CCnOuD,GHmJb,gBGjJvC,WAAY,SACJ,EDXA,UCcD,MAAA,MAAA,CAAqB,KACvB,CACT,CAAC,AAqCK,SAAA,EAEJ,CAAqB,CAAE,CAA2C,EAClE,EDvBI,CCuBA,EAAM,GAAD,GAAO,GAAK,CDvBG,CCuBI,MAAM,CAChC,MAAM,GDvBK,CAAA,ECuBmB,CAC5B,cAAc,CAAE,EAAM,GAAD,GAAiB,CACtC,YAAa,EAAO,IAAD,AH3CM,EG2CL,SAGA,CDfV,CCeY,CAAA,IACrB,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAI,EAAoB,GAAD,GAAO,CAAE,CAAC,EAAE,CAAE,CAAC,IAC/C,EAAO,CAAK,CAAR,AAAS,CAAC,CAAC,CAAA,AACf,EAAQ,CAAM,CAAA,CAAT,CAAY,ADfX,CCeW,EAClB,IAAI,CAAC,EAAa,MAAM,CAAC,EAAM,CAAd,CAAY,CACpC,CAAC,AACD,CAF2C,CAAC,CAAC,CAAA,GAEtC,EAAA,MAAU,CAAC,GAAG,EACvB,CDdwB,ACcvB,AAiBiB,CD/BO,ACaE,AAGV,CAHW,CAAA,CAGX,GDuEA,CAAA,CAAA,CAAA,ECxDC,MAAM,CAAtB,EAAsB,OAAN,EACd,CAAmB,CACnB,CD5BQ,AC4BR,CACA,GAAU,CD7ByB,CAAA,CC+BnC,CAFO,EAEM,AAAb,GD9Bc,QC8BU,CAAC,AAAzB,EAGE,OADA,EAAA,MAAc,IACP,EAAI,CAAD,CAAC,KAAO,CAFF,AAGd,EAAQ,GAH8B,CAAA,CAG/B,MAAY,EAAa,CACtB,EAAE,CAAC,CAAC,CAAd,AAAe,CAAC,CACE,CAAA,AAEtB,GAAa,CAHF,CAAC,CAAC,QAGT,EAAmB,OAAO,EAAI,CAAD,CAAC,QAAU,CAAC,GAC7C,EAD4D,CAAC,AAChD,CADgD,AD5B7C,MC6BI,GAAhB,EAAkB,CD7Bb,CC6BD,GD5BG,EC4BkB,ED5Bd,AC6Bf,GAAa,MAAM,GAAf,EACF,EADM,EDnBI,GCoBH,EAAI,CAAD,CAAC,KAAO,CAAC,EAAI,CAAD,CAAC,SAAW,CAAC,GAAmB,EAAH,AAAa,CAAZ,CAAc,CAAC,AAAE,CAAC,AAAF,CAAG,AAAV,CAAU,AAEzE,AAFgE,CAAC,GAE3D,EAAY,EAAgB,CDrBV,ICqBU,CAAM,EAAA,YAAqB,CAAC,CAAA,AAC9D,GAAI,EAAU,CACZ,AADa,CDlBL,AAAQ,CACV,CCkBA,CAAC,EAAO,EDlBC,ACkBS,EDlBM,ACkBC,KAAK,CAAC,CAAG,EAClC,CDnByC,CCmBlC,EAAH,EDlBM,ECkBG,CAAC,QAAQ,CAAC,GAAQ,CAAJ,AAAK,CAAJ,AAAI,AACtC,OAAO,EAAI,CAAD,CAAC,QAAU,CAAC,EAAiB,CACrC,CDlBK,CCiB8B,EAC/B,CAAE,EAAU,EAAE,CAAC,AAAE,CAAD,CAAP,AACb,CADc,CAAC,AAAU,CDjBpB,CAAC,ECkBA,CAAe,QAAb,GAEZ,CAAC,AAED,CDpBE,GCoBI,EAAc,EAAgB,EAAD,GAAM,CAAzB,AAA0B,EAAS,MAAD,CAAC,GAAU,CAAC,CAAA,AAC9D,GAAI,EAAY,CAAC,AACf,GAAM,CAAC,ADNG,ECMI,CADF,CACO,CAAP,AAAU,CAAJ,CAClB,GAAI,KAD4B,CAAA,AACtB,CAAC,IDNU,ICMF,CAAC,KAAW,CAAE,EAAkB,GAAD,GAAO,EAAG,CAAC,CAAC,AAAG,CAAC,CAChE,MAAM,IAAI,EAAuB,CAC/B,KDH2C,CAAA,MCG/B,CAAE,MAAM,CAAC,QAAQ,CAAC,GAC9B,CADmC,CAAC,GAC/B,CAAE,IAEX,CAF2B,MAEpB,EAAI,CAAD,CAAC,MAAQ,CAAC,EAA4B,AAAV,EAAY,CAAC,AAAf,CAAgB,CAAC,CAAC,CAAT,AAAqB,AACpE,CAAC,AADmE,AAGpE,AAHgD,CAAC,GAG3C,EAAc,EAAgB,EAAD,GAAM,CAAzB,AAA0B,EAAS,MAAD,CAAC,GAAU,CAAC,CAAA,AAC9D,GAAI,GAAc,KAAK,CAAC,CAAV,MAAiB,CAAC,GAAQ,CAAC,AACvC,CADmC,CAAC,CDC7B,ACAD,CAAC,EAAO,EAAU,CAAZ,AAAY,EAClB,EDDwB,ACCN,CDDO,CCAR,ADAS,ACCN,CAAA,AAC1B,IAAK,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAM,GAAD,GAAO,CAAE,CAAC,EAAE,CAAE,AACrC,CADsC,CACjC,IAAI,CAAC,EAAO,EAAW,CAAK,CAAjB,AAAkB,CAAC,CAAC,EAAE,CAAZ,GAAgB,CAAC,CAAC,CAAA,IAE9C,AAAoB,CAAC,EAAE,CAAnB,EAAK,CDEC,CCFF,IAAO,CDEL,KCDH,EH5DS,CAAA,AG4DN,KAAO,CAAC,GAAG,IAAI,CAAC,CAAA,GAGtB,CHzDG,GAAA,EGyDkB,EAC7B,CAAC,CAD0C,AAwLF,CAxLG,CAwLI,AAxLJ,IAwLG,CAAC,IAAS,CAyCxB,EAAM,GDuFP,CCvFO,KAAA,AAiCnC,OAAO,KDuHD,KCvHkC,EAAO,IAAD,CAAC,IAAS,CAE5D,EAFoC,UAExB,gBACV,CAAc,aACd,CAAW,MACX,CAAI,CAC0D,CAAA,CAC9D,KAAK,CACH,CAAA,iCAAA,EAAoC,EAAI,EAAA,cAAA,EAAmB,EAAc,YAAA,CAAA,EAAgB,EAAW,GAAA,CAAK,CAC1G,CAAA,AARe,GAOsF,IAPtF,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,EDmIR,0CCzHlB,AA4BK,MAAA,UAAsC,EAAO,IAAD,CAAC,IAAS,CAE1D,YAAY,CDkJH,aAAA,CCjJK,OACZ,CAAK,CACoC,CAAA,ID+IL,EC9I/B,CAAA,CAAA,eAAA,EACe,EAAK,GAAA,KAAA,EAAW,EAAI,CAAD,CAAC,EAAI,CACxC,GACD,EADM,CACN,AHEwD,kCAAA,EGFhB,EAAY,EAAA,CAAI,CAC1D,CAAA,KADsD,sHAEzD,CAAC,CA0BG,AAzBL,MAyBY,UAA4B,EAAO,IAAD,CAAC,EAAf,EAAwB,CAEvD,YAAY,gBACV,CAAc,aACd,CAAW,CACqC,CAAA,CAChD,KAAK,CACH;gCAEmC,cAAc,EAAE;yBACvB,GAC3B,CAAC,CAVY,GAUR,CAAC,EADgC,CATzB,CAS2B,AAC9B,CAAC,CACb,CAAA,UAXe,CAAA,IAAA,CAAA,OAAA,iDAAO,mCAAmC,EAY5D,CAZ4D,AAY3D,CACF,AAkBK,MAAO,UAA0B,EAAO,IAAD,CAAC,IAAS,CAErD,YAAY,CAAc,CAAA,CACxB,KAAK,CAAC,CAAA,QAAA,EAAW,EAAK,GAAA,qBAAA,CAA0B,CAAC,CAAA,AAFjC,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,sBH2Bc,WG3BmB,IAI3D,AAcK,MAAO,UAAyB,EAAA,SAAgB,CAEpD,YAAY,CAAY,CAAA,CACtB,KAAK,CAAC,CAAA,OAAA,EAAA,EAAc,2BAAA,CAA6B,CAAC,CAAA,kBH4BmB,iEG9B9C,kCAGzB,CAHyD,AAGxD,CACF,QHtsBD,EAAiC,CGD1B,ADMA,ADHA,ADFA,CCEyC,AAAQ,CAA/C,AAA+C,CAAN,AAAM,EEH5C,AHCA,AEKA,GCNG,ADMA,CFLC,ACEwC,AAAoB,CAAA,CDA5E,EAAiC,CEGZ,ACNA,AHGd,AGDA,CHDe,AGCiC,CAAA,CAAA,EFC7B,AEDd,AHCA,ICAkB,ACsDd,AFtDA,AGDuC,CAFxB,AAEwB,AHgYjD,CE5X0B,ACND,CDMC,AFLC,CAAA,AGCb,EHCE,IGDI,AHgYV,CEmFD,CFlFb,CAA0B,EAE1B,EAlY+B,CAAA,EEkdmB,CFhF3C,CACmB,UAAxB,OAAO,EEiFE,AAAD,CFjFO,MAAqB,CAAE,KAAM,OAAQ,EEiFE,GFjFI,UAC1D,GAAQ,GAAF,IAAS,EAAI,CAAE,IEiFyB,AFjFrB,CAAE,SAAS,CAAE,IAAI,CAAE,QAAQ,CAAE,CAC3B,QAAQ,EAAnC,OAAO,GEiFC,AFjFO,GAAF,IAAS,EAAiB,CACrC,IAAI,AEiFA,CFjFE,MEiFM,IFhFZ,IAAI,CAAE,SAAS,EAEjB,GAAQ,CEiFG,EFjFL,gBAAuB,CAC3B,GEgFiC,CAAC,CFhF5B,QEiFU,YFhFhB,IAAI,CAAE,SAAS,EAEjB,GAAQ,GAAF,CAAM,EAAI,CAAE,CEiFC,IFjFK,CEiFsB,CAAC,CAAA,GFjFjB,CAAE,IAAI,CAAE,SAAS,CAAE,CAClD,CAAC,MAAM,CAAC,OAAO,CAAgB,AAClC,CADkC,AACjC,AAsFK,SAAU,EAAW,CAAuB,EAChD,EE8Ga,CF9GP,CAAE,CEgHH,CAAA,GADqB,GF/GZ,OAAE,CAAK,CAAE,CAAG,EAC1B,GAD+B,CAAA,GACxB,AAsDH,SAAU,AAAW,CAtDR,AAsD+B,EAChD,EEqII,CFrIE,IADkB,EAChB,CAAI,aAAE,CAAW,CAAE,OAAK,CEqIN,AFrIQ,CAAG,EAC/B,EAAU,AAiNZ,SAAU,EAAW,CAI1B,EACC,GAAM,CAAE,CALgB,KAKZ,aAAE,CAAW,OAAE,CAAK,CAAE,CAAG,EAC/B,EAA0C,CADN,AACO,CADP,AACS,IAAI,CAAE,GAAvC,MAAgD,CAAE,CAAC,CAAA,AAC/D,EAA2B,CAAC,AA0B9B,QA1BsC,CA0B5B,AAAS,CA1BJ,AA6BpB,EACC,GAAM,EAJgB,WAId,CAAW,OAAE,CAAK,CAAE,CAAG,EACzB,EAAkB,CADY,CACR,AADQ,CACT,CAAC,QAAU,CAzclC,AAyciB,AAAkB,SAzcd,AAAX,CAycmC,AAzcxB,EACzB,GAAM,IE0Ec,AF3EI,SAChB,CAAW,OAAE,CAAK,CE4EL,AF5EO,CAAG,EAE3B,EAAS,CAFuB,CAAA,AAErB,CAAA,AACT,CE0ES,CF1EM,AAghBjB,SAAU,EACd,CAGC,CACD,EAAuB,IAAI,GAAK,AAAF,EAE9B,GAAM,CAAE,CAP0B,UAOf,CAAE,CAAY,OAAE,CAAK,CAAE,CAAG,EACvC,EAAQ,CADoC,CAAA,AACvB,CAAhB,IAAqB,CAAC,IAAP,GAAc,CAAC,CAAA,AACnC,EAAc,GAAO,CAAC,CAAC,AAAJ,CAAM,CAAA,AAC/B,EADiB,CACb,EAAQ,GAAG,CAAC,CAAL,QAA4C,EAA5B,CAAC,CAAI,CAAK,CAAC,EAAY,CAAc,AAC9D,OAAO,CADwC,CAKjD,IAAK,CAJW,CAAA,EAIL,KAFX,AAEgB,EAFR,GAAG,CAAC,CAAL,EAEa,CAAK,CAAC,EAAY,EACpC,EAHqB,AAGA,CAHC,AAGC,CAHD,GAEa,OACD,CAAE,EAAM,GAAD,AAArB,CAA0B,OAAE,CAAK,CAAE,CAAE,EAAJ,CACvD,IADkE,CAAC,CAAA,CAC5D,CACT,CAAC,CAliB2C,IAiiB5B,CAAA,QAjiB8B,QAAa,CAAK,CAAE,CAAT,AAAU,CAIjE,AAJiE,CAAH,GAIzD,IAAM,IAAI,CAHf,EAAa,CAGM,IAAI,CAHJ,CAAC,GAEP,CAAC,KAAgB,EAFC,CAAC,CAAA,CAEG,CAAC,AAAX,EAAE,EAAa,CAAC,GAAc,IAAI,EAAE,CAAC,CAAA,CAAT,AAEnD,CAFoD,EAE1C,CAAA,EAAJ,AAAO,EAAI,CAAA,CAAA,CAAI,CAAC,CAAK,CAAC,EAAK,EAAD,AAAK,EAAA,AAAE,CAAC,CACrC,GAAG,CAAC,CAAC,MAAE,CAAI,CAAE,IAAI,CAAE,CAAC,CAAE,EAAE,CAAG,CAAD,EAAI,CAAC,CAAA,CAAA,EAAI,EAAI,CAAE,CAAF,AAAG,CAC1C,IAAI,CAAC,GAAG,CAAC,CAAA,CAAA,CAAG,CAGjB,AAHiB,MEiFa,CF9EvB,CACT,CAAC,CA0bmD,GA3brC,CAAA,OE6FQ,EF8V+B,QAAa,CAAK,CAAE,CAAT,AAAU,CAAC,CAAJ,AAAI,AAC1E,OAAO,EAAK,EAAD,CAAC,MAAS,CAAC,EACxB,CAAC,CAjC4C,WAgCN,CAAC,CAAA,AAhCO,QAAa,CAAK,CAAE,CAAC,AAAV,CAAW,CAAJ,AAAI,AAEnE,IAAK,IAAM,KAAS,AAAJ,CAAS,CAAC,EAAY,EAAI,EAAE,CAAE,CAAC,AAC7C,GAAM,AAD6B,CAC5B,EAAM,EAAF,AAAQ,CA0CjB,AA1CoB,EAAJ,OA0CN,EA1CqB,AA0CT,CAK3B,EACC,GAAI,GANqB,IAMnB,CAAK,MAAE,CAAI,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,EAEnC,GAAI,AAAgB,KAFyB,CAAA,GAEhB,CAApB,CAAC,EAAK,CACb,CADY,KACL,CACL,CAAE,IAAI,CAAE,SAAS,CAAE,CACnB,EAAK,EAAD,CAAC,MAAS,CAAC,EAAW,CAAE,IAAI,CAAE,EAAO,AAAhB,GAAc,QAAa,CAAE,IAAI,IAAE,CAAK,CAAE,CAAC,CAAC,CAAJ,AAClE,CAAA,AAEH,GAAa,OAAO,GAAhB,EAAkB,CAAC,AACrB,CADM,GACA,EAAU,EAAM,GAAT,AAAQ,GAAO,CAAG,CAAC,CAAC,AAAE,CAAD,EAAI,CAAC,AAAE,CAAD,CAAG,CAE3C,AAF2C,OAC3C,EAAQ,CAAA,EAAH,AAAG,EAAK,EAAU,EAAM,GAAT,AAAQ,EAAM,CAAC,CAAC,CAAC,CAAA,CAAE,CAAA,AAChC,CAAC,CAAE,IAAI,CAAE,SAAS,CAAE,CAAE,EAAK,EAAD,CAAC,MAAS,CAAC,EAAO,CAAE,EAAJ,AAAM,CAAE,KAAK,CAAE,CAAC,CAAC,AACpE,CADoE,AACnE,AAED,GAAa,QAAQ,GAAjB,EACF,EADM,IACC,CACL,CAAE,IAAI,CAAE,SAAS,CAAE,CACnB,EAAK,EAAD,CAAC,MAAS,CAAC,EAAM,GAAD,CAAC,MAAU,CAAC,GAAQ,CAAE,CAAL,CAAC,AAAM,CAAE,KAAK,CAAE,CAAC,CACvD,CAAA,AAEH,GAAI,EAAK,EAAD,SAAY,CAAC,GAAG,CAAC,GAAK,EAAK,EAAD,IAAO,CAAG,CAAC,CAAE,CAAC,AAC9C,IAAM,EAAa,EAAK,EAAD,GAAM,CAAb,AAAc,CAAC,CAAE,EAAK,EAAD,SAAY,CAAC,GAAG,CAAC,CAAC,CAAA,AACjD,EAAkB,EAA2C,GAAD,AAAI,CACpE,AAAC,GACC,CADG,AAAI,CACK,CAFI,AACX,KAEH,EACA,CAFS,CACL,EACA,CAAE,QACN,EACA,AAFgB,GACX,EACA,CAAE,EACR,CAAC,CADW,AAEhB,CAAA,AACD,MAAO,CACL,CAAE,IAAI,CAAE,SAAS,CAAE,CACnB,EAAK,EAAD,CAAC,MAAS,CACZ,EACE,EAAe,GADJ,AACO,CADN,AACO,CAAC,CAAC,CAAC,CAAC,EADL,AACO,CAAG,CAAd,AAAa,AAAE,CAAC,CAC9B,EAAe,GAAG,CAAC,CAAC,CAAC,CAAE,CAAC,CAAC,EAAE,CAAG,AAAhB,CAAe,AAAE,CAAC,CACjC,CACF,CACF,AACH,CADG,AACF,AAED,MAAO,CAAC,MAAE,CAAI,CAAE,CAAE,CAAJ,CAAU,AAC1B,CAAC,AADyB,CA1FY,CA0Fb,MAzFnB,EACA,GADK,CACD,CAAE,EAAM,GAAD,CAAK,CAChB,IAAI,CAAE,EAAM,GAAD,CAAK,CAChB,KAAK,CAAE,CAAI,CAAC,EAAM,GAAD,CAAK,CAAC,CACxB,CAAC,CAAA,AACF,EAAa,IAAI,CAAC,GAClB,CADsB,CAAV,AAAW,AACT,CADS,GACL,CAAC,EACrB,CAAC,AAED,EAH0B,CAAX,AAAY,CAAA,GAGpB,EAAqB,EAAc,EAC5C,CAAC,AADqB,CArOO,AAqON,CE7FO,AFvI1B,IAAI,CAoOqB,AAAa,GAAe,CAAC,CAAA,SAnOtD,UAED,CAAC,CAAA,AACF,OAAO,EAAI,EAAA,OAAU,CAAC,EACxB,CAAC,CA9DmB,CAChB,KAAM,EACN,IADY,IEgHI,IF/GH,OE+GqB,QF9GlC,KAAK,CAAE,CACL,GAAG,CAAK,CACR,GE+GK,UF/GS,GAAO,EAAF,UAAc,EAAI,EAAyB,KAGpE,CAH0E,AEkHzE,AF/GA,AA0GK,CA7GqE,QA6G3D,EAGd,CEmJqB,AFnJyB,EAC9C,EAjHiE,CAiH3D,CACJ,AALqB,MAKf,CAAE,CAAO,CEiJuB,AFhJtC,OAAO,CAAE,CAAQ,aACjB,CAAW,CACX,OAAK,CACN,CAAG,EAEE,EAAgB,CAFiB,AAGrC,CAHqC,CE+IlB,AF3InB,IAD4B,CACE,AAE9B,EADA,EAAE,AACI,EAAO,CE0IN,AF1IQ,CAAL,EAAQ,CAAK,CAAE,CAAA,AACzB,CEyI8B,AAC7B,CAAC,CAAA,CF1IG,IAAM,KAAK,AAAI,EAAQ,CAAC,AAC3B,GADwB,AAClB,MAAE,CAAI,MAAE,CAAI,CAAA,CAAK,CACV,IADe,CAAA,IE0IO,CAAC,CAAA,EFzIhC,IAAI,AAAgB,CAAI,CAAC,CE0IG,CF1IE,CE0IK,AF1ID,CAAI,CAAC,EAAgB,CAAC,CAAb,UAAwB,EAAA,CAAE,AAC3E,CAD2E,AAC1E,AACD,OAAO,CACT,CAAC,CAAA,AAEK,CAHO,CAAA,AAIX,AAAK,EAEE,CEsIA,CFzIG,AACN,AACS,EAAM,CAFN,CAAC,CACA,AACI,CEyIf,CF3Ic,CEyID,CFzIG,EAGC,CAAC,EADU,EAAI,EAAyB,GACjC,GAFN,CAAA,AAC8C,CAD5C,AAC6C,CAAA,AAD7C,AAKnB,EAAU,CAAC,GAAG,EAClB,GAAoB,gBAAgB,CAAhC,KEiJO,AACC,CFlJ+B,GAC3C,AAAK,CEkJJ,AFlJS,CEkJR,AFlJS,CGhBkD,CHgBzD,AAAmB,CAChB,CAF6C,AAC3B,CACJ,AAF+B,CAE1B,CEmJf,AFnJgB,CEmJhB,CFnJ4B,CAAE,CADnB,EAAU,CAAA,EACZ,AACtB,CAAC,CADuC,AAAW,AACjD,CADkD,CAAA,AAChD,AAEJ,CAFI,GEgJyC,GF9ItC,EEmJO,EFnJH,CEmJG,AFnJF,CGpBmD,KHoB1C,CAAC,QAAE,MAAM,IAAE,OAAO,OAAE,QAAa,CAAK,CAAE,CAAT,AAAW,CAAC,CAAL,AAAM,CAAE,IAC5C,AAArB,CADsE,CEoJ3C,CFpJ6C,EAAE,KAC3C,AAA3B,OAAO,EAA2B,EAAM,CEoJxB,AFpJJ,CEoJI,MFpJgC,EAAE,CAAA,AAC/C,EAEX,CAAC,AA4CK,SAAU,EAGd,CAA2C,EAC3C,GAJsB,AAIlB,CAAC,AAEH,OAplBE,AAmlBF,MAAM,GAnlBM,AAGd,CAA2C,CC+BtB,CD9BrB,EEwBI,CFxBE,QAAE,CAAM,SAAE,CAAO,aAAE,CAAW,OAAE,CAAK,CAAE,CAC3C,EAEF,EAAqB,CACnB,EACA,KAEA,CC4BC,GD5BI,IAAM,KAAK,AAAI,EAAQ,CAC1B,AAD2B,GACrB,AADkB,CAChB,MAAI,MAAE,CAAI,CAAE,CAAG,EACjB,EAAQ,CAAI,AADU,AC8Bf,CD9Be,AACT,EAAK,CAElB,AAFkB,EAEH,EAAK,EAAD,GAAM,CAAC,EAAA,AAAd,YAAmC,CAAC,CAAA,AACtD,GACE,IACkB,AEyBV,AFzBP,QAAyB,IAA1B,KAAQ,GAAuC,EAAlC,QAAiB,OAAO,CAAU,CAAQ,CAAC,AACxD,CAAC,AACD,CAF0C,EE4BnC,AF1BD,CAAC,CAAE,EAAM,EAAF,AAAQ,CAAG,EE0BA,AF1BJ,AAGpB,EAAI,CAAD,AEuB8B,CFvB7B,QAAU,CAAC,CE2BK,CAAC,AF3BC,CE2BD,AF1BnB,EADkB,KACD,QAAT,CE2BO,CF1Bf,EADY,EACR,CAAE,MAAM,CAAC,QAAQ,CAAC,GAAS,EAAJ,AAAM,CAAC,CAAG,CAAC,EAE1C,CAAC,AAED,GACW,IE0BD,KF1BU,GAAlB,GE2BO,AF1BU,CE2BK,AF5BlB,SACJ,OAAO,GACP,CAAC,EAAQ,KAAD,CAAC,EAAQ,CAAC,GAElB,EAFuB,CAAC,GAElB,IAAI,EAAQ,KAAD,CAAC,aAAmB,CAAC,CACpC,OAAO,CAAE,EACT,GE0BO,GF1BA,IAAI,EE0BO,CAAA,gBF1BkB,EAAE,CAG1C,CEuBgD,GFvB1C,EAAa,EAAK,KAAK,CAAb,AAAc,CEyBD,CAAb,AFzBuB,MAAD,CAAC,GAAU,CAAC,CAAA,AAClD,CEyBC,CAAC,CAAA,AFzBE,EAAY,CAAC,AACf,GAAM,CEyBA,AFzBC,CAAE,EADG,AACE,CAAG,CAAJ,AEyBM,CFxBnB,CEyBG,EFzBC,GAAQ,CEyBE,CF1Ba,AACX,CADW,AACZ,CAAC,EAAI,CAAC,KAAgB,AAAM,CAAL,KAAW,CAAC,QAAQ,CAAC,GACzD,CAD6D,CAAC,IACxD,IAAI,EAAuB,CAC/B,YAAY,CAAE,MADgB,AACV,CAAC,QAAQ,CAAC,GAC9B,CADkC,CAAC,QACxB,EE0Bc,CF1BX,CAAC,EE0BU,AF1BN,CAAA,IAEzB,CAAC,AAED,IAAM,EAAS,CAAK,CG8BJ,AH9BK,EAAK,CACtB,AADsB,IAExB,AA0uBR,EA3uBgB,AGwCA,EHxCE,CAAC,EGsCM,EHqsBhB,AAAkB,CAAY,EAErC,GACW,SAAS,EAHI,CAGtB,GACS,CADL,KACW,GAAf,GACS,CADL,OACa,GAAjB,GACA,CADI,CACC,EAAD,QAAW,CAAC,OAAO,CAAC,EACxB,EAAK,EAAD,QAAW,CAAC,MAAM,CAAC,EACvB,EAAK,EAAD,QAAW,CAAC,KAAK,CAAC,CAEtB,MAAM,IAAI,EAAuB,MAAE,CAAI,CAAE,CAAC,AAC9C,CAAC,AAD0C,AAAG,CApvBpB,EGuCQ,CHtC1B,EAAa,CE0BO,CF1BC,EAmvBO,EAhvBlC,CAAC,CAAA,AAGD,GAAI,EAAM,KE2BG,OF3BS,EAAI,AGsCF,EHtCU,CGsCC,AHtCA,AACjC,CGqCkC,EHrCZ,IE2BI,MF3BtB,KGqC+C,EHrCxC,EAAqB,MAAM,IAAI,EAAmB,MGuCf,EHvCiB,CAAM,CAAE,CAAC,CAAA,AACxE,EADqE,AACxD,CGuCQ,CHxCuC,AACzC,GAAD,SAAa,CE4BD,AF5BG,GAInC,GAAoB,CGsCC,KDXD,UF3BgB,CAAhC,AAAiC,IGsC7B,CHrCF,CE2BD,AF3BM,CE2BL,AF3BM,CGqCsB,CAAA,AHrCV,CAAE,EAAa,CGsC5B,AHtCiC,CGsCjC,ADVQ,AF5B0B,CE4BpC,AAAW,CAAA,AF5BqC,CAAE,CAApC,MAA2C,CAC3D,AADiD,AAAW,CAAA,KACtD,IAAI,EAAwB,aAAE,QAAH,AAAgB,CAAK,CAAE,CAAT,AAAU,AAElE,CAFkE,AAEjE,CAF8D,AAihBpD,IACA,CADK,AAEd,CAFe,AAEd,AAAC,CAFa,CACF,CAAA,EACL,CACN,AADO,OACA,CACT,CAAC,AACH,CAAC,AAOK,EATU,CAAA,GASH,UAA+B,EAAO,IAAD,CAAC,IAAS,CAAxB,AAGlC,YAAY,cACV,CAAY,WACZ,CAAS,CACmC,CAAA,CAC5C,KAAK,CAAC,CAAA,cAAA,EAAiB,EAAY,UAAA,CAAA,EAAc,EAAS,CAAA,CAAG,CAAC,CAAA,AAN9C,GAM0C,IAN1C,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,oCAOzB,CAP2D,AAO1D,CACF,AAGK,MAAO,UAA2B,EAAO,IAAD,CAAC,CAAf,GAAwB,aAG1C,QAAE,CAAM,CAAuB,CAAA,CACzC,KAAK,CAAC,CAAA,gBAAA,EAAmB,EAAK,EAAD,CAAC,MAAS,CAAC,GAAO,EAAA,CAAD,AAAK,CAAJ,AAAM,CACnD,YAAY,CAAE,CAAC,iCAAiC,CAAC,CAClD,CAAC,CAAA,AALc,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,8BAA8B,EAMvD,CAAC,AANsD,CAOxD,AAGK,MAAO,UAAgC,EAAO,IAAD,CAAC,IAAS,CAG3D,CAHmC,CGrB/B,UHwBQ,aACV,CAAW,OACX,CAAK,CAC+D,CAAA,CACpE,EG5BwC,CAAC,EH4BpC,CACH,CAAA,uBAAA,EAA0B,EAAW,SAAA,WAAA,EAAuB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,IAAO,CAAF,CAAC,CAAC,CAAK,CACnG,CACE,aAAc,CAAC,CG5BC,kDH4BkD,GATtD,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,mCAAmC,EAY5D,CAAC,CAIG,MAAO,UAA+B,EAAO,IAAD,CAAC,IAAS,CAAxB,AAGlC,YAAY,MAAE,CAAI,CAAoB,CAAA,CACpC,KAAK,CAAC,CAAA,aAAA,EAAgB,EAAI,EAAA,WAAA,CAAe,CAAE,CACzC,YAAY,CAAE,CAAC,0CAA0C,CAAC,CAC3D,CAAC,CAAA,AALc,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,kCAAkC,EAM3D,CAN2D,AAM1D,CACF","ignoreList":[0,1,2,3]}