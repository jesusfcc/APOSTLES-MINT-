{"version":3,"sources":["../../../../node_modules/viem/utils/promise/withTimeout.ts","../../../../node_modules/thirdweb/src/wallets/ecosystem/get-ecosystem-wallet-auth-options.ts","../../../../node_modules/thirdweb/src/wallets/in-app/core/wallet/in-app-core.ts","../../../../node_modules/thirdweb/src/wallets/utils/normalizeChainId.ts","../../../../node_modules/thirdweb/src/utils/signatures/helpers/parse-typed-data.ts","../../../../node_modules/thirdweb/src/utils/platform.ts","../../../../node_modules/thirdweb/src/wallets/utils/defaultDappMetadata.ts","../../../../node_modules/viem/errors/typedData.ts","../../../../node_modules/viem/utils/signature/hashTypedData.ts","../../../../node_modules/viem/utils/typedData.ts","../../../../node_modules/ox/core/Rlp.ts","../../../../node_modules/ox/core/internal/cursor.ts","../../../../node_modules/ox/core/Signature.ts","../../../../node_modules/ox/core/Authorization.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\n\nexport type WithTimeoutErrorType = ErrorType\n\nexport function withTimeout<data>(\n  fn: ({\n    signal,\n  }: {\n    signal: AbortController['signal'] | null\n  }) => Promise<data>,\n  {\n    errorInstance = new Error('timed out'),\n    timeout,\n    signal,\n  }: {\n    // The error instance to throw when the timeout is reached.\n    errorInstance?: Error | undefined\n    // The timeout (in ms).\n    timeout: number\n    // Whether or not the timeout should use an abort signal.\n    signal?: boolean | undefined\n  },\n): Promise<data> {\n  return new Promise((resolve, reject) => {\n    ;(async () => {\n      let timeoutId!: NodeJS.Timeout\n      try {\n        const controller = new AbortController()\n        if (timeout > 0) {\n          timeoutId = setTimeout(() => {\n            if (signal) {\n              controller.abort()\n            } else {\n              reject(errorInstance)\n            }\n          }, timeout) as NodeJS.Timeout // need to cast because bun globals.d.ts overrides @types/node\n        }\n        resolve(await fn({ signal: controller?.signal || null }))\n      } catch (err) {\n        if ((err as Error)?.name === 'AbortError') reject(errorInstance)\n        reject(err)\n      } finally {\n        clearTimeout(timeoutId)\n      }\n    })()\n  })\n}\n","import { getThirdwebBaseUrl } from \"../../utils/domains.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport type { AuthOption } from \"../types.js\";\nimport type { EcosystemWalletId } from \"../wallet-types.js\";\n\ntype EcosystemOptions = {\n  name: string;\n  imageUrl?: string;\n  slug: string;\n  homepage?: string;\n  authOptions: AuthOption[];\n  smartAccountOptions: SmartAccountOptions;\n};\n\ntype SmartAccountOptions = {\n  defaultChainId: number;\n  sponsorGas: boolean;\n  accountFactoryAddress?: string;\n  executionMode?: \"EIP4337\" | \"EIP7702\";\n};\n\n/**\n * Retrieves the specified auth options for a given ecosystem wallet, if any.\n * @param walletId The ecosystem wallet ID.\n * @returns {AuthOption[] | undefined} The auth options for the ecosystem wallet.\n * @internal\n */\nexport async function getEcosystemInfo(\n  walletId: EcosystemWalletId,\n): Promise<EcosystemOptions> {\n  return withCache(\n    async () => {\n      const res = await fetch(\n        `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2024-05-05/ecosystem-wallet`,\n        {\n          headers: {\n            \"x-ecosystem-id\": walletId,\n          },\n        },\n      );\n\n      const data = await res.json();\n\n      if (!data || data.code === \"UNAUTHORIZED\") {\n        throw new Error(\n          data.message ||\n            `Could not find ecosystem wallet with id ${walletId}, please check your ecosystem wallet configuration.`,\n        );\n      }\n\n      // siwe is the auth option in the backend, but we want to use wallet as the auth option in the frontend\n      if (data.authOptions?.includes(\"siwe\")) {\n        data.authOptions = data.authOptions.filter((o: string) => o !== \"siwe\");\n        data.authOptions.push(\"wallet\");\n      }\n\n      return data;\n    },\n    {\n      cacheKey: `ecosystem-wallet-options-${walletId}`,\n      cacheTime: 1000 * 60 * 5, // 5 mins\n    },\n  );\n}\n","import { trackConnect } from \"../../../../analytics/track/connect.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport {\n  getCachedChain,\n  getCachedChainIfExists,\n} from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { getEcosystemInfo } from \"../../../ecosystem/get-ecosystem-wallet-auth-options.js\";\nimport type { Account, Wallet } from \"../../../interfaces/wallet.js\";\nimport { createWalletEmitter } from \"../../../wallet-emitter.js\";\nimport type {\n  CreateWalletArgs,\n  EcosystemWalletId,\n} from \"../../../wallet-types.js\";\nimport type { InAppConnector } from \"../interfaces/connector.js\";\nimport type { Ecosystem } from \"./types.js\";\n\nconst connectorCache = new Map<string, InAppConnector>();\n\n/**\n * @internal\n */\nexport async function getOrCreateInAppWalletConnector(\n  client: ThirdwebClient,\n  connectorFactory: (client: ThirdwebClient) => Promise<InAppConnector>,\n  ecosystem?: Ecosystem,\n) {\n  const key = stringify({\n    clientId: client.clientId,\n    ecosystem,\n    partialSecretKey: client.secretKey?.slice(0, 5),\n  });\n  if (connectorCache.has(key)) {\n    return connectorCache.get(key) as InAppConnector;\n  }\n  const connector = await connectorFactory(client);\n  connectorCache.set(key, connector);\n  return connector;\n}\n\n/**\n * @internal\n */\nexport function createInAppWallet(args: {\n  createOptions?: CreateWalletArgs<\"inApp\">[1];\n  connectorFactory: (client: ThirdwebClient) => Promise<InAppConnector>;\n  ecosystem?: Ecosystem;\n}): Wallet<\"inApp\" | EcosystemWalletId> {\n  const { createOptions: _createOptions, connectorFactory, ecosystem } = args;\n  const walletId = ecosystem ? ecosystem.id : \"inApp\";\n  const emitter = createWalletEmitter<\"inApp\">();\n  let createOptions = _createOptions;\n  let account: Account | undefined;\n  let adminAccount: Account | undefined; // Admin account if smartAccountOptions were provided with connection\n  let chain: Chain | undefined;\n  let client: ThirdwebClient | undefined;\n  let authToken: string | null = null;\n\n  const resolveSmartAccountOptionsFromEcosystem = async (options?: {\n    chain?: Chain;\n  }) => {\n    if (ecosystem) {\n      const ecosystemOptions = await getEcosystemInfo(ecosystem.id);\n      const smartAccountOptions = ecosystemOptions?.smartAccountOptions;\n      if (smartAccountOptions) {\n        const executionMode =\n          ecosystemOptions.smartAccountOptions.executionMode;\n        if (executionMode === \"EIP7702\") {\n          createOptions = {\n            ...createOptions,\n            executionMode: {\n              mode: \"EIP7702\",\n              sponsorGas: smartAccountOptions.sponsorGas,\n            },\n          };\n        } else {\n          // default to 4337\n          const { defaultChainId } = ecosystemOptions.smartAccountOptions;\n          const preferredChain =\n            options?.chain ??\n            (defaultChainId ? getCachedChain(defaultChainId) : undefined);\n          if (!preferredChain) {\n            throw new Error(\n              `A chain must be provided either via 'chain' in connect options or 'defaultChainId' in ecosystem configuration. Please pass it via connect() or update the ecosystem configuration.`,\n            );\n          }\n          createOptions = {\n            ...createOptions,\n            smartAccount: {\n              chain: preferredChain,\n              factoryAddress: smartAccountOptions.accountFactoryAddress,\n              sponsorGas: smartAccountOptions.sponsorGas,\n            },\n          };\n        }\n      }\n    }\n  };\n\n  return {\n    autoConnect: async (options) => {\n      const { autoConnectInAppWallet } = await import(\"./index.js\");\n\n      const connector = await getOrCreateInAppWalletConnector(\n        options.client,\n        connectorFactory,\n        ecosystem,\n      );\n\n      await resolveSmartAccountOptionsFromEcosystem();\n\n      const {\n        account: connectedAccount,\n        chain: connectedChain,\n        adminAccount: _adminAccount,\n      } = await autoConnectInAppWallet(options, createOptions, connector);\n\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      adminAccount = _adminAccount;\n      chain = connectedChain;\n      try {\n        authToken = await connector.storage.getAuthCookie();\n      } catch (error) {\n        console.error(\"Failed to retrieve auth token:\", error);\n        authToken = null;\n      }\n      trackConnect({\n        chainId: chain.id,\n        client: options.client,\n        ecosystem,\n        walletAddress: account.address,\n        walletType: walletId,\n      });\n      // return only the account\n      return account;\n    },\n    connect: async (options) => {\n      const { connectInAppWallet } = await import(\"./index.js\");\n      const connector = await getOrCreateInAppWalletConnector(\n        options.client,\n        connectorFactory,\n        ecosystem,\n      );\n\n      await resolveSmartAccountOptionsFromEcosystem();\n\n      const {\n        account: connectedAccount,\n        chain: connectedChain,\n        adminAccount: _adminAccount,\n      } = await connectInAppWallet(options, createOptions, connector);\n\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      adminAccount = _adminAccount;\n      chain = connectedChain;\n      try {\n        authToken = await connector.storage.getAuthCookie();\n      } catch (error) {\n        console.error(\"Failed to retrieve auth token:\", error);\n        authToken = null;\n      }\n      trackConnect({\n        chainId: chain.id,\n        client: options.client,\n        ecosystem,\n        walletAddress: account.address,\n        walletType: walletId,\n      });\n      // return only the account\n      return account;\n    },\n    disconnect: async () => {\n      // If no client is assigned, we should be fine just unsetting the states\n      if (client) {\n        const connector = await getOrCreateInAppWalletConnector(\n          client,\n          connectorFactory,\n          ecosystem,\n        );\n        const result = await connector.logout();\n        if (!result.success) {\n          throw new Error(\"Failed to logout\");\n        }\n      }\n      account = undefined;\n      adminAccount = undefined;\n      chain = undefined;\n      authToken = null;\n      emitter.emit(\"disconnect\", undefined);\n    },\n    getAccount: () => account,\n    getAdminAccount: () => adminAccount,\n    getAuthToken: () => authToken,\n    getChain() {\n      if (!chain) {\n        return undefined;\n      }\n\n      chain = getCachedChainIfExists(chain.id) || chain;\n      return chain;\n    },\n    getConfig: () => createOptions,\n    id: walletId,\n    subscribe: emitter.subscribe,\n    switchChain: async (newChain) => {\n      if (\n        (createOptions?.smartAccount ||\n          createOptions?.executionMode?.mode === \"EIP4337\") &&\n        client &&\n        account\n      ) {\n        // if account abstraction is enabled, reconnect to smart account on the new chain\n        const { autoConnectInAppWallet } = await import(\"./index.js\");\n        const connector = await getOrCreateInAppWalletConnector(\n          client,\n          connectorFactory,\n          ecosystem,\n        );\n\n        await resolveSmartAccountOptionsFromEcosystem({ chain: newChain });\n\n        const {\n          account: connectedAccount,\n          chain: connectedChain,\n          adminAccount: _adminAccount,\n        } = await autoConnectInAppWallet(\n          {\n            chain: newChain,\n            client,\n          },\n          createOptions,\n          connector,\n        );\n        adminAccount = _adminAccount;\n        account = connectedAccount;\n        chain = connectedChain;\n      } else {\n        // if not, simply set the new chain\n        chain = newChain;\n      }\n      emitter.emit(\"chainChanged\", newChain);\n    },\n  };\n}\n","import { hexToNumber, isHex } from \"../../utils/encoding/hex.js\";\n\n/**\n * @internal\n */\nexport function normalizeChainId(chainId: string | number | bigint): number {\n  if (typeof chainId === \"number\") {\n    return chainId;\n  }\n  if (isHex(chainId)) {\n    return hexToNumber(chainId);\n  }\n  if (typeof chainId === \"bigint\") {\n    return Number(chainId);\n  }\n  return Number.parseInt(chainId, 10);\n}\n","import * as ox__Hex from \"ox/Hex\";\nimport type * as ox__TypedData from \"ox/TypedData\";\nimport type { Hex } from \"../../encoding/hex.js\";\n\ntype UnknownDomain = unknown & { chainId?: unknown };\ntype HexDomain = unknown & { chainId: Hex };\n\n/**\n * @internal\n */\nexport function parseTypedData<\n  typedData extends\n    | ox__TypedData.TypedData\n    | Record<string, unknown> = ox__TypedData.TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>(\n  typedData: ox__TypedData.Definition<typedData, primaryType>,\n): ox__TypedData.Definition<typedData, primaryType> {\n  const domain = typedData.domain as UnknownDomain;\n  if (domain?.chainId !== undefined && ox__Hex.validate(domain.chainId)) {\n    typedData.domain = {\n      ...(typedData.domain as HexDomain),\n      chainId: ox__Hex.toNumber(\n        (typedData.domain as unknown as HexDomain).chainId,\n      ),\n    } as unknown as ox__TypedData.Definition<typedData, primaryType>[\"domain\"];\n  }\n  return typedData;\n}\n","function isReactNative(): boolean {\n  return (\n    typeof document === \"undefined\" &&\n    typeof navigator !== \"undefined\" &&\n    navigator.product === \"ReactNative\"\n  );\n}\n\nfunction isNode(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\"\n  );\n}\n\nexport function isBrowser(): boolean {\n  return !isReactNative() && !isNode();\n}\n","import { isBrowser } from \"../../utils/platform.js\";\nimport type { AppMetadata } from \"../types.js\";\n\n/**\n * @internal\n */\nexport function getDefaultAppMetadata(): Required<AppMetadata> {\n  if (!isBrowser()) {\n    return {\n      description: \"thirdweb powered dApp\",\n      logoUrl: \"https://thirdweb.com/favicon.ico\",\n      name: \"thirdweb powered dApp\",\n      url: \"https://thirdweb.com\",\n    };\n  }\n\n  const { protocol, hostname, port } = window.location;\n  let baseUrl = `${protocol}//${hostname}`;\n\n  // Add the port if it's not the default HTTP or HTTPS port\n  if (port && port !== \"80\" && port !== \"443\") {\n    baseUrl += `:${port}`;\n  }\n\n  const logoUrl = `${baseUrl}/favicon.ico`;\n\n  return {\n    description: window.document.title || \"thirdweb powered dApp\",\n    logoUrl,\n    name: window.document.title || \"thirdweb powered dApp\",\n    url: baseUrl,\n  };\n}\n","import type { TypedData } from 'abitype'\n\nimport { stringify } from '../utils/stringify.js'\nimport { BaseError } from './base.js'\n\nexport type InvalidDomainErrorType = InvalidDomainError & {\n  name: 'InvalidDomainError'\n}\nexport class InvalidDomainError extends BaseError {\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\nexport type InvalidPrimaryTypeErrorType = InvalidPrimaryTypeError & {\n  name: 'InvalidPrimaryTypeError'\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\nexport type InvalidStructTypeErrorType = InvalidStructTypeError & {\n  name: 'InvalidStructTypeError'\n}\nexport class InvalidStructTypeError extends BaseError {\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n      name: 'InvalidStructTypeError',\n    })\n  }\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  getTypesForEIP712Domain,\n  type ValidateTypedDataErrorType,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\nexport type HashStructErrorType =\n  | EncodeDataErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport {\n  InvalidDomainError,\n  InvalidPrimaryTypeError,\n  InvalidStructTypeError,\n} from '../errors/typedData.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\nimport { stringify } from './stringify.js'\n\nexport type SerializeTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function serializeTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = parameters as unknown as TypedDataDefinition\n\n  const normalizeData = (\n    struct: readonly TypedDataParameter[],\n    data_: Record<string, unknown>,\n  ) => {\n    const data = { ...data_ }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!types.EIP712Domain) return {}\n    if (!domain_) return {}\n    return normalizeData(types.EIP712Domain, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return stringify({ domain, message, primaryType, types })\n}\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_, 10) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_, 10))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_, 10),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: {\n  domain?: TypedDataDomain | undefined\n}): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    (typeof domain?.chainId === 'number' ||\n      typeof domain?.chainId === 'bigint') && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n","import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Cursor from './internal/cursor.js'\nimport type { ExactPartial, RecursiveArray } from './internal/types.js'\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nexport function toBytes(\n  value: Bytes.Bytes | Hex.Hex,\n): RecursiveArray<Bytes.Bytes> {\n  return to(value, 'Bytes')\n}\n\nexport declare namespace toBytes {\n  type ErrorType = to.ErrorType\n}\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value: Bytes.Bytes | Hex.Hex): RecursiveArray<Hex.Hex> {\n  return to(value, 'Hex')\n}\n\nexport declare namespace toHex {\n  type ErrorType = to.ErrorType\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport function to<\n  value extends Bytes.Bytes | Hex.Hex,\n  to extends 'Hex' | 'Bytes',\n>(value: value, to: to | 'Hex' | 'Bytes'): to.ReturnType<to> {\n  const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes')\n\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0)\n        throw new Hex.InvalidLengthError(value)\n      return Bytes.fromHex(value)\n    }\n    return value as Bytes.Bytes\n  })()\n\n  const cursor = Cursor.create(bytes, {\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n  })\n  const result = decodeRlpCursor(cursor, to_)\n\n  return result as to.ReturnType<to>\n}\n\n/** @internal */\nexport declare namespace to {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (to extends 'Bytes' ? RecursiveArray<Bytes.Bytes> : never)\n    | (to extends 'Hex' ? RecursiveArray<Hex.Hex> : never)\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | decodeRlpCursor.ErrorType\n    | Cursor.create.ErrorType\n    | Hex.InvalidLengthError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\n\n/** @internal */\nexport function decodeRlpCursor<to extends 'Hex' | 'Bytes' = 'Hex'>(\n  cursor: Cursor.Cursor,\n  to: to | 'Hex' | 'Bytes' | undefined = 'Hex',\n): decodeRlpCursor.ReturnType<to> {\n  if (cursor.bytes.length === 0)\n    return (\n      to === 'Hex' ? Hex.fromBytes(cursor.bytes) : cursor.bytes\n    ) as decodeRlpCursor.ReturnType<to>\n\n  const prefix = cursor.readByte()\n  if (prefix < 0x80) cursor.decrementPosition(1)\n\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80)\n    const bytes = cursor.readBytes(length)\n    return (\n      to === 'Hex' ? Hex.fromBytes(bytes) : bytes\n    ) as decodeRlpCursor.ReturnType<to>\n  }\n\n  // list\n  const length = readLength(cursor, prefix, 0xc0)\n  return readList(cursor, length, to) as {} as decodeRlpCursor.ReturnType<to>\n}\n\n/** @internal */\nexport declare namespace decodeRlpCursor {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex'> = to.ReturnType<to>\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | readLength.ErrorType\n    | readList.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function readLength(\n  cursor: Cursor.Cursor,\n  prefix: number,\n  offset: number,\n) {\n  if (offset === 0x80 && prefix < 0x80) return 1\n  if (prefix <= offset + 55) return prefix - offset\n  if (prefix === offset + 55 + 1) return cursor.readUint8()\n  if (prefix === offset + 55 + 2) return cursor.readUint16()\n  if (prefix === offset + 55 + 3) return cursor.readUint24()\n  if (prefix === offset + 55 + 4) return cursor.readUint32()\n  throw new Errors.BaseError('Invalid RLP prefix')\n}\n\n/** @internal */\nexport declare namespace readLength {\n  type ErrorType = Errors.BaseError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function readList<to extends 'Hex' | 'Bytes'>(\n  cursor: Cursor.Cursor,\n  length: number,\n  to: to | 'Hex' | 'Bytes',\n) {\n  const position = cursor.position\n  const value: decodeRlpCursor.ReturnType<to>[] = []\n  while (cursor.position - position < length)\n    value.push(decodeRlpCursor(cursor, to))\n  return value\n}\n\n/** @internal */\nexport declare namespace readList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor.Cursor): void\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function from<as extends 'Hex' | 'Bytes'>(\n  value: RecursiveArray<Bytes.Bytes> | RecursiveArray<Hex.Hex>,\n  options: from.Options<as>,\n): from.ReturnType<as> {\n  const { as } = options\n\n  const encodable = getEncodable(value)\n  const cursor = Cursor.create(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (as === 'Hex') return Hex.fromBytes(cursor.bytes) as from.ReturnType<as>\n  return cursor.bytes as from.ReturnType<as>\n}\n\nexport declare namespace from {\n  type Options<as extends 'Hex' | 'Bytes'> = {\n    /** The type to convert the RLP value to. */\n    as: as | 'Hex' | 'Bytes'\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Cursor.create.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromBytes<as extends 'Hex' | 'Bytes' = 'Bytes'>(\n  bytes: RecursiveArray<Bytes.Bytes>,\n  options: fromBytes.Options<as> = {},\n): fromBytes.ReturnType<as> {\n  const { as = 'Bytes' } = options\n  return from(bytes, { as }) as never\n}\n\nexport declare namespace fromBytes {\n  type Options<as extends 'Hex' | 'Bytes' = 'Bytes'> = ExactPartial<\n    from.Options<as>\n  >\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Bytes'> = from.ReturnType<as>\n\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromHex<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  hex: RecursiveArray<Hex.Hex>,\n  options: fromHex.Options<as> = {},\n): fromHex.ReturnType<as> {\n  const { as = 'Hex' } = options\n  return from(hex, { as }) as never\n}\n\nexport declare namespace fromHex {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = ExactPartial<\n    from.Options<as>\n  >\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = from.ReturnType<as>\n\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n\nfunction getEncodable(\n  bytes: RecursiveArray<Bytes.Bytes> | RecursiveArray<Hex.Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor.Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: Bytes.Bytes | Hex.Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? Bytes.fromHex(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0]! < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor.Cursor) {\n      if (bytes.length === 1 && bytes[0]! < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new Errors.BaseError('Length is too large.')\n}\n","import type { Bytes } from '../Bytes.js'\nimport * as Errors from '../Errors.js'\n\n/** @internal */\nexport type Cursor = {\n  bytes: Bytes\n  dataView: DataView\n  position: number\n  positionReadCount: Map<number, number>\n  recursiveReadCount: number\n  recursiveReadLimit: number\n  remaining: number\n  assertReadLimit(position?: number): void\n  assertPosition(position: number): void\n  decrementPosition(offset: number): void\n  getReadCount(position?: number): number\n  incrementPosition(offset: number): void\n  inspectByte(position?: number): Bytes[number]\n  inspectBytes(length: number, position?: number): Bytes\n  inspectUint8(position?: number): number\n  inspectUint16(position?: number): number\n  inspectUint24(position?: number): number\n  inspectUint32(position?: number): number\n  pushByte(byte: Bytes[number]): void\n  pushBytes(bytes: Bytes): void\n  pushUint8(value: number): void\n  pushUint16(value: number): void\n  pushUint24(value: number): void\n  pushUint32(value: number): void\n  readByte(): Bytes[number]\n  readBytes(length: number, size?: number): Bytes\n  readUint8(): number\n  readUint16(): number\n  readUint24(): number\n  readUint32(): number\n  setPosition(position: number): () => void\n  _touch(): void\n}\n\nconst staticCursor: Cursor = /*#__PURE__*/ {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit)\n      throw new RecursiveReadLimitExceededError({\n        count: this.recursiveReadCount + 1,\n        limit: this.recursiveReadLimit,\n      })\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1)\n      throw new PositionOutOfBoundsError({\n        length: this.bytes.length,\n        position,\n      })\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position - offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position + offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]!\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + length - 1)\n    return this.bytes.subarray(position, position + length)\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]!\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 1)\n    return this.dataView.getUint16(position)\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 2)\n    return (\n      (this.dataView.getUint16(position) << 8) +\n      this.dataView.getUint8(position + 2)\n    )\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 3)\n    return this.dataView.getUint32(position)\n  },\n  pushByte(byte: Bytes[number]) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = byte\n    this.position++\n  },\n  pushBytes(bytes: Bytes) {\n    this.assertPosition(this.position + bytes.length - 1)\n    this.bytes.set(bytes, this.position)\n    this.position += bytes.length\n  },\n  pushUint8(value: number) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = value\n    this.position++\n  },\n  pushUint16(value: number) {\n    this.assertPosition(this.position + 1)\n    this.dataView.setUint16(this.position, value)\n    this.position += 2\n  },\n  pushUint24(value: number) {\n    this.assertPosition(this.position + 2)\n    this.dataView.setUint16(this.position, value >> 8)\n    this.dataView.setUint8(this.position + 2, value & ~4294967040)\n    this.position += 3\n  },\n  pushUint32(value: number) {\n    this.assertPosition(this.position + 3)\n    this.dataView.setUint32(this.position, value)\n    this.position += 4\n  },\n  readByte() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectByte()\n    this.position++\n    return value\n  },\n  readBytes(length, size) {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectBytes(length)\n    this.position += size ?? length\n    return value\n  },\n  readUint8() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint8()\n    this.position += 1\n    return value\n  },\n  readUint16() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint16()\n    this.position += 2\n    return value\n  },\n  readUint24() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint24()\n    this.position += 3\n    return value\n  },\n  readUint32() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint32()\n    this.position += 4\n    return value\n  },\n  get remaining() {\n    return this.bytes.length - this.position\n  },\n  setPosition(position) {\n    const oldPosition = this.position\n    this.assertPosition(position)\n    this.position = position\n    return () => (this.position = oldPosition)\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return\n    const count = this.getReadCount()\n    this.positionReadCount.set(this.position, count + 1)\n    if (count > 0) this.recursiveReadCount++\n  },\n}\n\n/** @internal */\nexport function create(\n  bytes: Bytes,\n  { recursiveReadLimit = 8_192 }: create.Config = {},\n): Cursor {\n  const cursor: Cursor = Object.create(staticCursor)\n  cursor.bytes = bytes\n  cursor.dataView = new DataView(\n    bytes.buffer,\n    bytes.byteOffset,\n    bytes.byteLength,\n  )\n  cursor.positionReadCount = new Map()\n  cursor.recursiveReadLimit = recursiveReadLimit\n  return cursor\n}\n\n/** @internal */\nexport declare namespace create {\n  type Config = { recursiveReadLimit?: number | undefined }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport class NegativeOffsetError extends Errors.BaseError {\n  override readonly name = 'Cursor.NegativeOffsetError'\n\n  constructor({ offset }: { offset: number }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`)\n  }\n}\n\n/** @internal */\nexport class PositionOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Cursor.PositionOutOfBoundsError'\n\n  constructor({ length, position }: { length: number; position: number }) {\n    super(\n      `Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`,\n    )\n  }\n}\n\n/** @internal */\nexport class RecursiveReadLimitExceededError extends Errors.BaseError {\n  override readonly name = 'Cursor.RecursiveReadLimitExceededError'\n\n  constructor({ count, limit }: { count: number; limit: number }) {\n    super(\n      `Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`,\n    )\n  }\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\nimport type { Compute, ExactPartial, OneOf } from './internal/types.js'\n\n/** Root type for an ECDSA signature. */\nexport type Signature<\n  recovered extends boolean = true,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  recovered extends true\n    ? {\n        r: bigintType\n        s: bigintType\n        yParity: numberType\n      }\n    : {\n        r: bigintType\n        s: bigintType\n        yParity?: numberType | undefined\n      }\n>\n\n/** RPC-formatted ECDSA signature. */\nexport type Rpc<recovered extends boolean = true> = Signature<\n  recovered,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/** (Legacy) ECDSA signature. */\nexport type Legacy<bigintType = bigint, numberType = number> = {\n  r: bigintType\n  s: bigintType\n  v: numberType\n}\n\n/** RPC-formatted (Legacy) ECDSA signature. */\nexport type LegacyRpc = Legacy<Hex.Hex, Hex.Hex>\n\nexport type Tuple = readonly [yParity: Hex.Hex, r: Hex.Hex, s: Hex.Hex]\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(\n  signature: ExactPartial<Signature>,\n  options: assert.Options = {},\n): asserts signature is Signature {\n  const { recovered } = options\n  if (typeof signature.r === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (typeof signature.s === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (recovered && typeof signature.yParity === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (signature.r < 0n || signature.r > Solidity.maxUint256)\n    throw new InvalidRError({ value: signature.r })\n  if (signature.s < 0n || signature.s > Solidity.maxUint256)\n    throw new InvalidSError({ value: signature.s })\n  if (\n    typeof signature.yParity === 'number' &&\n    signature.yParity !== 0 &&\n    signature.yParity !== 1\n  )\n    throw new InvalidYParityError({ value: signature.yParity })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType =\n    | MissingPropertiesError\n    | InvalidRError\n    | InvalidSError\n    | InvalidYParityError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature: Bytes.Bytes): Signature {\n  return fromHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature: Hex.Hex): Signature {\n  if (signature.length !== 130 && signature.length !== 132)\n    throw new InvalidSerializedSizeError({ signature })\n\n  const r = BigInt(Hex.slice(signature, 0, 32))\n  const s = BigInt(Hex.slice(signature, 32, 64))\n\n  const yParity = (() => {\n    const yParity = Number(`0x${signature.slice(130)}`)\n    if (Number.isNaN(yParity)) return undefined\n    try {\n      return vToYParity(yParity)\n    } catch {\n      throw new InvalidYParityError({ value: yParity })\n    }\n  })()\n\n  if (typeof yParity === 'undefined')\n    return {\n      r,\n      s,\n    } as never\n  return {\n    r,\n    s,\n    yParity,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType =\n    | Hex.from.ErrorType\n    | InvalidSerializedSizeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value: extract.Value): Signature | undefined {\n  if (typeof value.r === 'undefined') return undefined\n  if (typeof value.s === 'undefined') return undefined\n  return from(value as any)\n}\n\nexport declare namespace extract {\n  type Value = {\n    r?: bigint | Hex.Hex | undefined\n    s?: bigint | Hex.Hex | undefined\n    yParity?: number | Hex.Hex | undefined\n    v?: number | Hex.Hex | undefined\n  }\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from<\n  const signature extends\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n>(\n  signature:\n    | signature\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n): from.ReturnType<signature> {\n  const signature_ = (() => {\n    if (typeof signature === 'string') return fromHex(signature)\n    if (signature instanceof Uint8Array) return fromBytes(signature)\n    if (typeof signature.r === 'string') return fromRpc(signature)\n    if (signature.v) return fromLegacy(signature)\n    return {\n      r: signature.r,\n      s: signature.s,\n      ...(typeof signature.yParity !== 'undefined'\n        ? { yParity: signature.yParity }\n        : {}),\n    }\n  })()\n  assert(signature_)\n  return signature_ as never\n}\n\nexport declare namespace from {\n  type ReturnType<\n    signature extends\n      | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n      | Hex.Hex\n      | Bytes.Bytes,\n  > = signature extends Signature<boolean> & { v?: undefined }\n    ? signature\n    : Signature\n\n  type ErrorType =\n    | assert.ErrorType\n    | fromBytes.ErrorType\n    | fromHex.ErrorType\n    | vToYParity.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature: Bytes.Bytes): Signature<false> {\n  return fromDerHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature: Hex.Hex): Signature<false> {\n  const { r, s } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2))\n  return { r, s }\n}\n\nexport declare namespace fromDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature: Legacy): Signature {\n  return {\n    r: signature.r,\n    s: signature.s,\n    yParity: vToYParity(signature.v),\n  }\n}\n\nexport declare namespace fromLegacy {\n  type ErrorType = vToYParity.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature: {\n  r: Hex.Hex\n  s: Hex.Hex\n  yParity?: Hex.Hex | undefined\n  v?: Hex.Hex | undefined\n}): Signature {\n  const yParity = (() => {\n    const v = signature.v ? Number(signature.v) : undefined\n    let yParity = signature.yParity ? Number(signature.yParity) : undefined\n    if (typeof v === 'number' && typeof yParity !== 'number')\n      yParity = vToYParity(v)\n    if (typeof yParity !== 'number')\n      throw new InvalidYParityError({ value: signature.yParity })\n    return yParity\n  })()\n\n  return {\n    r: BigInt(signature.r),\n    s: BigInt(signature.s),\n    yParity,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple: Tuple): Signature {\n  const [yParity, r, s] = tuple\n  return from({\n    r: r === '0x' ? 0n : BigInt(r),\n    s: s === '0x' ? 0n : BigInt(s),\n    yParity: yParity === '0x' ? 0 : Number(yParity),\n  })\n}\n\nexport declare namespace fromTuple {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature: Signature<boolean>): Bytes.Bytes {\n  return Bytes.fromHex(toHex(signature))\n}\n\nexport declare namespace toBytes {\n  type ErrorType =\n    | toHex.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature: Signature<boolean>): Hex.Hex {\n  assert(signature)\n\n  const r = signature.r\n  const s = signature.s\n\n  const signature_ = Hex.concat(\n    Hex.fromNumber(r, { size: 32 }),\n    Hex.fromNumber(s, { size: 32 }),\n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n      ? Hex.fromNumber(yParityToV(signature.yParity), { size: 1 })\n      : '0x',\n  )\n\n  return signature_\n}\n\nexport declare namespace toHex {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature: Signature<boolean>): Bytes.Bytes {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return sig.toDERRawBytes()\n}\n\nexport declare namespace toDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature: Signature<boolean>): Hex.Hex {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return `0x${sig.toDERHex()}`\n}\n\nexport declare namespace toDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature: Signature): Legacy {\n  return {\n    r: signature.r,\n    s: signature.s,\n    v: yParityToV(signature.yParity),\n  }\n}\n\nexport declare namespace toLegacy {\n  type ErrorType = yParityToV.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature: Signature): Rpc {\n  const { r, s, yParity } = signature\n  return {\n    r: Hex.fromNumber(r, { size: 32 }),\n    s: Hex.fromNumber(s, { size: 32 }),\n    yParity: yParity === 0 ? '0x0' : '0x1',\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature: Signature): Tuple {\n  const { r, s, yParity } = signature\n\n  return [\n    yParity ? '0x01' : '0x',\n    r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r!)),\n    s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s!)),\n  ] as const\n}\n\nexport declare namespace toTuple {\n  type ErrorType =\n    | Hex.trimLeft.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(\n  signature: ExactPartial<Signature>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(signature, options)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v: number): Signature['yParity'] {\n  if (v === 0 || v === 27) return 0\n  if (v === 1 || v === 28) return 1\n  if (v >= 35) return v % 2 === 0 ? 1 : 0\n  throw new InvalidVError({ value: v })\n}\n\nexport declare namespace vToYParity {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity: number): number {\n  if (yParity === 0) return 27\n  if (yParity === 1) return 28\n  throw new InvalidYParityError({ value: yParity })\n}\n\nexport declare namespace yParityToV {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSerializedSizeError'\n\n  constructor({ signature }: { signature: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${signature}\\` is an invalid signature size.`, {\n      metaMessages: [\n        'Expected: 64 bytes or 65 bytes.',\n        `Received ${Hex.size(Hex.from(signature))} bytes.`,\n      ],\n    })\n  }\n}\n\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n  override readonly name = 'Signature.MissingPropertiesError'\n\n  constructor({ signature }: { signature: unknown }) {\n    super(\n      `Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidRError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidYParityError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidVError'\n\n  constructor({ value }: { value: number }) {\n    super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`)\n  }\n}\n","import type * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport type { Compute, Mutable, Undefined } from './internal/types.js'\n\n/** Root type for an EIP-7702 Authorization. */\nexport type Authorization<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  {\n    /** Address of the contract to set as code for the Authority. */\n    address: Address.Address\n    /** Chain ID to authorize. */\n    chainId: numberType\n    /** Nonce of the Authority to authorize. */\n    nonce: bigintType\n  } & (signed extends true\n    ? Signature.Signature<true, bigintType, numberType>\n    : Undefined<Signature.Signature>)\n>\n\n/** RPC representation of an {@link ox#Authorization.Authorization}. */\nexport type Rpc = Authorization<true, Hex.Hex, Hex.Hex>\n\n/** List of {@link ox#Authorization.Authorization}. */\nexport type List<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<readonly Authorization<signed, bigintType, numberType>[]>\n\n/** RPC representation of an {@link ox#Authorization.List}. */\nexport type ListRpc = List<true, Hex.Hex, Hex.Hex>\n\n/** Signed representation of a list of {@link ox#Authorization.Authorization}. */\nexport type ListSigned<bigintType = bigint, numberType = number> = List<\n  true,\n  bigintType,\n  numberType\n>\n\n/** Signed representation of an {@link ox#Authorization.Authorization}. */\nexport type Signed<bigintType = bigint, numberType = number> = Authorization<\n  true,\n  bigintType,\n  numberType\n>\n\n/** Tuple representation of an {@link ox#Authorization.Authorization}. */\nexport type Tuple<signed extends boolean = boolean> = signed extends true\n  ? readonly [\n      chainId: Hex.Hex,\n      address: Hex.Hex,\n      nonce: Hex.Hex,\n      yParity: Hex.Hex,\n      r: Hex.Hex,\n      s: Hex.Hex,\n    ]\n  : readonly [chainId: Hex.Hex, address: Hex.Hex, nonce: Hex.Hex]\n\n/** Tuple representation of a signed {@link ox#Authorization.Authorization}. */\nexport type TupleSigned = Tuple<true>\n\n/** Tuple representation of a list of {@link ox#Authorization.Authorization}. */\nexport type TupleList<signed extends boolean = boolean> =\n  readonly Tuple<signed>[]\n\n/** Tuple representation of a list of signed {@link ox#Authorization.Authorization}. */\nexport type TupleListSigned = TupleList<true>\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nexport function from<\n  const authorization extends Authorization | Rpc,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  authorization: authorization | Authorization,\n  options: from.Options<signature> = {},\n): from.ReturnType<authorization, signature> {\n  if (typeof authorization.chainId === 'string')\n    return fromRpc(authorization) as never\n  return { ...authorization, ...options.signature } as never\n}\n\nexport declare namespace from {\n  type Options<\n    signature extends Signature.Signature | undefined =\n      | Signature.Signature\n      | undefined,\n  > = {\n    /** The {@link ox#Signature.Signature} to attach to the Authorization. */\n    signature?: signature | Signature.Signature | undefined\n  }\n\n  type ReturnType<\n    authorization extends Authorization | Rpc = Authorization,\n    signature extends Signature.Signature | undefined =\n      | Signature.Signature\n      | undefined,\n  > = Compute<\n    authorization extends Rpc\n      ? Signed\n      : authorization &\n          (signature extends Signature.Signature ? Readonly<signature> : {})\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */\nexport function fromRpc(authorization: Rpc): Signed {\n  const { address, chainId, nonce } = authorization\n  const signature = Signature.extract(authorization)!\n\n  return {\n    address,\n    chainId: Number(chainId),\n    nonce: BigInt(nonce),\n    ...signature,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */\nexport function fromRpcList(authorizationList: ListRpc): ListSigned {\n  return authorizationList.map(fromRpc)\n}\n\nexport declare namespace fromRpcList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nexport function fromTuple<const tuple extends Tuple>(\n  tuple: tuple,\n): fromTuple.ReturnType<tuple> {\n  const [chainId, address, nonce, yParity, r, s] = tuple\n  const signature =\n    yParity && r && s ? Signature.fromTuple([yParity, r, s]) : undefined\n  return from({\n    address,\n    chainId: Number(chainId),\n    nonce: BigInt(nonce),\n    ...signature,\n  }) as never\n}\n\nexport declare namespace fromTuple {\n  type ReturnType<authorization extends Tuple = Tuple> = Compute<\n    Authorization<authorization extends Tuple<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */\nexport function fromTupleList<const tupleList extends TupleList>(\n  tupleList: tupleList,\n): fromTupleList.ReturnType<tupleList> {\n  const list: Mutable<List> = []\n  for (const tuple of tupleList) list.push(fromTuple(tuple))\n  return list as never\n}\n\nexport declare namespace fromTupleList {\n  type ReturnType<tupleList extends TupleList> = Compute<\n    TupleList<tupleList extends TupleList<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */\nexport function getSignPayload(authorization: Authorization): Hex.Hex {\n  return hash(authorization)\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */\nexport function hash(authorization: Authorization): Hex.Hex {\n  return Hash.keccak256(Hex.concat('0x05', Rlp.fromHex(toTuple(authorization))))\n}\n\nexport declare namespace hash {\n  type ErrorType =\n    | toTuple.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */\nexport function toRpc(authorization: Signed): Rpc {\n  const { address, chainId, nonce, ...signature } = authorization\n\n  return {\n    address,\n    chainId: Hex.fromNumber(chainId),\n    nonce: Hex.fromNumber(nonce),\n    ...Signature.toRpc(signature),\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */\nexport function toRpcList(authorizationList: ListSigned): ListRpc {\n  return authorizationList.map(toRpc)\n}\n\nexport declare namespace toRpcList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */\nexport function toTuple<const authorization extends Authorization>(\n  authorization: authorization,\n): toTuple.ReturnType<authorization> {\n  const { address, chainId, nonce } = authorization\n  const signature = Signature.extract(authorization)\n  return [\n    chainId ? Hex.fromNumber(chainId) : '0x',\n    address,\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    ...(signature ? Signature.toTuple(signature) : []),\n  ] as never\n}\n\nexport declare namespace toTuple {\n  type ReturnType<authorization extends Authorization = Authorization> =\n    Compute<Tuple<authorization extends Signature.Signature ? true : false>>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */\nexport function toTupleList<\n  const list extends\n    | readonly Authorization<true>[]\n    | readonly Authorization<false>[],\n>(list?: list | undefined): toTupleList.ReturnType<list> {\n  if (!list || list.length === 0) return []\n\n  const tupleList: Mutable<TupleList> = []\n  for (const authorization of list) tupleList.push(toTuple(authorization))\n\n  return tupleList as never\n}\n\nexport declare namespace toTupleList {\n  type ReturnType<\n    list extends\n      | readonly Authorization<true>[]\n      | readonly Authorization<false>[],\n  > = Compute<\n    TupleList<list extends readonly Authorization<true>[] ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"names":[],"mappings":"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","ignoreList":[5,6,10,11]}