{"version":3,"sources":["../../../../node_modules/thirdweb/src/rpc/actions/eth_getStorageAt.ts","../../../../node_modules/thirdweb/src/utils/bytecode/resolveImplementation.ts","../../../../node_modules/thirdweb/src/utils/bytecode/extractMinimalProxyImplementationAddress.ts"],"sourcesContent":["import type { BlockTag, EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\nimport { getAddress } from \"../../utils/address.js\";\n\ntype GetStorageAtParams = {\n  address: string;\n  position: Hex;\n  blockTag?: BlockTag;\n};\n\n/**\n * Retrieves the value stored at a specific position in the storage of a contract.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the eth_getStorageAt method.\n * @returns A promise that resolves to the value stored at the specified position.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getStorageAt } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const storageValue = await eth_getStorageAt(rpcRequest, {\n * address: \"0x...\",\n *  position: 0n,\n * });\n * ```\n */\nexport async function eth_getStorageAt(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetStorageAtParams,\n): Promise<Hex> {\n  return await request({\n    method: \"eth_getStorageAt\",\n    params: [\n      getAddress(params.address),\n      params.position,\n      params.blockTag ?? \"latest\",\n    ],\n  });\n}\n","import { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport { getContract, type ThirdwebContract } from \"../../contract/contract.js\";\nimport { eth_getStorageAt } from \"../../rpc/actions/eth_getStorageAt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { isAddress } from \"../address.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { extractMinimalProxyImplementationAddress } from \"./extractMinimalProxyImplementationAddress.js\";\n\n// TODO: move to const exports\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\nconst ZERO_BYTES32 =\n  \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n/**\n * Resolves the implementation address and bytecode for a given proxy contract.\n * @param contract The contract to resolve the implementation for.\n * @returns A promise that resolves to an object containing the implementation address and bytecode.\n * @example\n * ```ts\n * import { resolveImplementation } from \"thirdweb/utils\";\n * const implementation = await resolveImplementation(contract);\n * ```\n * @contract\n */\nexport async function resolveImplementation(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<{ address: string; bytecode: Hex }> {\n  const [originalBytecode, beacon] = await Promise.all([\n    getBytecode(contract),\n    getBeaconFromStorageSlot(contract),\n  ]);\n  // check minimal proxy first synchronously\n  const minimalProxyImplementationAddress =\n    extractMinimalProxyImplementationAddress(originalBytecode);\n  if (minimalProxyImplementationAddress) {\n    return {\n      address: minimalProxyImplementationAddress,\n      bytecode: await getBytecode(\n        getContract({\n          ...contract,\n          address: minimalProxyImplementationAddress,\n        }),\n      ),\n    };\n  }\n\n  // check other proxy types\n  if (beacon && beacon !== AddressZero) {\n    // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation\n    // Hence we replace the proxy address with Beacon address, and continue further resolving below\n    contract = getContract({\n      ...contract,\n      address: beacon,\n    });\n  }\n\n  const implementations = await Promise.all([\n    getImplementationFromStorageSlot(contract),\n    getImplementationFromContractCall(contract),\n  ]);\n\n  for (const implementationAddress of implementations) {\n    if (\n      implementationAddress &&\n      isAddress(implementationAddress) &&\n      implementationAddress !== AddressZero\n    ) {\n      const implementationBytecode = await getBytecode({\n        ...contract,\n        address: implementationAddress,\n      });\n      // return the original contract bytecode if the implementation bytecode is empty\n      if (implementationBytecode === \"0x\") {\n        return {\n          address: contract.address,\n          bytecode: originalBytecode,\n        };\n      }\n\n      return {\n        address: implementationAddress,\n        bytecode: implementationBytecode,\n      };\n    }\n  }\n\n  return { address: contract.address, bytecode: originalBytecode };\n}\n\nasync function getBeaconFromStorageSlot(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  /**\n   * The storage slot of the Beacon as defined in EIP-1967\n   * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address\n   *\n   * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))\n   */\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  try {\n    const proxyStorage = await eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position:\n        \"0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50\",\n    });\n    if (proxyStorage.length >= 40) {\n      return `0x${proxyStorage.slice(-40)}`;\n    }\n    return undefined;\n  } catch {\n    return undefined;\n  }\n}\n\nasync function getImplementationFromStorageSlot(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  try {\n    const proxyStoragePromises = [\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n      }),\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          // keccak256(\"matic.network.proxy.implementation\") - used in polygon USDT proxy: https://polygonscan.com/address/0xc2132d05d31c914a87c6611c10748aeb04b58e8f#code\n          \"0xbaab7dbf64751104133af04abc7d9979f0fda3b059a322a8333f533d3f32bf7f\",\n      }),\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          // keccak256(\"org.zeppelinos.proxy.implementation\") - e.g. base USDC proxy: https://basescan.org/address/0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913#code\n          \"0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3\",\n      }),\n    ];\n\n    const proxyStorages = await Promise.all(proxyStoragePromises);\n    const proxyStorage = proxyStorages.find(\n      (storage) => storage !== ZERO_BYTES32,\n    );\n\n    return proxyStorage ? `0x${proxyStorage.slice(-40)}` : AddressZero;\n  } catch {\n    return undefined;\n  }\n}\n\nconst UPGRADEABLE_PROXY_ABI = {\n  inputs: [],\n  name: \"implementation\",\n  outputs: [\n    {\n      internalType: \"address\",\n      name: \"\",\n      type: \"address\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nasync function getImplementationFromContractCall(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  try {\n    return await readContract({ contract, method: UPGRADEABLE_PROXY_ABI });\n  } catch {\n    return undefined;\n  }\n}\n","/**\n * Extracts the implementation address from a given bytecode string if it matches any of the known minimal proxy patterns.\n * @param bytecode The bytecode string to extract the implementation address from.\n * @returns The implementation address as a string if a match is found, otherwise undefined.\n * @example\n * ```ts\n * import { extractMinimalProxyImplementationAddress } from \"thirdweb/utils\";\n * const bytecode = \"0x363d3d373d3d3d363d73...\";\n * const implementationAddress = extractMinimalProxyImplementationAddress(bytecode);\n * ```\n * @utils\n */\nexport function extractMinimalProxyImplementationAddress(\n  bytecode: string,\n): string | undefined {\n  if (!bytecode.startsWith(\"0x\")) {\n    bytecode = `0x${bytecode}`;\n  }\n  // EIP-1167 clone minimal proxy - https://eips.ethereum.org/EIPS/eip-1167\n  if (bytecode.startsWith(\"0x363d3d373d3d3d363d73\")) {\n    const implementationAddress = bytecode.slice(22, 62);\n    return `0x${implementationAddress}`;\n  }\n\n  // Minimal Proxy with receive() from 0xSplits - https://github.com/0xSplits/splits-contracts/blob/c7b741926ec9746182d0d1e2c4c2046102e5d337/contracts/libraries/Clones.sol\n  if (bytecode.startsWith(\"0x36603057343d5230\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(122, 122 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // 0age's minimal proxy - https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48\n  if (bytecode.startsWith(\"0x3d3d3d3d363d3d37363d73\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(24, 24 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // vyper's minimal proxy (uniswap v1) - https://etherscan.io/address/0x09cabec1ead1c0ba254b09efb3ee13841712be14#code\n  if (bytecode.startsWith(\"0x366000600037611000600036600073\")) {\n    const implementationAddress = bytecode.slice(32, 32 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  if (bytecode.startsWith(\"0x36600080376020600036600073\")) {\n    const implementationAddress = bytecode.slice(28, 28 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // EIP-7511 minimal proxy with PUSH0 opcode - https://eips.ethereum.org/EIPS/eip-7511\n  if (bytecode.startsWith(\"0x365f5f375f5f365f73\")) {\n    const implementationAddress = bytecode.slice(20, 60);\n    return `0x${implementationAddress}`;\n  }\n\n  // EIP-7702 - https://eips.ethereum.org/EIPS/eip-7702#abstract\n  if (bytecode.length === 48 && bytecode.startsWith(\"0xef0100\")) {\n    const implementationAddress = bytecode.slice(8, 48);\n    return `0x${implementationAddress}`;\n  }\n\n  return undefined;\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2]}