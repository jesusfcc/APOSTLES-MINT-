module.exports=[564861,a=>{"use strict";function b(){let a=new Set,b=[],c=()=>{},d=c();return{_listeners:()=>a,clear(){a.forEach(a=>a([],{removed:[...b]})),b=[]},destroy(){this.clear(),a.clear(),d?.()},findProvider:({rdns:a})=>b.find(b=>b.info.rdns===a),getProviders:()=>b,reset(){this.clear(),d?.(),d=c()},subscribe:(c,{emitImmediately:d}={})=>(a.add(c),d&&c(b,{added:b}),()=>a.delete(c))}}a.s(["createStore",()=>b],564861)},909105,393355,51904,679722,54276,a=>{"use strict";var b=a.i(74282);function c(){return!!(function(){if("undefined"==typeof navigator)return!1;let a=(0,b.detectOS)(navigator.userAgent);return!!a&&a.toLowerCase().includes("android")}()||function(){if("undefined"==typeof navigator)return!1;let a=(0,b.detectOS)(navigator.userAgent);return!!a&&(a.toLowerCase().includes("ios")||a.toLowerCase().includes("mac")&&navigator.maxTouchPoints>1)}())}function d(a){if(window!==window.top)window.open(a);else if(a.startsWith("http")){let b=document.createElement("a");b.href=a,b.target="_blank",b.rel="noreferrer noopener",b.click()}else window.location.href=a}a.s(["isMobile",()=>c],909105),a.s(["openWindow",()=>d],393355);var e=a.i(29946),f=a.i(638181),g=a.i(710142),h=a.i(876748);function i(b){let c,d,{createOptions:i}=b,j=(0,h.createWalletEmitter)();function k(){c=void 0,d=void 0}let l=async()=>{},m=async a=>{d=a},n=j.subscribe("chainChanged",a=>{d=a}),o=j.subscribe("disconnect",()=>{k(),n(),o()});return j.subscribe("accountChanged",a=>{c=a}),{autoConnect:async f=>{let{autoConnectCoinbaseWalletSDK:h}=await a.A(621662),i=await b.providerFactory(),[k,n,o,p]=await h(f,j,i);return c=k,d=n,l=o,m=p,(0,e.trackConnect)({chainId:d.id,client:f.client,walletAddress:c.address,walletType:g.COINBASE}),c},connect:async f=>{let{connectCoinbaseWalletSDK:h}=await a.A(621662),i=await b.providerFactory(),[k,n,o,p]=await h(f,j,i);return c=k,d=n,l=o,m=p,(0,e.trackConnect)({chainId:d.id,client:f.client,walletAddress:c.address,walletType:g.COINBASE}),c},disconnect:async()=>{k(),await l()},getAccount:()=>c,getChain(){if(d)return d=(0,f.getCachedChainIfExists)(d.id)||d},getConfig:()=>i,id:g.COINBASE,onConnectRequested:async()=>{if(b.onConnectRequested){let a=await b.providerFactory();return b.onConnectRequested?.(a)}},subscribe:j.subscribe,switchChain:async a=>{await m(a)}}}a.s(["coinbaseWalletSDK",()=>i],51904);var j=a.i(599696);function k(...b){let[c,d]=b,e={id:c,partnerId:d?.partnerId};return(0,j.createInAppWallet)({connectorFactory:async b=>{let{InAppWebConnector:c}=await a.A(522071);return new c({client:b,ecosystem:e,storage:d?.storage})},createOptions:{auth:{...d?.auth,options:[]},partnerId:e.partnerId},ecosystem:e})}function l(b){return(0,j.createInAppWallet)({connectorFactory:async c=>{let{InAppWebConnector:d}=await a.A(522071);return new d({client:c,passkeyDomain:b?.auth?.passkeyDomain,storage:b?.storage})},createOptions:b})}a.s(["ecosystemWallet",()=>k],679722),a.s(["inAppWallet",()=>l],54276)},89788,a=>{"use strict";a.s(["autoConnectEip1193Wallet",()=>u,"connectEip1193Wallet",()=>t,"getInjectedProvider",()=>s]);var b=a.i(145892),c=a.i(282258),d=a.i(126982),e=a.i(130557),f=a.i(28913),g=a.i(871892),h=a.i(71932),i=a.i(638181),j=a.i(770529),k=a.i(707014),l=a.i(841997),m=a.i(71763),n=a.i(86296),o=a.i(538014),p=a.i(983984),q=a.i(762109),r=a.i(433269);function s(a){let b=(0,r.injectedProvider)(a);if(!b)throw Error(`No injected provider found for wallet: "${a}"`);return b}async function t({id:a,provider:b,emitter:c,client:d,chain:e}){let f,g=0;for(;!f?.[0]&&g<3;){try{f=await b.request({method:"eth_requestAccounts"})}catch(a){var h;if(console.error(a),((h=a)instanceof Error?h.message:"string"==typeof h?h:"object"==typeof h&&null!==h?JSON.stringify(h):String(h))?.toLowerCase()?.includes("rejected"))throw a;await new Promise(a=>setTimeout(a,500))}g++}let k=f?.[0];if(!k)throw Error("Failed to connect to wallet, no accounts available");let l=(0,j.getAddress)(k),m=await b.request({method:"eth_chainId"}).then(q.normalizeChainId).catch(a=>{throw Error("Error reading chainId from provider",a)}),n=e&&e.id===m?e:(0,i.getCachedChain)(m);try{e&&void 0!==e.id&&e.id!==m&&(await x(b,e),n=e)}catch{console.warn(`Error switching to chain ${e?.id} - defaulting to wallet chain (${m})`)}return w({address:l,chain:n,client:d,emitter:c,id:a,provider:b})}async function u({id:a,provider:b,emitter:c,client:d,chain:e}){let f=(await b.request({method:"eth_accounts"}))[0];if(!f)throw Error("Failed to connect to wallet, no accounts available");let g=(0,j.getAddress)(f),h=await b.request({method:"eth_chainId"}).then(q.normalizeChainId);return w({address:g,chain:e&&e.id===h?e:(0,i.getCachedChain)(h),client:d,emitter:c,id:a,provider:b})}function v({provider:a,address:f,client:i,id:p}){let q={address:(0,j.getAddress)(f),async sendTransaction(c){let d=[{...c.gasPrice?{gasPrice:(0,k.numberToHex)(c.gasPrice)}:{maxFeePerGas:c.maxFeePerGas?(0,k.numberToHex)(c.maxFeePerGas):void 0,maxPriorityFeePerGas:c.maxPriorityFeePerGas?(0,k.numberToHex)(c.maxPriorityFeePerGas):void 0},from:this.address,gas:c.gas?(0,k.numberToHex)(c.gas):void 0,nonce:c.nonce?(0,k.numberToHex)(c.nonce):void 0,to:c.to?(0,j.getAddress)(c.to):void 0,data:c.data,value:c.value?(0,k.numberToHex)(c.value):void 0,authorizationList:c.authorizationList?b.toRpcList(c.authorizationList):void 0,accessList:c.accessList,...c.eip712}];try{let b=await a.request({method:"eth_sendTransaction",params:d});return(0,h.trackTransaction)({chainId:c.chainId,client:i,contractAddress:c.to??void 0,gasPrice:c.gasPrice,transactionHash:b,walletAddress:(0,j.getAddress)(f),walletType:p}),{transactionHash:b}}catch(a){throw(0,g.isInsufficientFundsError)(a)&&(0,h.trackInsufficientFundsError)({chainId:c.chainId,client:i,contractAddress:c.to||void 0,error:a,transactionValue:c.value,walletAddress:(0,j.getAddress)(f)}),a}},async signMessage({message:b}){if(!q.address)throw Error("Provider not setup");let c="string"==typeof b?(0,k.stringToHex)(b):b.raw instanceof Uint8Array?(0,k.uint8ArrayToHex)(b.raw):b.raw;return await a.request({method:"personal_sign",params:[c,(0,j.getAddress)(q.address)]})},async signAuthorization(d){let e,f=b.getSignPayload(d);try{e=await a.request({method:"eth_sign",params:[(0,j.getAddress)(q.address),f]})}catch{e=await a.request({method:"secp256k1_sign",params:[f]})}if(!e)throw Error("Failed to sign authorization");let g=c.fromHex(e);return{...d,...g}},async signTypedData(b){if(!a||!q.address)throw Error("Provider not setup");let c=(0,l.parseTypedData)(b),{domain:e,message:f,primaryType:g}=c,h={EIP712Domain:(0,d.getTypesForEIP712Domain)({domain:e}),...c.types};(0,d.validateTypedData)({domain:e,message:f,primaryType:g,types:h});let i=(0,d.serializeTypedData)({domain:e??{},message:f,primaryType:g,types:h});return await a.request({method:"eth_signTypedData_v4",params:[(0,j.getAddress)(q.address),i]})},watchAsset:async b=>await a.request({method:"wallet_watchAsset",params:b},{retryCount:0}),async sendCalls(b){try{let{callParams:c,chain:d}=await (0,o.toProviderCallParams)(b,q),e=await a.request({method:"wallet_sendCalls",params:c});if(e&&"object"==typeof e&&"id"in e)return{chain:d,client:i,id:e.id};return{chain:d,client:i,id:e}}catch(a){if(/unsupport|not support/i.test(a.message))throw Error(`${p} errored calling wallet_sendCalls, with error: ${a instanceof Error?a.message:(0,e.stringify)(a)}`);throw a}},async getCallsStatus(b){try{let c=await a.request({method:"wallet_getCallsStatus",params:[b.id]});return(0,m.toGetCallsStatusResponse)(c)}catch(a){if(/unsupport|not support/i.test(a.message))throw Error(`${p} does not support wallet_getCallsStatus, reach out to them directly to request EIP-5792 support.`);throw a}},async getCapabilities(b){let c=b.chainId;try{let b=await a.request({method:"wallet_getCapabilities",params:[(0,j.getAddress)(q.address),c?[(0,k.numberToHex)(c)]:void 0]});return(0,n.toGetCapabilitiesResult)(b,c)}catch(a){if(/unsupport|not support|not available/i.test(a.message))return{message:`${p} does not support wallet_getCapabilities, reach out to them directly to request EIP-5792 support.`};throw a}}};return q}async function w({provider:a,address:b,chain:c,emitter:d,client:e,id:g}){let h=v({address:b,client:e,id:g,provider:a});async function k(){a.removeListener("accountsChanged",m),a.removeListener("chainChanged",n),a.removeListener("disconnect",l);try{await (0,f.withTimeout)(()=>a.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]}),{timeout:100})}catch{}}async function l(){k(),d.emit("disconnect",void 0)}function m(b){if(b[0]){let c=v({address:(0,j.getAddress)(b[0]),client:e,id:g,provider:a});d.emit("accountChanged",c),d.emit("accountsChanged",b)}else l()}function n(a){let b=(0,i.getCachedChain)((0,q.normalizeChainId)(a));d.emit("chainChanged",b)}return a.on&&(a.on("accountsChanged",m),a.on("chainChanged",n),a.on("disconnect",l)),[h,c,l,b=>x(a,b)]}async function x(a,b){let c=(0,k.numberToHex)(b.id);try{await a.request({method:"wallet_switchEthereumChain",params:[{chainId:c}]})}catch{let d=await (0,i.getChainMetadata)(b);await a.request({method:"wallet_addEthereumChain",params:[{blockExplorerUrls:d.explorers?.map(a=>a.url),chainId:c,chainName:d.name,nativeCurrency:d.nativeCurrency,rpcUrls:(0,p.getValidPublicRPCUrl)(d)}]})}}},459433,a=>{"use strict";a.s(["createWallet",()=>p]);var b=a.i(29946),c=a.i(638181),d=a.i(85671),e=a.i(909105),f=a.i(393355),g=a.i(51904),h=a.i(466606),i=a.i(710142),j=a.i(171717),k=a.i(679722),l=a.i(54276),m=a.i(89788),n=a.i(872121),o=a.i(876748);function p(...q){let[r,s]=q;switch(!0){case"smart"===r:return(0,n.smartWallet)(s);case"embedded"===r||"inApp"===r:return(0,l.inAppWallet)(s);case(0,j.isEcosystemWallet)(r):return(0,k.ecosystemWallet)(...q);case r===i.COINBASE:return(0,g.coinbaseWalletSDK)({createOptions:s,onConnectRequested:async b=>{let{showCoinbasePopup:c}=await a.A(400595);return c(b)},providerFactory:()=>(0,h.getCoinbaseWebProvider)(s)});default:{let g,h,i,j=(0,o.createWalletEmitter)();function t(){g=void 0,h=void 0}let k=async()=>{},l=j.subscribe("disconnect",()=>{t(),i?.(),l()});j.subscribe("accountChanged",a=>{g=a});let n=async()=>{throw Error("Not implemented yet")},p=(0,e.isMobile)()?a=>(0,f.openWindow)(a):void 0,s={autoConnect:async c=>{let{injectedProvider:e}=await a.A(33410);if("walletConnect"!==r&&e(r)){let{autoConnectEip1193Wallet:d}=await a.A(59817),[e,f,l,o]=await d({chain:c.chain,client:c.client,emitter:j,id:r,provider:(0,m.getInjectedProvider)(r)});return g=e,h=f,k=l,n=o,i=j.subscribe("chainChanged",a=>{h=a}),(0,b.trackConnect)({chainId:h.id,client:c.client,walletAddress:g.address,walletType:r}),g}if(c&&"client"in c){let{autoConnectWC:e}=await a.A(603625),[f,i,l,m]=await e(c,j,s.id,d.webLocalStorage,p);return g=f,h=i,k=l,n=m,(0,b.trackConnect)({chainId:h.id,client:c.client,walletAddress:g.address,walletType:r}),g}throw Error("Failed to auto connect")},connect:async c=>{async function e(c){let e,{connectWC:f}=await a.A(603625);try{let[a,i,l,m]=await f({...c,walletConnect:{...c.walletConnect,onDisplayUri:c.walletConnect?.onDisplayUri||(async a=>{})}},j,s.id,d.webLocalStorage,p);return e&&(e.destroy(),e=void 0),g=a,h=i,k=l,n=m,(0,b.trackConnect)({chainId:h.id,client:c.client,walletAddress:g.address,walletType:r}),g}catch(a){throw e&&(e.destroy(),e=void 0),a}}if("walletConnect"===r){let{client:a,chain:b,...d}=c;return e({chain:b,client:a,walletConnect:{...d}})}let f=c&&"walletConnect"in c,{injectedProvider:l}=await a.A(33410);if(l(r)&&!f){let{connectEip1193Wallet:d}=await a.A(59817),[e,f,l,o]=await d({chain:c.chain,client:c.client,emitter:j,id:r,provider:(0,m.getInjectedProvider)(r)});return g=e,h=f,k=l,n=o,i=j.subscribe("chainChanged",a=>{h=a}),(0,b.trackConnect)({chainId:h.id,client:c.client,walletAddress:g.address,walletType:r}),g}if(c&&"client"in c)return e(c);throw Error("Failed to connect")},disconnect:async()=>{t(),await k()},getAccount:()=>g,getChain(){if(h)return h=(0,c.getCachedChainIfExists)(h.id)||h},getConfig:()=>q[1],id:r,subscribe:j.subscribe,switchChain:async a=>{try{await n(a),h=a}catch(a){console.error("Error switching chain",a)}}};return s}}}},433269,a=>{"use strict";a.s(["getInstalledWalletProviders",()=>i,"getInstalledWallets",()=>h,"injectedProvider",()=>g]);var b=a.i(564861),c=a.i(850671),d=a.i(710142),e=a.i(459433);let f=(0,c.isBrowser)()?(0,b.createStore)():void 0;function g(a){let b=i().find(b=>b.info.rdns===a);return b?.provider}function h(){return i().map(a=>a.info.rdns).map(a=>(0,e.createWallet)(a))}function i(){let a=(function(){if(f)return f})()?.getProviders()||[];for(let b of a)if("io.metamask.mobile"===b.info.rdns){b.info.rdns=d.METAMASK;break}return a}}];

//# sourceMappingURL=node_modules_4060ef67._.js.map