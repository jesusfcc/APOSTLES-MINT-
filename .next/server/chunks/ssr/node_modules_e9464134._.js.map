{"version":3,"sources":["../../../../node_modules/viem/utils/abi/encodePacked.ts","../../../../node_modules/thirdweb/src/merkletree/MerkleTree.ts","../../../../node_modules/thirdweb/src/utils/extensions/drops/fetch-proofs-for-claimers.ts","../../../../node_modules/thirdweb/src/utils/extensions/drops/convert-quantity.ts","../../../../node_modules/thirdweb/src/utils/extensions/drops/hash-entry.ts"],"sourcesContent":["import type {\n  AbiParameterToPrimitiveType,\n  AbiType,\n  Address,\n  SolidityAddress,\n  SolidityArrayWithoutTuple,\n  SolidityBool,\n  SolidityBytes,\n  SolidityInt,\n  SolidityString,\n} from 'abitype'\n\nimport {\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  BytesSizeMismatchError,\n  type BytesSizeMismatchErrorType,\n  UnsupportedPackedAbiType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\nimport {\n  type BoolToHexErrorType,\n  boolToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js'\n\ntype PackedAbiType =\n  | SolidityAddress\n  | SolidityBool\n  | SolidityBytes\n  | SolidityInt\n  | SolidityString\n  | SolidityArrayWithoutTuple\n\ntype EncodePackedValues<\n  packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n> = {\n  [K in keyof packedAbiTypes]: packedAbiTypes[K] extends AbiType\n    ? AbiParameterToPrimitiveType<{ type: packedAbiTypes[K] }>\n    : unknown\n}\n\nexport type EncodePackedErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | ConcatHexErrorType\n  | EncodeErrorType\n  | ErrorType\n\nexport function encodePacked<\n  const packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n>(types: packedAbiTypes, values: EncodePackedValues<packedAbiTypes>): Hex {\n  if (types.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encode(type, value))\n  }\n  return concatHex(data)\n}\n\ntype EncodeErrorType =\n  | BoolToHexErrorType\n  | BytesSizeMismatchErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | PadErrorType\n  | StringToHexErrorType\n  | UnsupportedPackedAbiType\n  | ErrorType\n\nfunction encode<const packedAbiType extends PackedAbiType | unknown>(\n  type: packedAbiType,\n  value: EncodePackedValues<[packedAbiType]>[0],\n  isArray = false,\n): Hex {\n  if (type === 'address') {\n    const address = value as Address\n    if (!isAddress(address)) throw new InvalidAddressError({ address })\n    return pad(address.toLowerCase() as Hex, {\n      size: isArray ? 32 : null,\n    }) as Address\n  }\n  if (type === 'string') return stringToHex(value as string)\n  if (type === 'bytes') return value as Hex\n  if (type === 'bool')\n    return pad(boolToHex(value as boolean), { size: isArray ? 32 : 1 })\n\n  const intMatch = (type as string).match(integerRegex)\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch\n    const size = Number.parseInt(bits, 10) / 8\n    return numberToHex(value as number, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int',\n    })\n  }\n\n  const bytesMatch = (type as string).match(bytesRegex)\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch\n    if (Number.parseInt(size, 10) !== ((value as Hex).length - 2) / 2)\n      throw new BytesSizeMismatchError({\n        expectedSize: Number.parseInt(size, 10),\n        givenSize: ((value as Hex).length - 2) / 2,\n      })\n    return pad(value as Hex, { dir: 'right', size: isArray ? 32 : null }) as Hex\n  }\n\n  const arrayMatch = (type as string).match(arrayRegex)\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch\n    const data: Hex[] = []\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true))\n    }\n    if (data.length === 0) return '0x'\n    return concatHex(data)\n  }\n\n  throw new UnsupportedPackedAbiType(type)\n}\n","// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\nimport { type Hex, uint8ArrayToHex } from \"../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../utils/encoding/to-bytes.js\";\nimport { keccak256 } from \"../utils/hashing/keccak256.js\";\nimport {\n  areUint8ArraysEqual,\n  compareUint8Arrays,\n  concatUint8Arrays,\n} from \"../utils/uint8-array.js\";\n\n// TODO: clean this up more, there is probably something to be said to move this entirely out of a class\n\ntype TLeaf = Uint8Array;\ntype TLayer = Uint8Array[];\n\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nexport class MerkleTree {\n  private leaves: TLeaf[] = [];\n  private layers: TLayer[] = [];\n\n  constructor(leaves: (Uint8Array | Hex)[]) {\n    this.leaves = leaves.map((el) =>\n      el instanceof Uint8Array ? el : hexToBytes(el),\n    );\n\n    this.leaves = this.leaves.sort(compareUint8Arrays);\n\n    this.createHashes(this.leaves);\n  }\n\n  public getHexRoot(): `0x${string}` {\n    return uint8ArrayToHex(this.getRoot());\n  }\n\n  public getHexProof(leaf: Uint8Array | Hex, index?: number): `0x${string}`[] {\n    return this.getProof(leaf, index).map((item) => uint8ArrayToHex(item.data));\n  }\n\n  // private below\n\n  private createHashes(nodes: Uint8Array[]) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n\n      this.layers.push([]);\n\n      const layerLimit = nodes.length;\n\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          // biome-ignore lint/style/noNonNullAssertion: in bounds\n          this.layers[layerIndex]!.push(...nodes.slice(layerLimit));\n          break;\n        }\n        if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            // push copy of hash and continue iteration\n            // biome-ignore lint/style/noNonNullAssertion: in bounds\n            this.layers[layerIndex]!.push(nodes[i]!);\n            continue;\n          }\n        }\n\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const left = nodes[i]!;\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const right = i + 1 === nodes.length ? left : nodes[i + 1]!;\n        const combined = [left, right];\n\n        combined.sort(compareUint8Arrays);\n\n        const hash = keccak256(concatUint8Arrays(combined), \"bytes\");\n\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        this.layers[layerIndex]!.push(hash);\n      }\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      nodes = this.layers[layerIndex]!;\n    }\n  }\n\n  private getRoot(): Uint8Array {\n    if (this.layers.length === 0) {\n      return new Uint8Array();\n    }\n\n    // biome-ignore lint/style/noNonNullAssertion: in bounds\n    return this.layers[this.layers.length - 1]![0] || new Uint8Array();\n  }\n\n  private getProof(\n    leaf: Uint8Array | Hex,\n    index?: number,\n  ): { position: \"left\" | \"right\"; data: Uint8Array }[] {\n    if (typeof leaf === \"undefined\") {\n      throw new Error(\"leaf is required\");\n    }\n\n    leaf = leaf instanceof Uint8Array ? leaf : hexToBytes(leaf);\n    const proof = [];\n\n    if (!Number.isInteger(index)) {\n      index = -1;\n\n      for (let i = 0; i < this.leaves.length; i++) {\n        // biome-ignore lint/style/noNonNullAssertion: within bounds\n        if (areUint8ArraysEqual(leaf, this.leaves[i]!)) {\n          index = i;\n        }\n      }\n    }\n\n    // @ts-expect-error - issue from original code\n    if (index <= -1) {\n      return [];\n    }\n\n    for (let i = 0; i < this.layers.length; i++) {\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      const layer = this.layers[i]!;\n      // @ts-expect-error - issue from original code\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode\n        ? // @ts-expect-error - issue from original code\n          index - 1\n        : // Proof Generation for Non-Bitcoin Trees\n          // @ts-expect-error - issue from original code\n          index + 1;\n\n      if (pairIndex < layer.length) {\n        proof.push({\n          data: layer[pairIndex],\n          position: isRightNode ? \"left\" : \"right\",\n        });\n      }\n\n      // set index to parent index\n      // @ts-expect-error - issue from original code\n      index = (index / 2) | 0;\n    }\n\n    // @ts-expect-error - issue from original code\n    return proof;\n  }\n}\n","import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  isNativeTokenAddress,\n  ZERO_ADDRESS,\n} from \"../../../constants/addresses.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { MerkleTree } from \"../../../merkletree/MerkleTree.js\";\nimport { download } from \"../../../storage/download.js\";\nimport type { Address } from \"../../address.js\";\nimport type { Hex } from \"../../encoding/hex.js\";\nimport { convertQuantity } from \"./convert-quantity.js\";\nimport { hashEntry } from \"./hash-entry.js\";\nimport type {\n  OverrideEntry,\n  OverrideProof,\n  ShardData,\n  ShardedMerkleTreeInfo,\n} from \"./types.js\";\n\nexport async function fetchProofsForClaimer(options: {\n  contract: ThirdwebContract;\n  claimer: string;\n  merkleTreeUri: string;\n  tokenDecimals: number;\n  hashEntry?: (options: {\n    entry: OverrideEntry;\n    chain: Chain;\n    client: ThirdwebClient;\n    tokenDecimals: number;\n  }) => Promise<Hex>;\n}): Promise<OverrideProof | null> {\n  const { contract, merkleTreeUri, claimer } = options;\n  const hashEntryFn = options.hashEntry || hashEntry;\n\n  // 2. download snapshot data\n  const response = await download({\n    client: contract.client,\n    uri: merkleTreeUri,\n  });\n  const merkleInfo: ShardedMerkleTreeInfo = await response.json();\n\n  // 3. download shard data based off the user address\n  const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();\n  const uri = merkleInfo.baseUri.endsWith(\"/\")\n    ? merkleInfo.baseUri\n    : `${merkleInfo.baseUri}/`;\n  let shardData: ShardData;\n\n  try {\n    const constructedShardUri = `${uri}${shardId}.json`;\n    const shard = await download({\n      client: contract.client,\n      uri: constructedShardUri,\n    });\n    shardData = await shard.json();\n  } catch {\n    // if the file can't be fetched it means claimer not in merkle tree\n    return null;\n  }\n\n  // 4. hash all the entries in that shard and construct the sub merkle tree\n  const hashedEntries = await Promise.all(\n    shardData.entries.map(async (entry) => {\n      return hashEntryFn({\n        chain: contract.chain,\n        client: contract.client,\n        entry,\n        tokenDecimals: options.tokenDecimals,\n      });\n    }),\n  );\n  // 5. get the proof for the claimer + the sub merkle tree root\n  const tree = new MerkleTree(hashedEntries);\n  const entry = shardData.entries.find(\n    (i) => i.address.toLowerCase() === claimer.toLowerCase(),\n  );\n  if (!entry) {\n    return null;\n  }\n  const proof = tree\n    .getHexProof(\n      await hashEntryFn({\n        chain: contract.chain,\n        client: contract.client,\n        entry,\n        tokenDecimals: options.tokenDecimals,\n      }),\n    )\n    .concat(shardData.proofs);\n  // 6. return the proof and the entry data for the contract call\n  const currencyAddress = (entry.currencyAddress || ZERO_ADDRESS) as Address;\n  const currencyDecimals = await (async () => {\n    if (\n      isNativeTokenAddress(currencyAddress) ||\n      currencyAddress === ZERO_ADDRESS\n    ) {\n      return 18;\n    }\n    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([\n      import(\"../../../contract/contract.js\"),\n      import(\"../../../extensions/erc20/read/decimals.js\"),\n    ]);\n    const currencyContract = getContract({\n      address: currencyAddress,\n      chain: contract.chain,\n      client: contract.client,\n    });\n    return await getDecimals({ contract: currencyContract });\n  })();\n\n  return {\n    currency: currencyAddress,\n    pricePerToken: convertQuantity({\n      quantity: entry.price || \"unlimited\",\n      tokenDecimals: currencyDecimals,\n    }),\n    proof,\n    quantityLimitPerWallet: convertQuantity({\n      quantity: entry.maxClaimable || \"unlimited\",\n      tokenDecimals: options.tokenDecimals,\n    }),\n  };\n}\n","import { maxUint256 } from \"ox/Solidity\";\nimport { toUnits } from \"../../units.js\";\n\nexport function convertQuantity(options: {\n  quantity: string;\n  tokenDecimals: number;\n}) {\n  const { quantity, tokenDecimals } = options;\n  if (quantity === \"unlimited\") {\n    return maxUint256;\n  }\n  return toUnits(quantity, tokenDecimals);\n}\n","import { encodePacked } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  isNativeTokenAddress,\n  ZERO_ADDRESS,\n} from \"../../../constants/addresses.js\";\nimport { getAddress } from \"../../address.js\";\nimport { keccak256 } from \"../../hashing/keccak256.js\";\nimport { convertQuantity } from \"./convert-quantity.js\";\nimport type { OverrideEntry } from \"./types.js\";\n\nexport async function hashEntry(options: {\n  entry: OverrideEntry;\n  chain: Chain;\n  client: ThirdwebClient;\n  tokenDecimals: number;\n}) {\n  const currencyAddress = options.entry.currencyAddress || ZERO_ADDRESS;\n  const currencyDecimals = await (async () => {\n    if (\n      isNativeTokenAddress(currencyAddress) ||\n      currencyAddress === ZERO_ADDRESS\n    ) {\n      return 18;\n    }\n    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([\n      import(\"../../../contract/contract.js\"),\n      import(\"../../../extensions/erc20/read/decimals.js\"),\n    ]);\n    const currencyContract = getContract({\n      address: currencyAddress,\n      chain: options.chain,\n      client: options.client,\n    });\n    return await getDecimals({ contract: currencyContract });\n  })();\n\n  return keccak256(\n    encodePacked(\n      [\"address\", \"uint256\", \"uint256\", \"address\"],\n      [\n        getAddress(options.entry.address),\n        convertQuantity({\n          quantity: options.entry.maxClaimable || \"unlimited\",\n          tokenDecimals: options.tokenDecimals,\n        }),\n        convertQuantity({\n          quantity: options.entry.price || \"unlimited\",\n          tokenDecimals: currencyDecimals,\n        }),\n        getAddress(currencyAddress),\n      ],\n    ),\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,3,4]}