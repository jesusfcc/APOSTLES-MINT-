{"version":3,"sources":["../../../../node_modules/thirdweb/src/rpc/rpc.ts","../../../../node_modules/thirdweb/src/rpc/fetch-rpc.ts","../../../../node_modules/thirdweb/src/contract/contract.ts","../../../../node_modules/viem/utils/formatters/formatter.ts","../../../../node_modules/viem/utils/formatters/transaction.ts","../../../../node_modules/thirdweb/src/utils/any-evm/zksync/isZkSyncChain.ts","../../../../node_modules/thirdweb/src/reactive/store.ts","../../../../node_modules/next/src/server/route-modules/app-page/module.compiled.js","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts","../../../../node_modules/thirdweb/src/utils/storage/webStorage.ts","../../../../node_modules/thirdweb/src/wallets/smart/smart-wallet.ts","../../../../node_modules/thirdweb/src/analytics/track/connect.ts","../../../../node_modules/thirdweb/src/wallets/wallet-emitter.ts","../../../../node_modules/thirdweb/src/utils/tiny-emitter.ts","../../../../node_modules/thirdweb/src/contract/actions/get-bytecode.ts","../../../../node_modules/thirdweb/src/rpc/actions/eth_getCode.ts","../../../../node_modules/thirdweb/src/utils/bytecode/is-contract-deployed.ts","../../../../node_modules/thirdweb/src/wallets/ecosystem/is-ecosystem-wallet.ts","../../../../node_modules/thirdweb/src/wallets/smart/lib/constants.ts","../../../../node_modules/thirdweb/src/utils/sleep.ts","../../../../node_modules/viem/utils/formatters/log.ts","../../../../node_modules/viem/utils/formatters/transactionReceipt.ts","../../../../node_modules/thirdweb/src/transaction/actions/wait-for-tx-receipt.ts","../../../../node_modules/thirdweb/src/rpc/watchBlockNumber.ts","../../../../node_modules/thirdweb/src/rpc/actions/eth_blockNumber.ts","../../../../node_modules/thirdweb/src/rpc/actions/eth_getTransactionReceipt.ts","../../../../node_modules/thirdweb/src/wallets/smart/is-smart-wallet.ts","../../../../node_modules/thirdweb/src/utils/storage/walletStorage.ts","../../../../node_modules/thirdweb/src/utils/type-guards.ts","../../../../node_modules/thirdweb/src/wallets/manager/index.ts","../../../../node_modules/thirdweb/src/reactive/computedStore.ts","../../../../node_modules/thirdweb/src/reactive/effect.ts","../../../../node_modules/%40tanstack/query-core/src/mutation.ts","../../../../node_modules/thirdweb/src/react/core/providers/invalidateWalletBalance.ts","../../../../node_modules/thirdweb/src/react/core/providers/RootElementContext.tsx","../../../../node_modules/%40tanstack/query-core/build/modern/queryClient.js","../../../../node_modules/%40tanstack/query-core/build/modern/mutationCache.js","../../../../node_modules/%40tanstack/query-core/build/modern/infiniteQueryBehavior.js","../../../../node_modules/%40tanstack/query-core/build/modern/queryCache.js","../../../../node_modules/thirdweb/src/react/core/utils/structuralSharing.ts","../../../../node_modules/%40tanstack/query-core/src/mutationCache.ts","../../../../node_modules/thirdweb/src/react/web/providers/thirdweb-provider.tsx","../../../../node_modules/thirdweb/src/react/core/providers/thirdweb-provider.tsx","../../../../node_modules/%40tanstack/query-core/src/queryCache.ts","../../../../node_modules/%40tanstack/query-core/src/queryClient.ts","../../../../node_modules/thirdweb/src/transaction/types.ts","../../../../node_modules/%40tanstack/query-core/src/infiniteQueryBehavior.ts"],"sourcesContent":["import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport type { Chain } from \"../chains/types.js\";\nimport { getRpcUrlForChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { fetchRpc, fetchSingleRpc, type RpcRequest } from \"./fetch-rpc.js\";\n\nconst RPC_CLIENT_MAP = new WeakMap();\n\n/**\n * @internal\n */\nfunction getRpcClientMap(client: ThirdwebClient) {\n  if (RPC_CLIENT_MAP.has(client)) {\n    return RPC_CLIENT_MAP.get(client);\n  }\n  const rpcClientMap = new Map();\n  RPC_CLIENT_MAP.set(client, rpcClientMap);\n  return rpcClientMap;\n}\n\n/**\n * @internal\n */\nfunction rpcRequestKey(request: RpcRequest): string {\n  return `${request.method}:${stringify(request.params)}`;\n}\n\nconst DEFAULT_MAX_BATCH_SIZE = 100;\n// default to no timeout (next tick)\nconst DEFAULT_BATCH_TIMEOUT_MS = 0;\n\ntype RPCOptions = Readonly<{\n  client: ThirdwebClient;\n  chain: Chain;\n  config?: {\n    maxBatchSize?: number;\n    batchTimeoutMs?: number;\n    requestTimeoutMs?: number;\n  };\n}>;\n\n/**\n * Returns an RPC request that can be used to make JSON-RPC requests.\n * @param options - The RPC options.\n * @returns The RPC request function.\n * @rpc\n * @example\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { getRpcClient } from \"thirdweb/rpc\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const rpcRequest = getRpcClient({ client, chain: ethereum, });\n * const blockNumber = await rpcRequest({\n *  method: \"eth_blockNumber\",\n * });\n * ```\n */\nexport function getRpcClient(\n  options: RPCOptions,\n): EIP1193RequestFn<EIP1474Methods> {\n  const rpcClientMap = getRpcClientMap(options.client);\n  const rpcUrl = options.chain.rpc;\n\n  if (rpcClientMap.has(rpcUrl)) {\n    return rpcClientMap.get(rpcUrl) as EIP1193RequestFn<EIP1474Methods>;\n  }\n\n  const rpcClient: EIP1193RequestFn<EIP1474Methods> = (() => {\n    // we can do this upfront because it cannot change later\n    const rpcUrl = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client,\n    });\n\n    const batchSize =\n      // look at the direct options passed\n      options.config?.maxBatchSize ??\n      // look at the client options\n      options.client.config?.rpc?.maxBatchSize ??\n      // use defaults\n      DEFAULT_MAX_BATCH_SIZE;\n    const batchTimeoutMs =\n      // look at the direct options passed\n      options.config?.batchTimeoutMs ??\n      // look at the client options\n      options.client.config?.rpc?.batchTimeoutMs ??\n      DEFAULT_BATCH_TIMEOUT_MS;\n\n    // inflight requests\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    const inflightRequests = new Map<string, Promise<any>>();\n\n    let pendingBatch: Array<{\n      request: {\n        method: string;\n        params: unknown[];\n        id: number;\n        jsonrpc: \"2.0\";\n      };\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      resolve: (value: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      reject: (reason?: any) => void;\n      requestKey: string;\n    }> = [];\n    let pendingBatchTimeout: ReturnType<typeof setTimeout> | null = null;\n\n    /**\n     * Sends the pending batch of requests.\n     * @internal\n     */\n    function sendPendingBatch() {\n      // clear the timeout if any\n      if (pendingBatchTimeout) {\n        clearTimeout(pendingBatchTimeout);\n        pendingBatchTimeout = null;\n      }\n\n      // prepare the requests array (we know the size)\n      const requests = new Array(pendingBatch.length);\n      const activeBatch = pendingBatch.slice().map((inflight, index) => {\n        // assign the id to the request\n        inflight.request.id = index;\n        // also assign the jsonrpc version\n        inflight.request.jsonrpc = \"2.0\";\n        // assign the request to the requests array (so we don't have to map it again later)\n        requests[index] = inflight.request;\n        return inflight;\n      });\n      // reset pendingBatch to empty\n      pendingBatch = [];\n\n      fetchRpc(rpcUrl, options.client, {\n        requests,\n        requestTimeoutMs: options.config?.requestTimeoutMs,\n      })\n        .then((responses) => {\n          activeBatch.forEach((inflight, index) => {\n            // Handle the inflight request promise for each response.\n            const response = responses[index];\n\n            // No response.\n            if (!response) {\n              inflight.reject(\n                new Error(\n                  `RPC Error from ${rpcUrl}:\\nrequests: ${stringify(requests)}\\nresponses: ${stringify(responses)}`,\n                ),\n              );\n            }\n            // Response is an error or error string.\n            else if (response instanceof Error) {\n              inflight.reject(response);\n            } else if (\"error\" in response) {\n              inflight.reject(response.error);\n            } else if (typeof response === \"string\") {\n              inflight.reject(new Error(response));\n            }\n            // eth_subscription is not supported yet.\n            else if (response.method === \"eth_subscription\") {\n              inflight.reject(\"Subscriptions not supported yet\");\n            }\n            // Else return the successful response for the inflight request.\n            else {\n              inflight.resolve(response.result);\n            }\n          });\n        })\n        .catch((err) => {\n          // http call failed, reject all inflight requests\n          for (const inflight of activeBatch) {\n            inflight.reject(err);\n          }\n        })\n        .finally(() => {\n          // Clear the inflight requests map so any new requests are re-fetched.\n          inflightRequests.clear();\n        });\n    }\n\n    // shortcut everything if we do not need to batch\n    if (batchSize === 1) {\n      return async (request) => {\n        // we can hard-code the id and jsonrpc version\n        // we also mutate the request object here to avoid copying it\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        (request as any).id = 1;\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        (request as any).jsonrpc = \"2.0\";\n        const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {\n          request: request,\n          requestTimeoutMs: options.config?.requestTimeoutMs,\n        });\n\n        if (!rpcResponse) {\n          throw new Error(\"No response\");\n        }\n        if (\"error\" in rpcResponse) {\n          throw rpcResponse.error;\n        }\n        return rpcResponse.result;\n      };\n    }\n\n    return async (request) => {\n      const requestKey = rpcRequestKey(request);\n\n      // if the request for this key is already inflight, return the promise directly\n      if (inflightRequests.has(requestKey)) {\n        // biome-ignore lint/style/noNonNullAssertion: the `has` check ensures this is defined\n        return inflightRequests.get(requestKey)!;\n      }\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let resolve: (value: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let reject: (reason?: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      const promise = new Promise<any>((resolve_, reject_) => {\n        resolve = resolve_;\n        reject = reject_;\n      });\n      inflightRequests.set(requestKey, promise);\n      // @ts-expect-error - they *are* definitely assigned within the promise constructor\n      pendingBatch.push({ reject, request, requestKey, resolve });\n      if (batchSize > 1) {\n        // if there is no timeout, set one\n        if (!pendingBatchTimeout) {\n          pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);\n        }\n        // if the batch is full, send it\n        if (pendingBatch.length >= batchSize) {\n          sendPendingBatch();\n        }\n      } else {\n        sendPendingBatch();\n      }\n      return promise;\n    };\n  })();\n\n  rpcClientMap.set(rpcUrl, rpcClient);\n  return rpcClient as EIP1193RequestFn<EIP1474Methods>;\n}\n","import type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\n\nexport type RpcRequest = {\n  jsonrpc?: \"2.0\";\n  method: string;\n  params?: unknown;\n  id?: number;\n};\n\ntype FetchRpcOptions = {\n  requests: RpcRequest[];\n  requestTimeoutMs?: number;\n};\n\ntype SuccessResult<T> = {\n  method?: never;\n  result: T;\n  error?: never;\n};\ntype ErrorResult<T> = {\n  method?: never;\n  result?: never;\n  error: T;\n};\ntype Subscription<TResult, TError> = {\n  method: \"eth_subscription\";\n  error?: never;\n  result?: never;\n  params: {\n    subscription: string;\n  } & (\n    | {\n        result: TResult;\n        error?: never;\n      }\n    | {\n        result?: never;\n        error: TError;\n      }\n  );\n};\n\ntype RpcResponse<TResult = unknown, TError = unknown> = {\n  jsonrpc: `${number}`;\n  id: number;\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n);\n\n/**\n * @internal\n */\nexport async function fetchRpc(\n  rpcUrl: string,\n  client: ThirdwebClient,\n  options: FetchRpcOptions,\n): Promise<RpcResponse[]> {\n  const response = await getClientFetch(client)(rpcUrl, {\n    body: stringify(options.requests),\n    headers: {\n      ...client.config?.rpc?.fetch?.headers,\n      \"Content-Type\": \"application/json\",\n    },\n    keepalive: client.config?.rpc?.fetch?.keepalive,\n    method: \"POST\",\n    requestTimeoutMs:\n      options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,\n  });\n\n  if (!response.ok) {\n    const error = await response.text().catch(() => null);\n    throw new Error(\n      `RPC request failed with status ${response.status} - ${response.statusText}: ${error || \"unknown error\"}`,\n    );\n  }\n\n  return await response.json();\n}\n\ntype FetchSingleRpcOptions = {\n  request: RpcRequest;\n  requestTimeoutMs?: number;\n};\n\n/**\n * @internal\n */\nexport async function fetchSingleRpc(\n  rpcUrl: string,\n  client: ThirdwebClient,\n  options: FetchSingleRpcOptions,\n): Promise<RpcResponse> {\n  const response = await getClientFetch(client)(rpcUrl, {\n    body: stringify(options.request),\n    headers: {\n      ...(client.config?.rpc?.fetch?.headers || {}),\n      \"Content-Type\": \"application/json\",\n    },\n    keepalive: client.config?.rpc?.fetch?.keepalive,\n    method: \"POST\",\n    requestTimeoutMs:\n      options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,\n  });\n\n  if (!response.ok) {\n    const error = await response.text().catch(() => null);\n    throw new Error(\n      `RPC request failed with status ${response.status} - ${response.statusText}: ${error || \"unknown error\"}`,\n    );\n  }\n  return await response.json();\n}\n","import type { Abi } from \"abitype\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { type Address, isAddress } from \"../utils/address.js\";\n\n/**\n * @contract\n */\nexport type ContractOptions<\n  abi extends Abi = [],\n  address extends string = string,\n> = {\n  client: ThirdwebClient;\n  address: address;\n  chain: Chain;\n  readonly abi?: abi;\n};\n\n/**\n * @contract\n */\nexport type ThirdwebContract<\n  abi extends Abi = [],\n  address extends string = `0x${string}`,\n> = Readonly<ContractOptions<abi, address>>;\n\n/**\n * Creates a Thirdweb contract by combining the Thirdweb client and contract options.\n * @param options - The options for creating the contract.\n * @returns The Thirdweb contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const contract = getContract({\n *  client,\n *  chain: sepolia,\n *  address: \"0x123...\",\n *  // optional ABI\n *  abi: [...],\n * });\n * ```\n * @contract\n */\nexport function getContract<const abi extends Abi = []>(\n  options: ContractOptions<abi>,\n): ThirdwebContract<abi, Address> {\n  if (!options.client) {\n    throw new Error(\n      `getContract validation error - invalid client: ${options.client}`,\n    );\n  }\n  if (!isAddress(options.address)) {\n    throw new Error(\n      `getContract validation error - invalid address: ${options.address}`,\n    );\n  }\n  if (!options.chain || !options.chain.id) {\n    throw new Error(\n      `getContract validation error - invalid chain: ${options.chain}`,\n    );\n  }\n  return options as ThirdwebContract<abi, Address>;\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Prettify } from '../../types/utils.js'\n\nexport type DefineFormatterErrorType = ErrorType\n\nexport function defineFormatter<type extends string, parameters, returnType>(\n  type: type,\n  format: (args: parameters, action?: string | undefined) => returnType,\n) {\n  return <\n    parametersOverride,\n    returnTypeOverride,\n    exclude extends (keyof parameters | keyof parametersOverride)[] = [],\n  >({\n    exclude,\n    format: overrides,\n  }: {\n    exclude?: exclude | undefined\n    format: (\n      args: parametersOverride,\n      action?: string | undefined,\n    ) => returnTypeOverride\n  }) => {\n    return {\n      exclude,\n      format: (args: parametersOverride, action?: string | undefined) => {\n        const formatted = format(args as any, action)\n        if (exclude) {\n          for (const key of exclude) {\n            delete (formatted as any)[key]\n          }\n        }\n        return {\n          ...formatted,\n          ...overrides(args, action),\n        } as Prettify<returnTypeOverride> & {\n          [_key in exclude[number]]: never\n        }\n      },\n      type,\n    }\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { SignedAuthorizationList } from '../../types/authorization.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type {\n  Chain,\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcAuthorizationList, RpcTransaction } from '../../types/rpc.js'\nimport type { Transaction, TransactionType } from '../../types/transaction.js'\nimport type { ExactPartial, UnionLooseOmit } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\n\ntype TransactionPendingDependencies =\n  | 'blockHash'\n  | 'blockNumber'\n  | 'transactionIndex'\n\nexport type FormattedTransaction<\n  chain extends Chain | undefined = undefined,\n  blockTag extends BlockTag = BlockTag,\n  _FormatterReturnType = ExtractChainFormatterReturnType<\n    chain,\n    'transaction',\n    Transaction\n  >,\n  _ExcludedPendingDependencies extends string = TransactionPendingDependencies &\n    ExtractChainFormatterExclude<chain, 'transaction'>,\n> = UnionLooseOmit<_FormatterReturnType, TransactionPendingDependencies> & {\n  [_K in _ExcludedPendingDependencies]: never\n} & Pick<\n    Transaction<bigint, number, blockTag extends 'pending' ? true : false>,\n    TransactionPendingDependencies\n  >\n\nexport const transactionType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n  '0x3': 'eip4844',\n  '0x4': 'eip7702',\n} as const satisfies Record<Hex, TransactionType>\n\nexport type FormatTransactionErrorType = ErrorType\n\nexport function formatTransaction(\n  transaction: ExactPartial<RpcTransaction>,\n  _?: string | undefined,\n) {\n  const transaction_ = {\n    ...transaction,\n    blockHash: transaction.blockHash ? transaction.blockHash : null,\n    blockNumber: transaction.blockNumber\n      ? BigInt(transaction.blockNumber)\n      : null,\n    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,\n    gas: transaction.gas ? BigInt(transaction.gas) : undefined,\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,\n    maxFeePerBlobGas: transaction.maxFeePerBlobGas\n      ? BigInt(transaction.maxFeePerBlobGas)\n      : undefined,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? BigInt(transaction.maxFeePerGas)\n      : undefined,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? BigInt(transaction.maxPriorityFeePerGas)\n      : undefined,\n    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,\n    to: transaction.to ? transaction.to : null,\n    transactionIndex: transaction.transactionIndex\n      ? Number(transaction.transactionIndex)\n      : null,\n    type: transaction.type\n      ? (transactionType as any)[transaction.type]\n      : undefined,\n    typeHex: transaction.type ? transaction.type : undefined,\n    value: transaction.value ? BigInt(transaction.value) : undefined,\n    v: transaction.v ? BigInt(transaction.v) : undefined,\n  } as Transaction\n\n  if (transaction.authorizationList)\n    transaction_.authorizationList = formatAuthorizationList(\n      transaction.authorizationList,\n    )\n\n  transaction_.yParity = (() => {\n    // If `yParity` is provided, we will use it.\n    if (transaction.yParity) return Number(transaction.yParity)\n\n    // If no `yParity` provided, try derive from `v`.\n    if (typeof transaction_.v === 'bigint') {\n      if (transaction_.v === 0n || transaction_.v === 27n) return 0\n      if (transaction_.v === 1n || transaction_.v === 28n) return 1\n      if (transaction_.v >= 35n) return transaction_.v % 2n === 0n ? 1 : 0\n    }\n\n    return undefined\n  })()\n\n  if (transaction_.type === 'legacy') {\n    delete transaction_.accessList\n    delete transaction_.maxFeePerBlobGas\n    delete transaction_.maxFeePerGas\n    delete transaction_.maxPriorityFeePerGas\n    delete transaction_.yParity\n  }\n  if (transaction_.type === 'eip2930') {\n    delete transaction_.maxFeePerBlobGas\n    delete transaction_.maxFeePerGas\n    delete transaction_.maxPriorityFeePerGas\n  }\n  if (transaction_.type === 'eip1559') {\n    delete transaction_.maxFeePerBlobGas\n  }\n  return transaction_\n}\n\nexport type DefineTransactionErrorType = DefineFormatterErrorType | ErrorType\n\nexport const defineTransaction = /*#__PURE__*/ defineFormatter(\n  'transaction',\n  formatTransaction,\n)\n\n//////////////////////////////////////////////////////////////////////////////\n\nfunction formatAuthorizationList(\n  authorizationList: RpcAuthorizationList,\n): SignedAuthorizationList {\n  return authorizationList.map((authorization) => ({\n    address: (authorization as any).address,\n    chainId: Number(authorization.chainId),\n    nonce: Number(authorization.nonce),\n    r: authorization.r,\n    s: authorization.s,\n    yParity: Number(authorization.yParity),\n  })) as SignedAuthorizationList\n}\n","import type { Chain } from \"../../../chains/types.js\";\n\n/**\n * Checks whether the given chain is part of the zksync stack\n * @param chain\n * @chain\n */\nexport async function isZkSyncChain(chain: Chain) {\n  if (chain.id === 1337 || chain.id === 31337) {\n    return false;\n  }\n\n  // check known zksync chain-ids first\n  if (\n    chain.id === 324 ||\n    chain.id === 300 ||\n    chain.id === 302 ||\n    chain.id === 11124 ||\n    chain.id === 282 ||\n    chain.id === 388 ||\n    chain.id === 4654 ||\n    chain.id === 333271 ||\n    chain.id === 37111 ||\n    chain.id === 978658 ||\n    chain.id === 531050104 ||\n    chain.id === 4457845 ||\n    chain.id === 2741 ||\n    chain.id === 240 ||\n    chain.id === 555271 ||\n    chain.id === 61166 ||\n    chain.id === 555272\n  ) {\n    return true;\n  }\n\n  // fallback to checking the stack on rpc\n  try {\n    const { getChainMetadata } = await import(\"../../../chains/utils.js\");\n    const chainMetadata = await getChainMetadata(chain);\n    return chainMetadata.stackType === \"zksync_stack\";\n  } catch {\n    // If the network check fails, assume it's not a ZkSync chain\n    return false;\n  }\n}\n","export type Store<T> = {\n  getValue(): T;\n  setValue(newValue: T): void;\n  subscribe(listener: () => void): () => void;\n};\n\n/**\n * Create a reactive value store\n * @param initialValue - The initial value to store\n * @example\n * ```ts\n * const store = createStore(0);\n * ```\n * @returns A store object\n * @internal\n */\nexport function createStore<T>(initialValue: T): Store<T> {\n  type Listener = () => void;\n  const listeners = new Set<Listener>();\n\n  let value = initialValue;\n\n  const notify = () => {\n    for (const listener of listeners) {\n      listener();\n    }\n  };\n\n  return {\n    getValue() {\n      return value;\n    },\n    setValue(newValue: T) {\n      if (newValue === value) {\n        return;\n      }\n      value = newValue;\n      notify();\n    },\n    subscribe(listener: Listener) {\n      listeners.add(listener);\n      return () => {\n        listeners.delete(listener);\n      };\n    },\n  };\n}\n","if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxRuntime\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n","import type { AsyncStorage } from \"./AsyncStorage.js\";\n\nexport const webLocalStorage: AsyncStorage = {\n  async getItem(key: string) {\n    try {\n      if (typeof window !== \"undefined\" && window.localStorage) {\n        return localStorage.getItem(key);\n      }\n    } catch {\n      // ignore\n    }\n\n    return null;\n  },\n  async removeItem(key: string) {\n    if (typeof window !== \"undefined\" && window.localStorage) {\n      localStorage.removeItem(key);\n    }\n  },\n  async setItem(key: string, value: string) {\n    try {\n      if (typeof window !== \"undefined\" && window.localStorage) {\n        localStorage.setItem(key, value);\n      }\n    } catch {\n      // ignore\n    }\n  },\n};\n","import { trackConnect } from \"../../analytics/track/connect.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChainIfExists } from \"../../chains/utils.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { isContractDeployed } from \"../../utils/bytecode/is-contract-deployed.js\";\nimport type { Account, Wallet } from \"../interfaces/wallet.js\";\nimport { createWalletEmitter } from \"../wallet-emitter.js\";\nimport type { WalletConnectionOption } from \"../wallet-types.js\";\nimport { getDefaultAccountFactory } from \"./lib/constants.js\";\nimport type { SmartWalletOptions } from \"./types.js\";\n\n/**\n * Creates a ERC4337 smart wallet based on a admin account.\n *\n * Smart wallets are smart contract wallets that enable multiple benefits for users:\n *\n * - Sponsor gas fees for transactions\n * - Multiple owners\n * - Session keys\n * - Batch transactions\n * - Predictable addresses\n * - Programmable features\n *\n * [Learn more about account abstraction](https://portal.thirdweb.com/connect/account-abstraction/how-it-works)\n *\n * @param createOptions - The options for creating the wallet.\n * Refer to [SmartWalletCreationOptions](https://portal.thirdweb.com/references/typescript/v5/SmartWalletCreationOptions) for more details.\n * @returns The created smart wallet.\n * @example\n *\n * ## Connect to a smart wallet\n *\n * To connect to a smart wallet, you need to provide an admin account as the `personalAccount` option.\n *\n * Any wallet can be used as an admin account, including an in-app wallets.\n *\n * The `sponsorGas` option is used to enable sponsored gas for transactions automatically.\n *\n * ```ts\n * import { smartWallet, inAppWallet } from \"thirdweb/wallets\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { sendTransaction } from \"thirdweb\";\n *\n * const wallet = smartWallet({\n *  chain: sepolia,\n *  sponsorGas: true, // enable sponsored transactions\n * });\n *\n * // any wallet can be used as an admin account\n * // in this example we use an in-app wallet\n * const adminWallet = inAppWallet();\n * const personalAccount = await adminWallet.connect({\n *   client,\n *   chain: sepolia,\n *   strategy: \"google\",\n * });\n *\n * const smartAccount = await wallet.connect({\n *   client,\n *   personalAccount, // pass the admin account\n * });\n *\n * // sending sponsored transactions with the smartAccount\n * await sendTransaction({\n *   account: smartAccount,\n *   transaction,\n * });\n * ```\n *\n * ## Using a custom account factory\n *\n * You can pass a custom account factory to the `smartWallet` function to use a your own account factory.\n *\n * ```ts\n * import { smartWallet } from \"thirdweb/wallets\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const wallet = smartWallet({\n *  chain: sepolia,\n *  sponsorGas: true, // enable sponsored transactions\n *  factoryAddress: \"0x...\", // custom factory address\n * });\n * ```\n *\n * ## Using v0.7 Entrypoint\n *\n * Both v0.6 (default) and v0.7 ERC4337 Entrypoints are supported. To use the v0.7 Entrypoint, simply pass in a compatible account factory.\n *\n * You can use the predeployed `DEFAULT_ACCOUNT_FACTORY_V0_7` or deploy your own [AccountFactory  v0.7](https://thirdweb.com/thirdweb.eth/AccountFactory_0_7).\n *\n * ```ts\n * import { smartWallet, DEFAULT_ACCOUNT_FACTORY_V0_7 } from \"thirdweb/wallets/smart\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const wallet = smartWallet({\n *  chain: sepolia,\n *  sponsorGas: true, // enable sponsored transactions\n *  factoryAddress: DEFAULT_ACCOUNT_FACTORY_V0_7, // 0.7 factory address\n * });\n * ```\n *\n * ## Configuring the smart wallet\n *\n * You can pass options to the `smartWallet` function to configure the smart wallet.\n *\n * ```ts\n * import { smartWallet } from \"thirdweb/wallets\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const wallet = smartWallet({\n *  chain: sepolia,\n *  sponsorGas: true, // enable sponsored transactions\n *  factoryAddress: \"0x...\", // custom factory address\n *  overrides: {\n *    accountAddress: \"0x...\", // override account address\n *    accountSalt: \"0x...\", // override account salt\n *    entrypointAddress: \"0x...\", // override entrypoint address\n *    tokenPaymaster: TokenPaymaster.BASE_USDC, // enable erc20 paymaster\n *    bundlerUrl: \"https://...\", // override bundler url\n *    paymaster: (userOp) => { ... }, // override paymaster\n *    ...\n *  }\n * });\n * ```\n *\n * Refer to [SmartWalletOptions](https://portal.thirdweb.com/references/typescript/v5/SmartWalletOptions) for more details.\n *\n * @wallet\n */\nexport function smartWallet(\n  createOptions: SmartWalletOptions,\n): Wallet<\"smart\"> {\n  const emitter = createWalletEmitter<\"smart\">();\n  let account: Account | undefined;\n  let adminAccount: Account | undefined;\n  let chain: Chain | undefined;\n  let lastConnectOptions: WalletConnectionOption<\"smart\"> | undefined;\n\n  return {\n    autoConnect: async (options) => {\n      const { connectSmartAccount: connectSmartWallet } = await import(\n        \"./index.js\"\n      );\n      const [connectedAccount, connectedChain] = await connectSmartWallet(\n        options,\n        createOptions,\n      );\n      // set the states\n      lastConnectOptions = options;\n      account = connectedAccount;\n      chain = connectedChain;\n      trackConnect({\n        chainId: chain.id,\n        client: options.client,\n        walletAddress: account.address,\n        walletType: \"smart\",\n      });\n      // return account\n      return account;\n    },\n    connect: async (options) => {\n      const { connectSmartAccount } = await import(\"./index.js\");\n      const [connectedAccount, connectedChain] = await connectSmartAccount(\n        options,\n        createOptions,\n      );\n      // set the states\n      adminAccount = options.personalAccount;\n      lastConnectOptions = options;\n      account = connectedAccount;\n      chain = connectedChain;\n      trackConnect({\n        chainId: chain.id,\n        client: options.client,\n        walletAddress: account.address,\n        walletType: \"smart\",\n      });\n      // return account\n      emitter.emit(\"accountChanged\", account);\n      return account;\n    },\n    disconnect: async () => {\n      if (account) {\n        const { disconnectSmartAccount } = await import(\"./index.js\");\n        await disconnectSmartAccount(account);\n      }\n      account = undefined;\n      adminAccount = undefined;\n      chain = undefined;\n      emitter.emit(\"disconnect\", undefined);\n    },\n    getAccount: () => account,\n    getAdminAccount: () => adminAccount,\n    getChain() {\n      if (!chain) {\n        return undefined;\n      }\n\n      chain = getCachedChainIfExists(chain.id) || chain;\n      return chain;\n    },\n    getConfig: () => createOptions,\n    id: \"smart\",\n    subscribe: emitter.subscribe,\n    switchChain: async (newChain: Chain) => {\n      if (!lastConnectOptions) {\n        throw new Error(\"Cannot switch chain without a previous connection\");\n      }\n      const isZksyncChain = await isZkSyncChain(newChain);\n      if (!isZksyncChain) {\n        // check if factory is deployed\n        const factory = getContract({\n          address:\n            createOptions.factoryAddress ||\n            getDefaultAccountFactory(\n              createOptions.overrides?.entrypointAddress,\n            ),\n          chain: newChain,\n          client: lastConnectOptions.client,\n        });\n        const isDeployed = await isContractDeployed(factory);\n        if (!isDeployed) {\n          throw new Error(\n            `Factory contract not deployed on chain: ${newChain.id}`,\n          );\n        }\n      }\n      const { connectSmartAccount } = await import(\"./index.js\");\n      const [connectedAccount, connectedChain] = await connectSmartAccount(\n        { ...lastConnectOptions, chain: newChain },\n        { ...createOptions, chain: newChain },\n      );\n      // set the states\n      account = connectedAccount;\n      chain = connectedChain;\n      emitter.emit(\"accountChanged\", connectedAccount);\n      emitter.emit(\"chainChanged\", connectedChain);\n    },\n  };\n}\n","import type { ThirdwebClient } from \"../../client/client.js\";\nimport type { Ecosystem } from \"../../wallets/in-app/core/wallet/types.js\";\nimport { track } from \"./index.js\";\n\n/**\n * @internal\n */\nexport async function trackConnect(args: {\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n  walletType: string;\n  walletAddress: string;\n  chainId?: number;\n}) {\n  const { client, ecosystem, walletType, walletAddress, chainId } = args;\n  return track({\n    client,\n    data: {\n      action: \"connect\",\n      chainId,\n      source: \"connectWallet\",\n      walletAddress,\n      walletType,\n    },\n    ecosystem,\n  });\n}\n","import type { Chain } from \"../chains/types.js\";\nimport { createEmitter, type Emitter } from \"../utils/tiny-emitter.js\";\nimport type { Account } from \"./interfaces/wallet.js\";\nimport type { WalletAutoConnectionOption, WalletId } from \"./wallet-types.js\";\n\nexport type WalletEmitterEvents<TWalletId extends WalletId> = {\n  accountChanged: Account;\n  accountsChanged: string[];\n  disconnect?: never;\n  chainChanged: Chain;\n  onConnect: WalletAutoConnectionOption<TWalletId>;\n};\n\nexport type WalletEmitter<TWalletId extends WalletId> = Emitter<\n  WalletEmitterEvents<TWalletId>\n>;\n\n/**\n\n * @internal\n */\nexport function createWalletEmitter<const TWalletId extends WalletId>() {\n  return createEmitter<WalletEmitterEvents<TWalletId>>();\n}\n","type GenericEmitterType = {\n  [key: string]: unknown;\n};\n\nexport type Emitter<T extends GenericEmitterType> = {\n  subscribe<K extends keyof T>(event: K, cb: (data: T[K]) => void): () => void;\n  emit<K extends keyof T>(event: K, data: T[K]): void;\n};\n\n/**\n * Creates an emitter object that allows subscribing to events and emitting events.\n * @returns An emitter object with `subscribe` and `emit` methods.\n * @template TEmitter - The type of the emitter.\n * @example\n * ```ts\n * const emitter = createEmitter<{\n *  event1: string;\n * event2: number;\n * }>();\n *\n * emitter.subscribe(\"event1\", (data) => {\n * console.log(data); // \"hello\"\n * });\n *\n * emitter.emit(\"event1\", \"hello\");\n * ```\n */\nexport function createEmitter<\n  const TEmitter extends GenericEmitterType,\n>(): Emitter<TEmitter> {\n  const subsribers = new Map<\n    keyof TEmitter,\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    Set<(data: any) => void>\n  >();\n\n  return {\n    emit(event, data) {\n      const subscribers = subsribers.get(event);\n      if (subscribers) {\n        for (const cb of subscribers) {\n          cb(data);\n        }\n      }\n    },\n    subscribe(event, cb) {\n      if (!subsribers.has(event)) {\n        subsribers.set(event, new Set([cb]));\n      } else {\n        subsribers.get(event)?.add(cb);\n      }\n\n      return () => {\n        const subscribers = subsribers.get(event);\n        if (subscribers) {\n          subscribers.delete(cb);\n        }\n      };\n    },\n  };\n}\n","import { eth_getCode } from \"../../rpc/actions/eth_getCode.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../contract.js\";\n\nconst BYTECODE_CACHE = new WeakMap<ThirdwebContract, Promise<Hex>>();\n\n/**\n * Retrieves the bytecode of a contract.\n * @param contract - The ThirdwebContract instance.\n * @returns A Promise that resolves to the bytecode of the contract.\n * @example\n * ```ts\n * import { getBytecode } from \"thirdweb/contract\";\n * const bytecode = await getBytecode(contract);\n * ```\n * @contract\n */\nexport function getBytecode(contract: ThirdwebContract): Promise<Hex> {\n  if (BYTECODE_CACHE.has(contract)) {\n    return BYTECODE_CACHE.get(contract) as Promise<Hex>;\n  }\n\n  const prom = (async () => {\n    const rpcRequest = getRpcClient(contract);\n    const result = await eth_getCode(rpcRequest, {\n      address: contract.address,\n      blockTag: \"latest\",\n    });\n    if (result === \"0x\") {\n      BYTECODE_CACHE.delete(contract);\n    }\n    return result;\n  })();\n  BYTECODE_CACHE.set(contract, prom);\n  return prom;\n}\n","import type { Address } from \"abitype\";\nimport type { BlockTag, EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\n\ntype GetCodeParams = {\n  address: Address;\n  blockTag?: BlockTag;\n};\n\n/**\n * Retrieves the bytecode of a smart contract at the specified address.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the eth_getCode method.\n * @returns A promise that resolves to the bytecode of the smart contract.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getCode } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const bytecode = await eth_getCode(rpcRequest, {\n *  address: \"0x...\",\n * });\n * ```\n */\nexport async function eth_getCode(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetCodeParams,\n): Promise<Hex> {\n  return request({\n    method: \"eth_getCode\",\n    params: [params.address as Hex, params.blockTag || \"latest\"],\n  });\n}\n","import { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\n\n// we use a weak set to cache *if* a contract *is* deployed\n// aka: we add it to this set if it's deployed, and only if it is deployed\n// instead of using a map with: true only (because we only want to cache if it's deployed)\nconst cache = new WeakSet<ThirdwebContract>();\n\n/**\n * Checks if a contract is deployed by verifying its bytecode.\n * @param contract - The contract to check.\n * @returns A promise that resolves to a boolean indicating whether the contract is deployed or not.\n * @example\n * ```ts\n * import { getContract } from \"thirdweb/contract\";\n * import { isContractDeployed } from \"thirdweb/contract/utils\";\n *\n * const contract = getContract({ ... });\n * const isDeployed = await isContractDeployed(contract);\n * console.log(isDeployed);\n * ```\n * @contract\n */\nexport async function isContractDeployed(\n  contract: ThirdwebContract,\n): Promise<boolean> {\n  if (cache.has(contract)) {\n    // it's only in there if it's deployed\n    return true;\n  }\n  // this already dedupes requests for the same contract\n  const bytecode = await getBytecode(contract);\n  const isDeployed = bytecode !== \"0x\";\n  // if it's deployed, we add it to the cache\n  if (isDeployed) {\n    cache.add(contract);\n  }\n  return isDeployed;\n}\n","import type { Wallet } from \"../interfaces/wallet.js\";\nimport type { EcosystemWalletId } from \"../wallet-types.js\";\n\nexport function isEcosystemWallet(\n  wallet: Wallet,\n): wallet is Wallet<EcosystemWalletId>;\n\nexport function isEcosystemWallet(wallet: string): wallet is EcosystemWalletId;\n\n/**\n * Checks if the given wallet is an ecosystem wallet.\n *\n * @param {Wallet | string} wallet - The wallet or wallet ID to check.\n * @returns {boolean} True if the wallet is an ecosystem wallet, false otherwise.\n * @internal\n */\nexport function isEcosystemWallet(\n  wallet: Wallet | string,\n): wallet is Wallet<EcosystemWalletId> {\n  return typeof wallet === \"string\"\n    ? wallet.startsWith(\"ecosystem.\")\n    : wallet.id.startsWith(\"ecosystem.\");\n}\n","import type { Chain } from \"../../../chains/types.js\";\nimport { getAddress } from \"../../../utils/address.js\";\nimport { getThirdwebDomains } from \"../../../utils/domains.js\";\nimport type { TokenPaymasterConfig } from \"../types.js\";\n\nexport const DUMMY_SIGNATURE =\n  \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n\nexport const DEFAULT_ACCOUNT_FACTORY_V0_6 =\n  \"0x85e23b94e7F5E9cC1fF78BCe78cfb15B81f0DF00\";\nexport const DEFAULT_ACCOUNT_FACTORY_V0_7 =\n  \"0x4be0ddfebca9a5a4a617dee4dece99e7c862dceb\";\n\nexport const ENTRYPOINT_ADDRESS_v0_6 =\n  \"0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789\"; // v0.6\nexport const ENTRYPOINT_ADDRESS_v0_7 =\n  \"0x0000000071727De22E5E9d8BAf0edAc6f37da032\"; // v0.7\n\nexport const MANAGED_ACCOUNT_GAS_BUFFER = 50000n;\n\ntype PAYMASTERS = \"BASE_USDC\" | \"CELO_CUSD\" | \"LISK_LSK\";\nexport const TokenPaymaster: Record<PAYMASTERS, TokenPaymasterConfig> = {\n  BASE_USDC: {\n    balanceStorageSlot: 9n,\n    chainId: 8453,\n    paymasterAddress: \"0x2222f2738BE6bB7aA0Bfe4AEeAf2908172CF5539\",\n    tokenAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n  },\n  CELO_CUSD: {\n    balanceStorageSlot: 9n,\n    chainId: 42220,\n    paymasterAddress: \"0x3feA3c5744D715ff46e91C4e5C9a94426DfF2aF9\",\n    tokenAddress: \"0x765DE816845861e75A25fCA122bb6898B8B1282a\",\n  },\n  LISK_LSK: {\n    balanceStorageSlot: 9n,\n    chainId: 1135,\n    paymasterAddress: \"0x9eb8cf7fBa5ed9EeDCC97a0d52254cc0e9B1AC25\",\n    tokenAddress: \"0xac485391EB2d7D88253a7F1eF18C37f4242D1A24\",\n  },\n};\n\n/*\n * @internal\n */\nexport const getDefaultAccountFactory = (entryPointAddress?: string) => {\n  const version = getEntryPointVersion(\n    entryPointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n  if (version === \"v0.7\") {\n    return DEFAULT_ACCOUNT_FACTORY_V0_7;\n  }\n  return DEFAULT_ACCOUNT_FACTORY_V0_6;\n};\n\n/**\n * @internal\n */\nexport const getDefaultBundlerUrl = (chain: Chain) => {\n  const domain = getThirdwebDomains().bundler;\n  if (domain.startsWith(\"localhost:\")) {\n    return `http://${domain}/v2?chain=${chain.id}`;\n  }\n  return `https://${chain.id}.${domain}/v2`;\n};\n\nexport const getEntryPointVersion = (address: string): \"v0.6\" | \"v0.7\" => {\n  const checksummedAddress = getAddress(address);\n  if (checksummedAddress === ENTRYPOINT_ADDRESS_v0_6) {\n    return \"v0.6\";\n  }\n  if (checksummedAddress === ENTRYPOINT_ADDRESS_v0_7) {\n    return \"v0.7\";\n  }\n  throw new Error(\"Unknown paymaster version\");\n};\n","/**\n * Delay an async thread\n * @param ms Sleep time in millisecond\n * @internal\n */\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport type { ExactPartial } from '../../types/utils.js'\n\nexport type FormatLogErrorType = ErrorType\n\nexport function formatLog(\n  log: ExactPartial<RpcLog>,\n  {\n    args,\n    eventName,\n  }: { args?: unknown | undefined; eventName?: string | undefined } = {},\n) {\n  return {\n    ...log,\n    blockHash: log.blockHash ? log.blockHash : null,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\n    transactionHash: log.transactionHash ? log.transactionHash : null,\n    transactionIndex: log.transactionIndex\n      ? Number(log.transactionIndex)\n      : null,\n    ...(eventName ? { args, eventName } : {}),\n  } as Log\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  Chain,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { TransactionReceipt } from '../../types/transaction.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { formatLog } from './log.js'\nimport { transactionType } from './transaction.js'\n\nexport type FormattedTransactionReceipt<\n  chain extends Chain | undefined = undefined,\n> = ExtractChainFormatterReturnType<\n  chain,\n  'transactionReceipt',\n  TransactionReceipt\n>\n\nexport const receiptStatuses = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\nexport type FormatTransactionReceiptErrorType = ErrorType\n\nexport function formatTransactionReceipt(\n  transactionReceipt: ExactPartial<RpcTransactionReceipt>,\n  _?: string | undefined,\n) {\n  const receipt = {\n    ...transactionReceipt,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs\n      ? transactionReceipt.logs.map((log) => formatLog(log))\n      : null,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex\n      ? hexToNumber(transactionReceipt.transactionIndex)\n      : null,\n    status: transactionReceipt.status\n      ? receiptStatuses[transactionReceipt.status]\n      : null,\n    type: transactionReceipt.type\n      ? transactionType[\n          transactionReceipt.type as keyof typeof transactionType\n        ] || transactionReceipt.type\n      : null,\n  } as TransactionReceipt\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice)\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed)\n\n  return receipt\n}\n\nexport type DefineTransactionReceiptErrorType =\n  | DefineFormatterErrorType\n  | ErrorType\n\nexport const defineTransactionReceipt = /*#__PURE__*/ defineFormatter(\n  'transactionReceipt',\n  formatTransactionReceipt,\n)\n","import type { Hex } from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { eth_getTransactionReceipt } from \"../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { SendTransactionResult, TransactionReceipt } from \"../types.js\";\n\nconst DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;\n\nconst map = new Map<string, Promise<TransactionReceipt>>();\n\nexport type WaitForReceiptOptions = Prettify<\n  SendTransactionResult & {\n    client: ThirdwebClient;\n    chain: Chain;\n    maxBlocksWaitTime?: number;\n  }\n>;\n\n/**\n * Waits for the transaction receipt of a given transaction hash on a specific contract.\n * @param options - The options for waiting for the receipt.\n * By default, it's 100 blocks.\n * @returns A promise that resolves with the transaction receipt.\n * @transaction\n * @example\n * ```ts\n * import { waitForReceipt } from \"thirdweb\";\n * const receipt = await waitForReceipt({\n *   client,\n *   chain,\n *   transactionHash: \"0x123...\",\n * });\n * ```\n */\nexport function waitForReceipt(\n  options: WaitForReceiptOptions,\n): Promise<TransactionReceipt> {\n  const { transactionHash, chain, client } = options;\n\n  const chainId = chain.id;\n  const key = `${chainId}:tx_${transactionHash}`;\n  const maxBlocksWaitTime =\n    options.maxBlocksWaitTime ?? DEFAULT_MAX_BLOCKS_WAIT_TIME;\n\n  if (map.has(key)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return map.get(key)!;\n  }\n  const promise = new Promise<TransactionReceipt>((resolve, reject) => {\n    if (!transactionHash) {\n      reject(\n        new Error(\n          \"Transaction has no transactionHash to wait for, did you execute it?\",\n        ),\n      );\n    }\n\n    const request = getRpcClient({ chain, client });\n\n    // start at -1 because the first block doesn't count\n    let blocksWaited = -1;\n\n    const unwatch = watchBlockNumber({\n      chain: chain,\n      client: client,\n      onNewBlockNumber: async () => {\n        blocksWaited++;\n        if (blocksWaited >= maxBlocksWaitTime) {\n          unwatch();\n          reject(\n            new Error(\n              `Transaction receipt for ${transactionHash} not found after ${maxBlocksWaitTime} blocks`,\n            ),\n          );\n          return;\n        }\n        try {\n          const receipt = await eth_getTransactionReceipt(request, {\n            hash: transactionHash as Hex,\n          });\n\n          // stop the polling\n          unwatch();\n          // resolve the top level promise with the receipt\n          resolve(receipt);\n        } catch {\n          // noop, we'll try again on the next blocks\n        }\n      },\n    });\n    // remove the promise from the map when it's done (one way or the other)\n  }).finally(() => {\n    map.delete(key);\n  });\n\n  map.set(key, promise);\n  return promise;\n}\n","import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { sleep } from \"../utils/sleep.js\";\nimport { eth_blockNumber } from \"./actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"./rpc.js\";\n\nconst MAX_POLL_DELAY = 5000; // 5 seconds\nconst DEFAULT_POLL_DELAY = 1000; // 1 second\nconst MIN_POLL_DELAY = 500; // 500 milliseconds\nconst DEFAULT_OVERPOLL_RATIO = 2; // poll twice as often as the average block time by default\n\nconst SLIDING_WINDOW_SIZE = 10; // always keep track of the last 10 block times\n\n/**\n * TODO: document\n * @internal\n */\nfunction getAverageBlockTime(blockTimes: number[]): number {\n  // left-pad the blocktimes Array with the DEFAULT_POLL_DELAY\n  while (blockTimes.length < SLIDING_WINDOW_SIZE) {\n    blockTimes.unshift(DEFAULT_POLL_DELAY);\n  }\n\n  const sum = blockTimes.reduce((acc, blockTime) => acc + blockTime, 0);\n  return sum / blockTimes.length;\n}\n\n/**\n * TODO: document\n * @internal\n */\nfunction createBlockNumberPoller(\n  client: ThirdwebClient,\n  chain: Chain,\n  overPollRatio?: number,\n  onError?: (error: Error) => void,\n) {\n  let subscribers: Array<(blockNumber: bigint) => void> = [];\n  let blockTimesWindow: number[] = [];\n\n  let isActive = false;\n  let lastBlockNumber: bigint | undefined;\n  let lastBlockAt: number | undefined;\n\n  const rpcRequest = getRpcClient({ chain, client });\n\n  /**\n   * TODO: document\n   * @internal\n   */\n  async function poll() {\n    // stop polling if there are no more subscriptions\n    if (!isActive) {\n      return;\n    }\n\n    try {\n      const blockNumber = await eth_blockNumber(rpcRequest);\n\n      if (!lastBlockNumber || blockNumber > lastBlockNumber) {\n        let newBlockNumbers = [];\n        if (lastBlockNumber) {\n          for (let i = lastBlockNumber + 1n; i <= blockNumber; i++) {\n            newBlockNumbers.push(BigInt(i));\n          }\n        } else {\n          newBlockNumbers = [blockNumber];\n        }\n        lastBlockNumber = blockNumber;\n        const currentTime = Date.now();\n        if (lastBlockAt) {\n          // if we skipped a block we need to adjust the block time down to that level\n          const blockTime =\n            (currentTime - lastBlockAt) / newBlockNumbers.length;\n\n          blockTimesWindow.push(blockTime);\n          blockTimesWindow = blockTimesWindow.slice(-SLIDING_WINDOW_SIZE);\n        }\n        lastBlockAt = currentTime;\n        // for all new blockNumbers...\n        for (const b of newBlockNumbers) {\n          // ... call all current subscribers\n          for (const subscriberCallback of subscribers) {\n            subscriberCallback(b);\n          }\n        }\n      }\n    } catch (err: unknown) {\n      if (onError) {\n        onError(err as Error);\n      } else {\n        console.error(\n          `[watchBlockNumber]: Failed to poll for latest block number: ${err}`,\n        );\n      }\n    }\n\n    const currentApproximateBlockTime = getAverageBlockTime(blockTimesWindow);\n\n    // make sure we never poll faster than our minimum poll delay or slower than our maximum poll delay\n    const pollDelay = Math.max(\n      MIN_POLL_DELAY,\n      Math.min(\n        MAX_POLL_DELAY,\n        Math.max(MIN_POLL_DELAY, currentApproximateBlockTime),\n      ),\n    );\n\n    // sleep for the pollDelay for this chain (divided by the overPollRatio, which defaults to 2)\n    await sleep(pollDelay / (overPollRatio ?? DEFAULT_OVERPOLL_RATIO));\n    // poll again\n    poll();\n  }\n\n  // return the \"subscribe\" function\n  return function subscribe(\n    callBack: (blockNumber: bigint) => void,\n    initialBlockNumber?: bigint,\n  ) {\n    subscribers.push(callBack);\n    // if we are currently not active -> start polling\n    if (!isActive) {\n      lastBlockNumber = initialBlockNumber;\n      isActive = true;\n      poll();\n    }\n\n    // return the \"unsubscribe\" function (meaning the caller can unsubscribe)\n    return function unSubscribe() {\n      // filter out the callback from the subscribers\n      subscribers = subscribers.filter((fn) => fn !== callBack);\n      // if the new subscribers Array is empty (aka we were the last subscriber) -> stop polling\n      if (subscribers.length === 0) {\n        lastBlockNumber = undefined;\n        lastBlockAt = undefined;\n        isActive = false;\n      }\n    };\n  };\n}\n\nconst existingPollers = new Map<\n  number,\n  ReturnType<typeof createBlockNumberPoller>\n>();\n\nexport type WatchBlockNumberOptions = {\n  client: ThirdwebClient;\n  chain: Chain;\n  onNewBlockNumber: (blockNumber: bigint) => void;\n  onError?: (error: Error) => void;\n  overPollRatio?: number;\n  latestBlockNumber?: bigint;\n};\n\n/**\n * Watches the block number for a specific chain.\n * @param opts - The options for watching the block number.\n * @returns The unwatch function.\n * @example\n * ```ts\n * import { watchBlockNumber } from \"thirdweb\";\n * const unwatch = watchBlockNumber({\n *  client,\n *  chainId,\n *  onNewBlockNumber: (blockNumber) => {\n *    // do something with the block number\n *  },\n *  onError: (err) => {\n *    // do something if getting the block number fails\n *  },\n * });\n *\n * // later stop watching\n * unwatch();\n * ```\n * @rpc\n */\nexport function watchBlockNumber(opts: WatchBlockNumberOptions) {\n  const {\n    client,\n    chain,\n    onNewBlockNumber,\n    overPollRatio,\n    latestBlockNumber,\n    onError,\n  } = opts;\n  const chainId = chain.id;\n  // if we already have a poller for this chainId -> use it.\n  let poller = existingPollers.get(chainId);\n  // otherwise create a new poller\n  if (!poller) {\n    poller = createBlockNumberPoller(client, chain, overPollRatio, onError);\n    // and store it for later use\n    existingPollers.set(chainId, poller);\n  }\n  // subscribe to the poller and return the unSubscribe function to the caller\n  return poller(onNewBlockNumber, latestBlockNumber);\n}\n","import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the current block number from the Ethereum blockchain.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to the current block number as a bigint.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_blockNumber } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const blockNumber = await eth_blockNumber(rpcRequest);\n * ```\n */\nexport async function eth_blockNumber(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const blockNumberHex = await request({\n    method: \"eth_blockNumber\",\n  });\n  return hexToBigInt(blockNumberHex);\n}\n","import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  formatTransactionReceipt,\n  type GetTransactionReceiptParameters,\n  type TransactionReceipt,\n} from \"viem\";\n\n/**\n * Retrieves the transaction receipt for a given transaction hash.\n * Throws an error if the receipt is not found.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the transaction receipt.\n * @returns A promise that resolves to the transaction receipt.\n * @throws An error if the transaction receipt is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getTransactionReceipt } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionReceipt = await eth_getTransactionReceipt(rpcRequest, {\n *  hash: \"0x...\",\n * });\n * ```\n */\nexport async function eth_getTransactionReceipt(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetTransactionReceiptParameters,\n): Promise<TransactionReceipt> {\n  const receipt = await request({\n    method: \"eth_getTransactionReceipt\",\n    params: [params.hash],\n  });\n\n  if (!receipt) {\n    throw new Error(\"Transaction receipt not found.\");\n  }\n\n  return formatTransactionReceipt(receipt);\n}\n","import { isEcosystemWallet } from \"../ecosystem/is-ecosystem-wallet.js\";\nimport type { Wallet } from \"../interfaces/wallet.js\";\n\n/**\n * Checks if the given wallet is a smart wallet.\n *\n * @param {Wallet} wallet - The wallet to check.\n * @returns {boolean} True if the wallet is a smart wallet, false otherwise.\n * @internal\n */\nexport function isSmartWallet(activeWallet?: Wallet): boolean {\n  if (!activeWallet) {\n    return false;\n  }\n\n  if (activeWallet.id === \"smart\") {\n    return true;\n  }\n\n  if (activeWallet.id === \"inApp\" || isEcosystemWallet(activeWallet)) {\n    const options = (activeWallet as Wallet<\"inApp\">).getConfig();\n    if (options && \"smartAccount\" in options && options.smartAccount) {\n      return true;\n    }\n    if (options?.executionMode) {\n      const execMode = options.executionMode;\n      return execMode.mode === \"EIP4337\" || execMode.mode === \"EIP7702\";\n    }\n  }\n  return false;\n}\n\n/**\n * @internal\n */\nexport function hasSponsoredTransactionsEnabled(wallet: Wallet | undefined) {\n  if (!wallet) {\n    return false;\n  }\n  let sponsoredTransactionsEnabled = false;\n  if (wallet && wallet.id === \"smart\") {\n    const options = (wallet as Wallet<\"smart\">).getConfig();\n    if (\"sponsorGas\" in options) {\n      sponsoredTransactionsEnabled = options.sponsorGas;\n    }\n    if (\"gasless\" in options) {\n      sponsoredTransactionsEnabled = options.gasless;\n    }\n  }\n  if (wallet && (wallet.id === \"inApp\" || isEcosystemWallet(wallet))) {\n    const options = (wallet as Wallet<\"inApp\">).getConfig();\n    if (options && \"smartAccount\" in options && options.smartAccount) {\n      const smartOptions = options.smartAccount;\n      if (\"sponsorGas\" in smartOptions) {\n        sponsoredTransactionsEnabled = smartOptions.sponsorGas;\n      }\n      if (\"gasless\" in smartOptions) {\n        sponsoredTransactionsEnabled = smartOptions.gasless;\n      }\n    }\n    if (options?.executionMode) {\n      const execMode = options.executionMode;\n      if (execMode.mode === \"EIP4337\") {\n        const smartOptions = execMode.smartAccount;\n        if (smartOptions && \"sponsorGas\" in smartOptions) {\n          sponsoredTransactionsEnabled = smartOptions.sponsorGas;\n        }\n        if (smartOptions && \"gasless\" in smartOptions) {\n          sponsoredTransactionsEnabled = smartOptions.gasless;\n        }\n      }\n      if (execMode.mode === \"EIP7702\") {\n        sponsoredTransactionsEnabled = execMode.sponsorGas || false;\n      }\n    }\n  }\n  return sponsoredTransactionsEnabled;\n}\n","import { stringify } from \"../json.js\";\nimport type { AsyncStorage } from \"./AsyncStorage.js\";\n\nconst CONNECT_PARAMS_MAP_KEY = \"tw:connected-wallet-params\";\n\n/**\n * Save the connection params to storage for given wallet id\n * It saves an object with wallet id as key and params as value to storage on CONNECT_PARAMS_MAP_KEY\n * CONNECT_PARAMS_MAP_KEY: { walletId1: walletId1Params, walletId2: walletId2Params, ... }\n *\n * @param walletId\n * @param params\n * @internal\n */\nexport async function saveConnectParamsToStorage<T extends object>(\n  storage: AsyncStorage,\n  walletId: string,\n  params: T,\n) {\n  // params must be stringifiable\n  if (!isStringifiable(params)) {\n    throw new Error(\"given params are not stringifiable\");\n  }\n\n  const currentValueStr = await storage.getItem(CONNECT_PARAMS_MAP_KEY);\n\n  let value: Record<string, T>;\n\n  if (currentValueStr) {\n    try {\n      value = JSON.parse(currentValueStr);\n    } catch {\n      value = {};\n    }\n\n    value[walletId] = params;\n  } else {\n    value = {\n      [walletId]: params,\n    };\n  }\n\n  storage.setItem(CONNECT_PARAMS_MAP_KEY, stringify(value));\n}\n\n/**\n * Save the connection params to storage for given wallet id\n * It saves an object with wallet id as key and params as value to storage on CONNECT_PARAMS_MAP_KEY\n * CONNECT_PARAMS_MAP_KEY: { walletId1: walletId1Params, walletId2: walletId2Params, ... }\n *\n * @param walletId\n * @param params\n * @internal\n */\nexport async function deleteConnectParamsFromStorage(\n  storage: AsyncStorage,\n  walletId: string,\n) {\n  const currentValueStr = await storage.getItem(CONNECT_PARAMS_MAP_KEY);\n\n  let value: Record<string, object>;\n\n  if (currentValueStr) {\n    try {\n      value = JSON.parse(currentValueStr);\n    } catch {\n      value = {};\n    }\n\n    delete value[walletId];\n    storage.setItem(CONNECT_PARAMS_MAP_KEY, stringify(value));\n  }\n}\n\n/**\n * Get the saved connection params from storage for given wallet id\n * @internal\n */\nexport async function getSavedConnectParamsFromStorage<T extends object>(\n  storage: AsyncStorage,\n  walletId: string,\n): Promise<T | null> {\n  const valueStr = await storage.getItem(CONNECT_PARAMS_MAP_KEY);\n\n  if (!valueStr) {\n    return null;\n  }\n\n  try {\n    const value = JSON.parse(valueStr);\n\n    if (value?.[walletId]) {\n      return value[walletId];\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\nfunction isStringifiable(value: unknown): boolean {\n  try {\n    stringify(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","/**\n * Checks if a value is an object.\n * @param value - The value to check.\n * @returns True if the value is an object, false otherwise.\n * @internal\n */\nexport function isObject(value: unknown): value is object {\n  return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Checks if a value is a string.\n * @param value - The value to check.\n * @returns True if the value is a string, false otherwise.\n * @internal\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\n/**\n * Checks if a value is an object with specified keys.\n * @param value - The value to check.\n * @param keys - The keys to check for in the object. Defaults to an empty array.\n * @returns True if the value is an object with the specified keys, false otherwise.\n * @internal\n */\nexport function isObjectWithKeys<key extends string>(\n  value: unknown,\n  keys: key[] = [],\n): value is Record<key, unknown> {\n  return isObject(value) && keys.every((key) => key in value);\n}\n\n/**\n * Checks if a value is a record with string values.\n * @param value - The value to check.\n * @returns True if the value is a record with string values, false otherwise.\n * @internal\n */\nexport function isRecord<\n  K extends string | number | symbol = string,\n  V = string,\n  T extends Record<K, V> = Record<K, V>,\n>(\n  value: unknown,\n  guards?: {\n    key?: (k: unknown) => k is K;\n    value?: (v: unknown) => v is V;\n  },\n): value is T {\n  const keyGuard = guards?.key ?? isString;\n  const valueGuard = guards?.value ?? isString;\n  return (\n    isObject(value) &&\n    !Array.isArray(value) &&\n    Object.entries(value).every(([k, v]) => keyGuard(k) && valueGuard(v))\n  );\n}\n","import type { Chain } from \"../../chains/types.js\";\nimport { cacheChains } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport type { OnConnectCallback } from \"../../react/core/hooks/connection/types.js\";\nimport { computedStore } from \"../../reactive/computedStore.js\";\nimport { effect } from \"../../reactive/effect.js\";\nimport { createStore } from \"../../reactive/store.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport { deleteConnectParamsFromStorage } from \"../../utils/storage/walletStorage.js\";\nimport type { Account, Wallet } from \"../interfaces/wallet.js\";\nimport { isSmartWallet } from \"../smart/index.js\";\nimport { smartWallet } from \"../smart/smart-wallet.js\";\nimport type { SmartWalletOptions } from \"../smart/types.js\";\nimport type { WalletId } from \"../wallet-types.js\";\n\ntype WalletIdToConnectedWalletMap = Map<string, Wallet>;\nexport type ConnectionStatus =\n  | \"connected\"\n  | \"disconnected\"\n  | \"connecting\"\n  | \"unknown\";\n\nconst CONNECTED_WALLET_IDS = \"thirdweb:connected-wallet-ids\";\nconst LAST_ACTIVE_EOA_ID = \"thirdweb:active-wallet-id\";\nconst LAST_ACTIVE_CHAIN = \"thirdweb:active-chain\";\n\nexport type ConnectionManager = ReturnType<typeof createConnectionManager>;\nexport type ConnectManagerOptions = {\n  client: ThirdwebClient;\n  accountAbstraction?: SmartWalletOptions;\n  setWalletAsActive?: boolean;\n  onConnect?: OnConnectCallback;\n};\n\n/**\n * Create a connection manager for Wallet connections\n * @param storage - An instance of type [`AsyncStorage`](https://portal.thirdweb.com/references/typescript/v5/AsyncStorage)\n * @example\n * ```ts\n * const manager = createConnectionManager();\n * ```\n * @returns A connection manager object\n * @walletUtils\n */\nexport function createConnectionManager(storage: AsyncStorage) {\n  // stores\n\n  // active wallet/account\n  const activeWalletStore = createStore<Wallet | undefined>(undefined);\n  const activeAccountStore = createStore<Account | undefined>(undefined);\n  const activeWalletChainStore = createStore<Chain | undefined>(undefined);\n  const activeWalletConnectionStatusStore =\n    createStore<ConnectionStatus>(\"unknown\");\n\n  const definedChainsStore = createStore<Map<number, Chain>>(new Map());\n\n  // update global cachedChains when defined Chains store updates\n  effect(() => {\n    cacheChains([...definedChainsStore.getValue().values()]);\n  }, [definedChainsStore]);\n\n  // change the active chain object to use the defined chain object\n  effect(() => {\n    const chainVal = activeWalletChainStore.getValue();\n    if (!chainVal) {\n      return;\n    }\n\n    const definedChain = definedChainsStore.getValue().get(chainVal.id);\n\n    if (!definedChain || definedChain === chainVal) {\n      return;\n    }\n\n    // update active chain store\n    activeWalletChainStore.setValue(definedChain);\n  }, [definedChainsStore, activeWalletChainStore]);\n\n  // other connected accounts\n  const walletIdToConnectedWalletMap =\n    createStore<WalletIdToConnectedWalletMap>(new Map());\n\n  const isAutoConnecting = createStore(false);\n\n  const connectedWallets = computedStore(() => {\n    return Array.from(walletIdToConnectedWalletMap.getValue().values());\n  }, [walletIdToConnectedWalletMap]);\n\n  // actions\n  const addConnectedWallet = (wallet: Wallet) => {\n    const oldValue = walletIdToConnectedWalletMap.getValue();\n    if (oldValue.has(wallet.id)) {\n      return;\n    }\n    const newValue = new Map(oldValue);\n    newValue.set(wallet.id, wallet);\n    walletIdToConnectedWalletMap.setValue(newValue);\n  };\n\n  const removeConnectedWallet = (wallet: Wallet) => {\n    const oldValue = walletIdToConnectedWalletMap.getValue();\n    const newValue = new Map(oldValue);\n    newValue.delete(wallet.id);\n    walletIdToConnectedWalletMap.setValue(newValue);\n  };\n\n  const onWalletDisconnect = (wallet: Wallet) => {\n    deleteConnectParamsFromStorage(storage, wallet.id);\n    removeConnectedWallet(wallet);\n\n    // if disconnecting the active wallet\n    if (activeWalletStore.getValue() === wallet) {\n      storage.removeItem(LAST_ACTIVE_EOA_ID);\n      activeAccountStore.setValue(undefined);\n      activeWalletChainStore.setValue(undefined);\n      activeWalletStore.setValue(undefined);\n      activeWalletConnectionStatusStore.setValue(\"disconnected\");\n    }\n  };\n\n  const disconnectWallet = (wallet: Wallet) => {\n    onWalletDisconnect(wallet);\n    wallet.disconnect();\n  };\n\n  // handle the connection logic, but don't set the wallet as active\n  const handleConnection = async (\n    wallet: Wallet,\n    options?: ConnectManagerOptions,\n  ) => {\n    const account = wallet.getAccount();\n    if (!account) {\n      throw new Error(\"Cannot set a wallet without an account as active\");\n    }\n\n    const activeWallet = await (async () => {\n      if (options?.accountAbstraction && !isSmartWallet(wallet)) {\n        return await handleSmartWalletConnection(\n          wallet,\n          options.client,\n          options.accountAbstraction,\n          onWalletDisconnect,\n        );\n      } else {\n        return wallet;\n      }\n    })();\n\n    await storage.setItem(LAST_ACTIVE_EOA_ID, wallet.id);\n\n    // add personal wallet to connected wallets list even if it's not the active one\n    addConnectedWallet(wallet);\n\n    if (options?.setWalletAsActive !== false) {\n      handleSetActiveWallet(activeWallet);\n    }\n\n    wallet.subscribe(\"accountChanged\", async () => {\n      // We reimplement connect here to prevent memory leaks\n      const newWallet = await handleConnection(wallet, options);\n      options?.onConnect?.(newWallet, connectedWallets.getValue());\n    });\n\n    return activeWallet;\n  };\n\n  const connect = async (wallet: Wallet, options?: ConnectManagerOptions) => {\n    // connectedWallet can be either wallet or smartWallet\n    const connectedWallet = await handleConnection(wallet, options);\n    options?.onConnect?.(connectedWallet, connectedWallets.getValue());\n    return connectedWallet;\n  };\n\n  const handleSetActiveWallet = (activeWallet: Wallet) => {\n    const account = activeWallet.getAccount();\n    if (!account) {\n      throw new Error(\"Cannot set a wallet without an account as active\");\n    }\n\n    // also add it to connected wallets if it's not already there\n    addConnectedWallet(activeWallet);\n\n    // update active states\n    activeWalletStore.setValue(activeWallet);\n    activeAccountStore.setValue(account);\n    activeWalletChainStore.setValue(activeWallet.getChain());\n    activeWalletConnectionStatusStore.setValue(\"connected\");\n\n    // setup listeners\n\n    const onAccountsChanged = (newAccount: Account) => {\n      activeAccountStore.setValue(newAccount);\n    };\n\n    const unsubAccounts = activeWallet.subscribe(\n      \"accountChanged\",\n      onAccountsChanged,\n    );\n\n    const unsubChainChanged = activeWallet.subscribe(\"chainChanged\", (chain) =>\n      activeWalletChainStore.setValue(chain),\n    );\n    const unsubDisconnect = activeWallet.subscribe(\"disconnect\", () => {\n      handleDisconnect();\n    });\n\n    const handleDisconnect = () => {\n      onWalletDisconnect(activeWallet);\n      unsubAccounts();\n      unsubChainChanged();\n      unsubDisconnect();\n    };\n  };\n\n  const setActiveWallet = async (activeWallet: Wallet) => {\n    handleSetActiveWallet(activeWallet);\n    // do not set smart wallet as last active EOA\n    if (activeWallet.id !== \"smart\") {\n      await storage.setItem(LAST_ACTIVE_EOA_ID, activeWallet.id);\n    }\n  };\n\n  // side effects\n\n  effect(\n    () => {\n      const _chain = activeWalletChainStore.getValue();\n      if (_chain) {\n        storage.setItem(LAST_ACTIVE_CHAIN, stringify(_chain));\n      } else {\n        storage.removeItem(LAST_ACTIVE_CHAIN);\n      }\n    },\n    [activeWalletChainStore],\n    false,\n  );\n\n  // save last connected wallet ids to storage\n  effect(\n    async () => {\n      const accounts = connectedWallets.getValue();\n      const ids = accounts.map((acc) => acc?.id).filter((c) => !!c) as string[];\n\n      storage.setItem(\n        CONNECTED_WALLET_IDS,\n        stringify(Array.from(new Set([...ids]))),\n      );\n    },\n    [connectedWallets],\n    false,\n  );\n\n  const switchActiveWalletChain = async (chain: Chain) => {\n    const wallet = activeWalletStore.getValue();\n    if (!wallet) {\n      throw new Error(\"No active wallet found\");\n    }\n\n    if (!wallet.switchChain) {\n      throw new Error(\"Wallet does not support switching chains\");\n    }\n\n    if (isSmartWallet(wallet)) {\n      // also switch personal wallet\n      const personalWalletId = await getStoredActiveWalletId(storage);\n      if (personalWalletId) {\n        const personalWallet = connectedWallets\n          .getValue()\n          .find((w) => w.id === personalWalletId);\n        if (personalWallet) {\n          await personalWallet.switchChain(chain);\n          await wallet.switchChain(chain);\n          // reset the active wallet as switch chain recreates a new smart account\n          handleSetActiveWallet(wallet);\n          return;\n        }\n      }\n      // If we couldn't find the personal wallet, just switch the smart wallet\n      await wallet.switchChain(chain);\n      handleSetActiveWallet(wallet);\n    } else {\n      await wallet.switchChain(chain);\n    }\n\n    // for wallets that dont implement events, just set it manually\n    activeWalletChainStore.setValue(wallet.getChain());\n  };\n\n  function defineChains(chains: Chain[]) {\n    const currentMapVal = definedChainsStore.getValue();\n\n    // if all chains to be defined are already defined, no need to update the definedChains map\n    const allChainsSame = chains.every((c) => {\n      const definedChain = currentMapVal.get(c.id);\n      // basically a deep equal check\n      return stringify(definedChain) === stringify(c);\n    });\n\n    if (allChainsSame) {\n      return;\n    }\n\n    const newMapVal = new Map(currentMapVal);\n    for (const c of chains) {\n      newMapVal.set(c.id, c);\n    }\n    definedChainsStore.setValue(newMapVal);\n  }\n\n  return {\n    activeAccountStore,\n    activeWalletChainStore,\n    activeWalletConnectionStatusStore,\n    activeWalletStore,\n    addConnectedWallet,\n    connect,\n    connectedWallets,\n    defineChains,\n    disconnectWallet,\n    handleConnection,\n    isAutoConnecting,\n    removeConnectedWallet,\n    setActiveWallet,\n    switchActiveWalletChain,\n  };\n}\n\n/**\n *\n * @internal\n */\nexport async function getStoredConnectedWalletIds(\n  storage: AsyncStorage,\n): Promise<string[] | null> {\n  try {\n    const value = await storage.getItem(CONNECTED_WALLET_IDS);\n    if (value) {\n      return JSON.parse(value) as string[];\n    }\n    return [];\n  } catch {\n    return [];\n  }\n}\n\n/**\n * @internal\n */\nexport async function getStoredActiveWalletId(\n  storage: AsyncStorage,\n): Promise<WalletId | null> {\n  try {\n    const value = await storage.getItem(LAST_ACTIVE_EOA_ID);\n    if (value) {\n      return value as WalletId;\n    }\n  } catch {}\n\n  return null;\n}\n\n/**\n * @internal\n */\nexport async function getLastConnectedChain(\n  storage: AsyncStorage,\n): Promise<Chain | null> {\n  try {\n    const value = await storage.getItem(LAST_ACTIVE_CHAIN);\n    if (value) {\n      return JSON.parse(value) as Chain;\n    }\n  } catch {}\n\n  return null;\n}\n\n/**\n * @internal\n */\nexport const handleSmartWalletConnection = async (\n  eoaWallet: Wallet,\n  client: ThirdwebClient,\n  options: SmartWalletOptions,\n  onWalletDisconnect: (wallet: Wallet) => void,\n) => {\n  const signer = eoaWallet.getAccount();\n  if (!signer) {\n    throw new Error(\"Cannot set a wallet without an account as active\");\n  }\n\n  const wallet = smartWallet(options);\n\n  await wallet.connect({\n    chain: options.chain,\n    client: client,\n    personalAccount: signer,\n  });\n\n  // Disconnect the active wallet when the EOA disconnects if it the active wallet is a smart wallet\n  const disconnectUnsub = eoaWallet.subscribe(\"disconnect\", () => {\n    handleDisconnect();\n  });\n  const handleDisconnect = () => {\n    disconnectUnsub();\n    onWalletDisconnect(wallet);\n  };\n\n  return wallet;\n};\n","import type { Store } from \"./store.js\";\n\nexport type ReadonlyStore<T> = {\n  getValue(): T;\n  subscribe(listener: () => void): () => void;\n};\n\n/**\n * Create a readonly store whose value is computed from other stores\n * @param computation - The function to compute the value of the store\n * @param dependencies - The stores it depends on\n * @example\n * ```ts\n * const foo = computed(() => bar.getValue() + baz.getValue(), [bar, baz]);\n * ```\n * @returns A store object\n */\nexport function computedStore<T>(\n  // pass the values of the dependencies to the computation function\n  computation: () => T,\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any store type\n  dependencies: (Store<any> | ReadonlyStore<any>)[],\n): ReadonlyStore<T> {\n  type Listener = () => void;\n  const listeners = new Set<Listener>();\n\n  let value = computation();\n\n  const notify = () => {\n    for (const listener of listeners) {\n      listener();\n    }\n  };\n\n  const setValue = (newValue: T) => {\n    value = newValue;\n    notify();\n  };\n\n  // when any of the dependencies change, recompute the value and set it\n  for (const store of dependencies) {\n    store.subscribe(() => {\n      setValue(computation());\n    });\n  }\n\n  return {\n    getValue() {\n      return value;\n    },\n    subscribe(listener: Listener) {\n      listeners.add(listener);\n      return () => {\n        listeners.delete(listener);\n      };\n    },\n  };\n}\n","import type { ReadonlyStore } from \"./computedStore.js\";\nimport type { Store } from \"./store.js\";\n\n/**\n * Run a function whenever dependencies change\n * @param effectFn - Side effect function to run\n * @param dependencies - The stores it depends on\n * @param runOnMount - Whether to run the effect function immediately or not\n * @example\n * ```ts\n * const foo = computed(() => bar.getValue() + baz.getValue(), [bar, baz]);\n * ```\n * @returns A function to stop listening to changes in the dependencies\n */\nexport function effect<T>(\n  // pass the values of the dependencies to the computation function\n  effectFn: () => T,\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any store type\n  dependencies: (Store<any> | ReadonlyStore<any>)[],\n  runOnMount = true,\n) {\n  if (runOnMount) {\n    effectFn();\n  }\n\n  // when any of the dependencies change, recompute the value and set it\n  const unsubscribeList = dependencies.map((store) => {\n    return store.subscribe(() => {\n      effectFn();\n    });\n  });\n\n  return () => {\n    for (const fn of unsubscribeList) {\n      fn();\n    }\n  };\n}\n","import { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { createRetryer } from './retryer'\nimport type {\n  DefaultError,\n  MutationMeta,\n  MutationOptions,\n  MutationStatus,\n} from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n  submittedAt: number\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface PendingAction<TVariables, TContext> {\n  type: 'pending'\n  isPaused: boolean\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | PendingAction<TVariables, TContext>\n  | PauseAction\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  readonly mutationId: number\n\n  #observers: Array<MutationObserver<TData, TError, TVariables, TContext>>\n  #mutationCache: MutationCache\n  #retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.mutationId = config.mutationId\n    this.#mutationCache = config.mutationCache\n    this.#observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = options\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.#mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.#observers = this.#observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.#mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === 'pending') {\n        this.scheduleGc()\n      } else {\n        this.#mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return (\n      this.#retryer?.continue() ??\n      // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n      this.execute(this.state.variables!)\n    )\n  }\n\n  async execute(variables: TVariables): Promise<TData> {\n    const onContinue = () => {\n      this.#dispatch({ type: 'continue' })\n    }\n\n    this.#retryer = createRetryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error('No mutationFn found'))\n        }\n        return this.options.mutationFn(variables)\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue,\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this),\n    })\n\n    const restored = this.state.status === 'pending'\n    const isPaused = !this.#retryer.canStart()\n\n    try {\n      if (restored) {\n        // Dispatch continue action to unpause restored mutation\n        onContinue()\n      } else {\n        this.#dispatch({ type: 'pending', variables, isPaused })\n        // Notify cache callback\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(variables)\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: 'pending',\n            context,\n            variables,\n            isPaused,\n          })\n        }\n      }\n      const data = await this.#retryer.start()\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(data, variables, this.state.context!)\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(data, null, variables, this.state.context)\n\n      this.#dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.#mutationCache.config.onError?.(\n          error as any,\n          variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onError?.(\n          error as TError,\n          variables,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.#mutationCache.config.onSettled?.(\n          undefined,\n          error as any,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          variables,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.#dispatch({ type: 'error', error: error as TError })\n      }\n    } finally {\n      this.#mutationCache.runNext(this)\n    }\n  }\n\n  #dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'pending':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: 'pending',\n            variables: action.variables,\n            submittedAt: Date.now(),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.#mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n    submittedAt: 0,\n  }\n}\n","import type { QueryClient } from \"@tanstack/react-query\";\n\nexport function invalidateWalletBalance(\n  queryClient: QueryClient,\n  chainId?: number,\n) {\n  queryClient.invalidateQueries({\n    queryKey: chainId ? [\"walletBalance\", chainId] : [\"walletBalance\"],\n  });\n  queryClient.invalidateQueries({\n    queryKey: chainId\n      ? [\"internal_account_balance\", chainId]\n      : [\"internal_account_balance\"],\n  });\n  queryClient.invalidateQueries({\n    queryKey: chainId ? [\"nfts\", chainId] : [\"nfts\"],\n  });\n  queryClient.invalidateQueries({\n    queryKey: chainId ? [\"tokens\", chainId] : [\"tokens\"],\n  });\n}\n","\"use client\";\nimport { createContext } from \"react\";\n\nexport const SetRootElementContext = createContext<\n  (el: React.ReactNode) => void\n>(() => {});\n","// src/queryClient.ts\nimport {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken\n} from \"./utils.js\";\nimport { QueryCache } from \"./queryCache.js\";\nimport { MutationCache } from \"./mutationCache.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.js\";\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new QueryCache();\n    this.#mutationCache = config.mutationCache || new MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1) return;\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0) return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    const query = this.#queryCache.build(this, defaultedOptions);\n    const cachedData = query.state.data;\n    if (cachedData === void 0) {\n      return this.fetchQuery(options);\n    }\n    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {\n      void this.prefetchQuery(defaultedOptions);\n    }\n    return Promise.resolve(cachedData);\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    const query = this.#queryCache.get(\n      defaultedOptions.queryHash\n    );\n    const prevData = query?.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(\n      options.queryHash\n    )?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(\n        {\n          type: \"active\",\n          ...filters\n        },\n        options\n      );\n    });\n  }\n  cancelQueries(filters, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(filters, options = {}) {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters?.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? \"active\"\n        },\n        options\n      );\n    });\n  }\n  refetchQueries(filters, options = {}) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true\n    };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query)\n    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n  ensureInfiniteQueryData(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.ensureQueryData(options);\n  }\n  resumePausedMutations() {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\nexport {\n  QueryClient\n};\n//# sourceMappingURL=queryClient.js.map","// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Set();\n    this.#scopes = /* @__PURE__ */ new Map();\n    this.#mutationId = 0;\n  }\n  #mutations;\n  #scopes;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.add(mutation);\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const scopedMutations = this.#scopes.get(scope);\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        this.#scopes.set(scope, [mutation]);\n      }\n    }\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation);\n      if (typeof scope === \"string\") {\n        const scopedMutations = this.#scopes.get(scope);\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope);\n          }\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = this.#scopes.get(scope);\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === \"pending\"\n      );\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);\n      return foundMutation?.continue() ?? Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: \"removed\", mutation });\n      });\n      this.#mutations.clear();\n      this.#scopes.clear();\n    });\n  }\n  getAll() {\n    return Array.from(this.#mutations);\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => matchMutation(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id;\n}\nexport {\n  MutationCache\n};\n//# sourceMappingURL=mutationCache.js.map","// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart, ensureQueryFn } from \"./utils.js\";\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options;\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n      const oldPages = context.state.data?.pages || [];\n      const oldPageParams = context.state.data?.pageParams || [];\n      let result = { pages: [], pageParams: [] };\n      let currentPage = 0;\n      const fetchFn = async () => {\n        let cancelled = false;\n        const addSignalProperty = (object) => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions);\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const createQueryFnContext = () => {\n            const queryFnContext2 = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? \"backward\" : \"forward\",\n              meta: context.options.meta\n            };\n            addSignalProperty(queryFnContext2);\n            return queryFnContext2;\n          };\n          const queryFnContext = createQueryFnContext();\n          const page = await queryFn(queryFnContext);\n          const { maxPages } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          const remainingPages = pages ?? oldPages.length;\n          do {\n            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);\n            if (currentPage > 0 && param == null) {\n              break;\n            }\n            result = await fetchPage(result, param);\n            currentPage++;\n          } while (currentPage < remainingPages);\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal\n            },\n            query\n          );\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, { pages, pageParams }) {\n  const lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams\n  ) : void 0;\n}\nfunction getPreviousPageParam(options, { pages, pageParams }) {\n  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;\n}\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\nexport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior\n};\n//# sourceMappingURL=infiniteQueryBehavior.js.map","// src/queryCache.ts\nimport { hashQueryKeyByOptions, matchQuery } from \"./utils.js\";\nimport { Query } from \"./query.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar QueryCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => matchQuery(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\nexport {\n  QueryCache\n};\n//# sourceMappingURL=queryCache.js.map","import { replaceEqualDeep } from \"@tanstack/react-query\";\n\n/** Forked from https://github.com/epoberezkin/fast-deep-equal */\n// biome-ignore lint/suspicious/noExplicitAny: This function by nature takes any object\nfunction deepEqual(a: any, b: any) {\n  if (a === b) return true;\n\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    if (a.constructor !== b.constructor) return false;\n\n    let length: number;\n    let i: number;\n\n    if (Array.isArray(a) && Array.isArray(b)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString)\n      return a.toString() === b.toString();\n\n    const keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0; )\n      // biome-ignore lint/style/noNonNullAssertion: We know its there\n      if (!Object.hasOwn(b, keys[i]!)) return false;\n\n    for (i = length; i-- !== 0; ) {\n      const key = keys[i];\n\n      if (key && !deepEqual(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  // biome-ignore lint/suspicious/noSelfCompare: TODO\n  return a !== a && b !== b;\n}\n\nexport function structuralSharing<T>(oldData: T | undefined, newData: T) {\n  if (deepEqual(oldData, newData)) {\n    return oldData as T;\n  }\n  return replaceEqualDeep(oldData, newData) as T;\n}\n","import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { DefaultError, MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Set<Mutation<any, any, any, any>>\n  #scopes: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Set()\n    this.#scopes = new Map()\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.add(mutation)\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const scopedMutations = this.#scopes.get(scope)\n      if (scopedMutations) {\n        scopedMutations.push(mutation)\n      } else {\n        this.#scopes.set(scope, [mutation])\n      }\n    }\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation)\n      if (typeof scope === 'string') {\n        const scopedMutations = this.#scopes.get(scope)\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation)\n            if (index !== -1) {\n              scopedMutations.splice(index, 1)\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope)\n          }\n        }\n      }\n    }\n\n    // Currently we notify the removal even if the mutation was already removed.\n    // Consider making this an error or not notifying of the removal depending on the desired semantics.\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const mutationsWithSameScope = this.#scopes.get(scope)\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === 'pending',\n      )\n      // we can run if there is no current pending mutation (start use-case)\n      // or if WE are the first pending mutation (continue use-case)\n      return !firstPendingMutation || firstPendingMutation === mutation\n    } else {\n      // For unscoped mutations there are never any pending mutations in front of the\n      // current mutation\n      return true\n    }\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const foundMutation = this.#scopes\n        .get(scope)\n        ?.find((m) => m !== mutation && m.state.isPaused)\n\n      return foundMutation?.continue() ?? Promise.resolve()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: 'removed', mutation })\n      })\n      this.#mutations.clear()\n      this.#scopes.clear()\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return Array.from(this.#mutations)\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TContext> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id\n}\n","\"use client\";\nimport { useMemo } from \"react\";\nimport { webLocalStorage } from \"../../../utils/storage/webStorage.js\";\nimport {\n  type ConnectionManager,\n  createConnectionManager,\n} from \"../../../wallets/manager/index.js\";\nimport { ThirdwebProviderCore } from \"../../core/providers/thirdweb-provider.js\";\n\n/**\n * The ThirdwebProvider is component is a provider component that sets up the React Query client.\n * @param props - The props for the ThirdwebProvider\n * @example\n * ```jsx\n * import { ThirdwebProvider } from \"thirdweb/react\";\n *\n * function Example() {\n *  return (\n *    <ThirdwebProvider>\n *      <App />\n *    </ThirdwebProvider>\n *   )\n * }\n * ```\n * @component\n * @walletConnection\n */\nexport function ThirdwebProvider(\n  props: React.PropsWithChildren<{\n    connectionManager?: ConnectionManager;\n  }>,\n) {\n  const connectionManager = useMemo(\n    () => props.connectionManager || createConnectionManager(webLocalStorage),\n    [props.connectionManager],\n  );\n\n  return (\n    <ThirdwebProviderCore manager={connectionManager}>\n      {props.children}\n    </ThirdwebProviderCore>\n  );\n}\n","\"use client\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { useState } from \"react\";\nimport { waitForReceipt } from \"../../../transaction/actions/wait-for-tx-receipt.js\";\nimport { isBaseTransactionOptions } from \"../../../transaction/types.js\";\nimport type { Hex } from \"../../../utils/encoding/hex.js\";\nimport { isObjectWithKeys } from \"../../../utils/type-guards.js\";\nimport type { ConnectionManager } from \"../../../wallets/manager/index.js\";\nimport { structuralSharing } from \"../utils/structuralSharing.js\";\nimport { ConnectionManagerCtx } from \"./connection-manager.js\";\nimport { invalidateWalletBalance } from \"./invalidateWalletBalance.js\";\nimport { SetRootElementContext } from \"./RootElementContext.js\";\n\n/**\n * @internal\n */\nexport function ThirdwebProviderCore(props: {\n  manager: ConnectionManager;\n  children: React.ReactNode;\n}) {\n  const [el, setEl] = useState<React.ReactNode>(null);\n  const [queryClient] = useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          mutations: {\n            onSettled: (data, _error, variables) => {\n              if (isBaseTransactionOptions(variables)) {\n                if (\n                  isObjectWithKeys(data, [\"transactionHash\"]) &&\n                  isObjectWithKeys(variables, [\"client\", \"chain\"])\n                ) {\n                  waitForReceipt({\n                    chain: variables.chain, // We know it exists from the if\n                    client: variables.client,\n                    transactionHash: data.transactionHash as Hex,\n                  })\n                    .catch((e) => {\n                      // swallow errors for receipts, but log\n                      console.error(\"[Transaction Error]\", e);\n                    })\n                    .then(() => {\n                      return Promise.all([\n                        queryClient.invalidateQueries({\n                          queryKey:\n                            // invalidate any readContract queries for this chainId:contractAddress\n                            [\n                              \"readContract\",\n                              variables.__contract?.chain.id ||\n                                variables.chain.id,\n                              variables.__contract?.address || variables.to,\n                            ] as const,\n                        }),\n                        invalidateWalletBalance(\n                          queryClient,\n                          variables.__contract?.chain.id || variables.chain.id,\n                        ),\n                      ]);\n                    });\n                }\n              }\n            },\n          },\n          queries: {\n            // With SSR, we usually want to set some default staleTime\n            // above 0 to avoid refetching immediately on the client\n            staleTime: 60 * 1000,\n            structuralSharing,\n          },\n        },\n      }),\n  );\n\n  return (\n    <ConnectionManagerCtx.Provider value={props.manager}>\n      <QueryClientProvider client={queryClient}>\n        <SetRootElementContext.Provider value={setEl}>\n          {props.children}\n        </SetRootElementContext.Provider>\n        {el}\n      </QueryClientProvider>\n    </ConnectionManagerCtx.Provider>\n  );\n}\n","import { hashQueryKeyByOptions, matchQuery } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type {\n  DefaultError,\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  WithRequired,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryHash: string) => boolean\n  set: (queryHash: string, query: Query) => void\n  get: (queryHash: string) => Query | undefined\n  delete: (queryHash: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    client: QueryClient,\n    options: WithRequired<\n      QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Array<Query> {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters<any> = {}): Array<Query> {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  EnsureInfiniteQueryDataOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InferDataFromTag,\n  InferErrorFromTag,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: OmitKeyof<QueryOptions<any, any, any>, 'queryKey'>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching<TQueryFilters extends QueryFilters<any> = QueryFilters>(\n    filters?: TQueryFilters,\n  ): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating<\n    TMutationFilters extends MutationFilters<any, any> = MutationFilters,\n  >(filters?: TMutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(queryKey: TTaggedQueryKey): TInferredQueryFnData | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n\n    return this.#queryCache.get<TInferredQueryFnData>(options.queryHash)?.state\n      .data\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n    const query = this.#queryCache.build(this, defaultedOptions)\n    const cachedData = query.state.data\n\n    if (cachedData === undefined) {\n      return this.fetchQuery(options)\n    }\n\n    if (\n      options.revalidateIfStale &&\n      query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))\n    ) {\n      void this.prefetchQuery(defaultedOptions)\n    }\n\n    return Promise.resolve(cachedData)\n  }\n\n  getQueriesData<\n    TQueryFnData = unknown,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(filters: TQueryFilters): Array<[QueryKey, TQueryFnData | undefined]> {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data as TQueryFnData | undefined\n      return [queryKey, data]\n    })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): NoInfer<TInferredQueryFnData> | undefined {\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    const query = this.#queryCache.get<TInferredQueryFnData>(\n      defaultedOptions.queryHash,\n    )\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (data === undefined) {\n      return undefined\n    }\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<\n    TQueryFnData,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(\n    filters: TQueryFilters,\n    updater: Updater<\n      NoInfer<TQueryFnData> | undefined,\n      NoInfer<TQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n  ): QueryState<TInferredQueryFnData, TInferredError> | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get<TInferredQueryFnData, TInferredError>(\n      options.queryHash,\n    )?.state\n  }\n\n  removeQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n  ): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    options?: ResetOptions,\n  ): Promise<void> {\n    const queryCache = this.#queryCache\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(\n        {\n          type: 'active',\n          ...filters,\n        },\n        options,\n      )\n    })\n  }\n\n  cancelQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: InvalidateQueryFilters<TTaggedQueryKey>,\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters?.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? 'active',\n        },\n        options,\n      )\n    })\n  }\n\n  refetchQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: RefetchQueryFilters<TTaggedQueryKey>,\n    options: RefetchOptions = {},\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled() && !query.isStatic())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (defaultedOptions.retry === undefined) {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query),\n    )\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options as any)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  ensureInfiniteQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: EnsureInfiniteQueryDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n\n    return this.ensureQueryData(options as any)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations()\n    }\n    return Promise.resolve()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: QueryKey,\n    options: Partial<\n      OmitKeyof<\n        QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n        'queryKey'\n      >\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    const result: OmitKeyof<\n      QueryObserverOptions<any, any, any, any, any>,\n      'queryKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TContext = unknown,\n  >(\n    mutationKey: MutationKey,\n    options: OmitKeyof<\n      MutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): OmitKeyof<MutationObserverOptions<any, any, any, any>, 'mutationKey'> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    const result: OmitKeyof<\n      MutationObserverOptions<any, any, any, any>,\n      'mutationKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (defaultedOptions.refetchOnReconnect === undefined) {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (defaultedOptions.throwOnError === undefined) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n","import type {\n  Abi,\n  AbiFunction,\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  ExtractAbiFunction,\n  ParseAbiItem,\n} from \"abitype\";\nimport type { TransactionReceipt as ViemTransactionReceipt } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { isObjectWithKeys } from \"../utils/type-guards.js\";\nimport type {\n  PreparedTransaction,\n  StaticPrepareTransactionOptions,\n} from \"./prepare-transaction.js\";\n\nexport type SendTransactionResult = {\n  readonly transactionHash: Hex;\n};\n\nexport type TransactionReceipt = ViemTransactionReceipt;\n\nexport type WithOverrides<T> = T & {\n  overrides?: Omit<\n    StaticPrepareTransactionOptions,\n    \"to\" | \"from\" | \"data\" | \"maxFeePerBlobGas\" | \"chain\" | \"client\"\n  >;\n};\n\nexport type ParamsOption<inputs extends readonly AbiParameter[]> =\n  inputs extends {\n    length: 0;\n  }\n    ? // allow omitting \"params\" if there are no inputs\n      { params?: readonly unknown[] }\n    : {\n        params:\n          | Readonly<AbiParametersToPrimitiveTypes<inputs>>\n          | (() => Promise<Readonly<AbiParametersToPrimitiveTypes<inputs>>>);\n      };\n\nexport type BaseTransactionOptions<\n  T extends object = object,\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  abi extends Abi = any,\n> = {\n  contract: ThirdwebContract<abi>;\n} & T;\n// type-guard\n/**\n * Checks if the given value is of type TxOpts.\n * @param value - The value to check.\n * @returns True if the value is of type TxOpts, false otherwise.\n * @internal\n */\nexport function isBaseTransactionOptions(\n  value: unknown,\n): value is PreparedTransaction {\n  return (\n    isObjectWithKeys(value, [\"__contract\"]) &&\n    isObjectWithKeys(value.__contract, [\"address\", \"chain\"]) &&\n    typeof value.__contract.address === \"string\"\n  );\n}\n\nexport type ParseMethod<\n  abi extends Abi,\n  method extends\n    | AbiFunction\n    | string\n    | ((contract: ThirdwebContract<abi>) => Promise<AbiFunction>),\n> = method extends AbiFunction // if the method IS an AbiFunction, return it\n  ? method\n  : method extends string // we now know we are in \"string\" territory\n    ? // if the string starts with `function` then we can parse it\n      method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : // do we have an ABI to check, check the length\n        abi extends { length: 0 }\n        ? // if not, we return AbiFunction\n          AbiFunction\n        : // if we do have a length, extract the abi function\n          ExtractAbiFunction<abi, method>\n    : // this means its neither have an AbiFunction NOR a string -> never\n      AbiFunction;\n","import { addToEnd, addToStart, ensureQueryFn } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options as InfiniteQueryPageParamsOptions<TData>\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction\n      const oldPages = context.state.data?.pages || []\n      const oldPageParams = context.state.data?.pageParams || []\n      let result: InfiniteData<unknown> = { pages: [], pageParams: [] }\n      let currentPage = 0\n\n      const fetchFn = async () => {\n        let cancelled = false\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions)\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const createQueryFnContext = () => {\n            const queryFnContext: OmitKeyof<\n              QueryFunctionContext<QueryKey, unknown>,\n              'signal'\n            > = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? 'backward' : 'forward',\n              meta: context.options.meta,\n            }\n            addSignalProperty(queryFnContext)\n            return queryFnContext as QueryFunctionContext<QueryKey, unknown>\n          }\n\n          const queryFnContext = createQueryFnContext()\n\n          const page = await queryFn(queryFnContext)\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch all pages\n          do {\n            const param =\n              currentPage === 0\n                ? (oldPageParams[0] ?? options.initialPageParam)\n                : getNextPageParam(options, result)\n            if (currentPage > 0 && param == null) {\n              break\n            }\n            result = await fetchPage(result, param)\n            currentPage++\n          } while (currentPage < remainingPages)\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return pages.length > 0\n    ? options.getNextPageParam(\n        pages[lastIndex],\n        pages,\n        pageParams[lastIndex],\n        pageParams,\n      )\n    : undefined\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return pages.length > 0\n    ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)\n    : undefined\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK","vendored","ReactJsxRuntime","React"],"mappings":"0DAIA,EAA6C,CCFtC,ADEA,CAAsC,CAAA,ACFpC,ADEA,CAAoC,QCF3B,ADEA,ECFE,ADEA,MCFM,ADEA,MCoDnB,KAAK,OAtDgC,ADEA,CCFC,ADEA,ECoDvB,EACpB,CAAc,CACd,CAAsB,CACtB,CAAwB,CAHI,CAK5B,IAAM,EAAW,MAAH,AAAG,CAAA,EAAM,EAAA,cAAA,AAAc,EAAC,GAAQ,EAAQ,CAAV,AAC1C,CAD2C,EAAO,EAClD,CAAA,EAAM,EAAA,SAAA,AAAS,EAAA,EAAS,QAAQ,CAAC,SACxB,CACP,GAAA,CDnDc,CCmDJ,MAAM,CDlDG,CAAA,KCkDI,KAAK,ADlDE,CAAC,CAAA,OCkDM,CACrC,cAAc,CAAE,kBAAkB,EAEpC,SAAS,CDlDG,ECkDM,GDlDK,GCkDC,EAAE,GAAG,EAAE,IDlDM,CCkDD,ADlDE,CAAC,CCkDD,SAAS,CAC/C,OAAQ,MAAM,CDlDG,ACmDjB,CDnDkB,eCmDF,CACd,EAAQ,KAAD,WAAiB,EAAI,EAAO,IAAD,EAAO,EAAE,GAAG,EAAE,KAAK,EAAE,gBAAgB,GAG3E,GAAI,CAAC,EAAS,EAAE,CAAE,CAAC,AACjB,EADW,EACL,EAAQ,GAAH,GAAS,EAAS,IAAI,EAAL,AAAO,CAAC,KAAK,CAAC,GAAG,CAAG,CAAD,GAAK,CAAC,AACrD,CADsD,MAChD,AAAI,IDnDQ,ECoDhB,CAAA,+BAAA,EAAkC,EAAS,MAAD,AAAO,CAAA,GAAA,EAAM,EAAS,MAAD,IAAW,CAAA,EAAA,EAAK,GAAS,EAAJ,aAAmB,CAAA,CAAE,CAC1G,CAAC,AAGJ,OAAO,MAAM,EAAS,IAAI,EAAE,AAAP,AACvB,CAD+B,AAC9B,AAUM,KAAK,UAAU,EACpB,CAAc,CACd,CAAsB,CACtB,CAA8B,EAE9B,IAAM,CAL4B,CAKjB,MAAH,AAAG,CAAA,EAAM,EAAA,cAAA,AAAc,EAAC,GAAQ,EAAQ,CACpD,AAD0C,CAAC,EAAO,CAC9C,CAAA,CAAA,EAAE,EAAA,SAAA,AAAS,EAAC,EAAQ,KAAD,EAAQ,CAAC,CAChC,OAAO,CAAE,CACP,GAAG,EAAQ,IAAD,EAAO,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAI,CAAA,CAAE,CAAC,AAC7C,cAAc,CAAE,kBAAkB,CACnC,CACD,SAAS,CAAE,EAAO,IAAD,EAAO,EAAE,GAAG,EAAE,KAAK,EAAE,SAAS,CAC/C,MAAM,CAAE,MAAM,CACd,gBAAgB,CACd,EAAQ,KAAD,WAAiB,EAAI,EAAO,IAAD,EAAO,EAAE,GAAG,EAAE,KAAK,EAAE,gBAAgB,CAC1E,CAAC,CAAC,AAEH,GAAI,CAAC,EAAS,EAAE,CAAE,CAAC,AACjB,EADW,EACL,EAAQ,GAAH,GAAS,EAAS,IAAI,EAAL,AAAO,CAAC,KAAK,CAAC,GAAG,CAAG,CAAD,GAAK,CACpD,AADqD,CAAC,MAChD,AAAI,KAAK,CACb,CAAA,+BAAA,EAAkC,EAAS,MAAM,AAAP,CAAO,GAAA,EAAM,EAAS,MAAD,IAAW,CAAA,EAAA,EAAK,GAAS,EAAJ,aAAmB,CAAA,CAAE,CAC1G,AACH,CADI,AACH,AACD,OAAO,MAAM,EAAS,IAAI,EAAE,AAC9B,AADuB,CAAQ,AAC9B,AD5GD,IAAM,CAoDA,CApDiB,IAAI,OAAO,CAoD5B,AApDc,CAAgB,CAAC,OAoDrB,EACd,CAAmB,EAEnB,IAAM,EAlDR,AAkDuB,CAHK,QA/CnB,AAAgB,CAAA,AAkDL,ECAZ,ADjDN,GAAA,EAAmB,GAAG,CAAC,GACrB,GAD2B,CAAC,EAAE,CAAC,AAC/B,EAAA,GAAyB,CAAC,GAE5B,IAAM,EAAe,IAAI,GAAG,CAE5B,CAF8B,CAAZ,AAAa,KAC/B,EAAA,GAAkB,CAAC,EAAQ,ACkDR,GDjDZ,CACT,CAAC,CCiDS,ADN6B,EAAQ,KAAD,CAAO,CAAC,CAAC,AAC/C,EAAS,EAAQ,EAAX,GAAU,AAAM,CAAC,GAAG,CAAC,AAEjC,GAAI,EAAa,GAAG,CAAC,GACnB,GADyB,AAAX,CAAY,EAAE,CAAC,AACtB,EAAa,GAAG,CAAC,GAG1B,GAHqB,AAAW,CAAqC,AAG/D,CAHgE,CAGlB,CAAC,GAAG,EAAE,AAExD,CAFa,GAEP,EAAM,CAAA,EAAG,CAAH,CAAG,iBAAA,AAAiB,EAAC,CAC/B,KAAK,CAAE,EAAQ,KAAD,AAAM,CACpB,MAAM,CAAE,EAAQ,KAAD,CAAO,CACvB,CAAC,CAEI,AAFH,EAID,EAAQ,KAFK,AAEN,CAAO,EADd,AACgB,YAAY,EAE5B,EADA,AACQ,KAAD,CAAO,CAAC,MAAM,EAAE,GAAG,EAHU,AAGR,SADC,GACW,EApDf,EAqDzB,CArD4B,CAuDxB,AAvDyB,EAyD7B,EAAQ,KAAD,CAAO,EAAE,CAJD,CAEG,GAClB,SAC8B,EAE9B,EAAQ,AADR,KACO,CAAO,CAAC,MAAM,EAAE,GAAG,EAAE,GAHQ,MAEP,KACa,EAzDf,CAAC,CA0D5B,AAII,AA9DyB,EA8DN,IAAI,GAAG,CAE5B,CAFoD,CAAC,AAcpD,EAAE,CAAC,AACJ,CAfkB,CAe0C,IAAI,CAbpD,AAaqD,AAMrE,EAzB0B,CAAC,MAyBlB,GANc,CAQjB,IACF,QAHqB,IAGT,CAAC,EADQ,CAErB,CAFuB,CAED,AAFE,IAEE,CAAC,CAI7B,IAAM,EAAW,AAAI,EALa,CAAC,CAAC,CACf,AAIK,CAAZ,AAAa,EAAa,MAAM,CAAC,CAAC,AAC1C,EADiC,AACnB,EAAa,KAAK,EAArB,AAAuB,CAAC,EAAT,CAAY,CAAC,CAAC,EAAU,KAEtD,AAF2D,CAAP,CAAS,AAEpD,EAFsD,IAEvD,CAAQ,CAAC,EAAE,CAAG,EAEtB,EAAS,CAFkB,CAAC,IAEpB,CAAQ,CAAC,OAAO,CAAG,KAAK,CAAC,AAEjC,CAAQ,CAAC,EAAM,CAAG,EAAJ,AAAa,MAAD,CAAQ,CAAC,AAC5B,IAGT,EAAe,EAAE,AAHA,CAGC,AAElB,AALkB,EAKT,EAAQ,EAAQ,CAFb,CAEJ,AAAO,GAAS,CAAO,CAAE,UAC/B,EACA,MADQ,UACQ,CAAE,EAAQ,KAAD,CAAO,EAAE,gBAAgB,CACnD,CAAC,CACC,IAAI,CAAC,AAAC,IACL,EAAY,GADE,EAAE,EAAE,AACC,CAAC,CAAT,AAAU,EAAU,KAAK,AAElC,CAF2B,CAAS,EAAE,AAEhC,EAAW,CAAS,CAAC,EAAM,CAAC,AAG7B,CAHS,CAWL,AAXuB,MAGnB,EAAE,AAQE,CARD,IAQa,KAAK,CAChC,CADkC,CAAC,AAC1B,MAAD,AAAO,CAAC,GACP,KADe,CAAC,CAAC,AACV,GAAI,EACpB,EAAS,IADmB,EAAE,AACtB,AAAO,CADgB,AACf,EAAS,KAAK,CAAN,AAAO,CAAC,AACvB,AAAoB,QAAQ,EAAE,CAAC,MAAxB,EAChB,EAAS,IADe,EAChB,AAAO,CAAC,AAAI,KAAK,CAAC,IAGC,IAHO,CAAC,CAAC,CAAC,WAGQ,EAAE,CAAxC,AAAyC,EAAhC,MAAD,AAAO,CACtB,EAAS,MAAM,AAAP,CAAQ,iCAAiC,CAAC,CAAC,AAInD,EAAS,MAAD,CAAQ,CAAC,EAAS,MAAD,AAAO,CAAC,CAAC,AApBlC,EAAS,MAAM,AAAP,CACN,AAAI,KAAK,CACP,CAAA,eAAA,EAAkB,EAAM,IAAA;AAAA,UAAA,EAAA,CAAA,EAAgB,EAAA,SAAA,AAAS,EAAC,QAAQ,CAAC,CAAA;AAAA,WAAA,EAAA,CAAA,EAAgB,EAAA,SAAA,AAAS,EAAC,GAAU,CAAE,CAClG,CACF,AAkBL,CAlBM,AAkBL,CAAC,AACJ,CADK,AACJ,AArBuG,CAqBtG,AArBuG,CAsBxG,KAAK,CAAC,AAAC,GAAG,CAET,CAFW,EAAE,CAER,IAAM,KAAY,EACrB,CADiB,CACR,MAAD,AAAO,CADiB,AAChB,CADkB,CAAC,AAGvC,CAFuB,AAEtB,CAFuB,AAEtB,CAFuB,AAGxB,OAAO,CAAC,GAAG,EAEV,AAFY,EAEK,KAAK,EAAE,AAC1B,CAD2B,AAC1B,CAAC,AACN,CADO,AACN,IAFqB,GAKtB,AAAkB,CAAC,EAAE,CAAjB,AAAkB,EACb,KAAK,CAAE,CADH,GAKR,EAAgB,CAJE,CAIA,CAJE,AAIC,CAAC,CAJA,AAIP,AAAQ,AAEvB,EAAgB,KAAD,EAAQ,CAAG,KAAK,CAAC,AACjC,IAAM,EAAc,MAAM,EAAe,CAAxB,CAAgC,EAAQ,EAAV,GAAS,CAAO,CAAE,CAAzB,AACtC,OAAO,CAAE,EACT,KADgB,WACA,CAAE,EAAQ,KAAD,CAAO,EAAE,gBAAgB,CACnD,CAAC,CAAC,AAEH,GAAI,CAAC,EACH,MAAM,AAAI,GADI,EAAE,AACD,CADE,AACD,aAAa,CAAC,CAAC,AAEjC,GAAI,OAAO,GAAI,EACb,MAAM,EAAY,CADM,EAAE,CAAC,CACJ,CAAC,AAE1B,GAFmB,IAEZ,EAAY,MAAM,AAC3B,CAD4B,AAC3B,CAAC,AAGG,CAJe,IAIV,CAAE,OAAO,CASf,CATiB,CAWjB,CAXmB,CACjB,EArLH,CAAA,AA6L8B,CAAC,AAEA,CAVD,AAUE,AA/L7B,EAAQ,GAqLE,EAAwB,AArL3B,CAqL4B,AAAtB,AArLC,CAAA,AAqLsB,CArLtB,EAAA,CAAA,EAAI,EAAA,IAqLQ,KArLC,AAAT,EAAU,EAAQ,KAAD,CAAO,CAAC,CAAA,CAAE,CAwLnD,AAxLoD,GAwLhD,EAAiB,GAAG,CAAC,GAEvB,OAFkB,AAAe,AAE1B,CAF2B,CAEV,CAFY,CAAC,CAEV,CAAC,GAO9B,IAAM,EAAU,CAPwB,AAAf,CAAiB,CAAC,CAOvB,CAAP,MAAc,CAAM,CAAC,EAAU,KAC1C,CADwC,CAC9B,AADuC,EAEjD,AAFmD,EAE1C,AAF4C,CAC9C,AAET,CAAC,CAAC,CAAC,AAFiB,AACZ,AAiBR,CAlBqB,EACH,CAAC,GAEnB,EAAiB,GAAG,CAAC,EAAY,GAEjC,EAAa,EAF2B,CAAxB,AAAe,AAAU,CAAC,AAEzB,CAAC,KAAN,GAAQ,EAAQ,IAAF,GAAS,cAAE,UAAU,AAAE,CAAO,CAAE,CAAC,CAAC,AACxD,EAAY,CAAC,AADuC,EACrC,AAEb,AAAC,CAFa,GAGhB,AAHS,EAGa,UAAU,CAAC,EAAkB,AAD7B,EAC2C,AADzC,CAAC,AACyC,CAA/C,AAAgD,AAGjE,EAAa,MAAM,EAAI,AAHwB,EAGnC,CACd,KAGF,CAJoC,EAAE,CAMjC,AANkC,CAO3C,CAAC,CAAC,AACJ,CAAC,CAAC,EAPsB,AAKN,AAEd,AAGJ,CAHK,AAFc,CALO,CAAC,EAGL,EAMtB,AANwB,CAAC,CAMZ,GAAG,CAAC,EAAQ,GAClB,CADK,AAAW,AAEzB,CAAC,IAFmC,CAAC,CAAC,CACgB,CAAC,oDE/OvD,IAAA,EAAwC,CAAqB,AAAtD,CAAuD,CAAA,AAAvC,CAAuC,QA2CxD,AA3C0B,EAAE,MAAM,CA2CxB,EACd,CAA6B,EAE7B,GAAI,CAAC,EAHoB,AAGZ,KAAD,CAAO,CACjB,CADmB,CAAC,IACd,AAAI,KAAK,CACb,CAAA,+CAAA,EAAkD,EAAQ,KAAD,CAAO,CAAA,CAAE,CACnE,CAAC,AAEJ,GAAI,CAAA,CAAA,EAAC,EAAA,SAAS,AAAT,EAAU,EAAQ,KAAD,EAAQ,CAAC,CAC7B,CAD+B,CAAC,IAC1B,AAAI,KAAK,CACb,CAAA,gDAAA,EAAmD,EAAQ,KAAD,EAAQ,CAAA,CAAE,CACrE,CAAC,AAEJ,GAAI,CAAC,EAAQ,KAAD,AAAM,EAAI,CAAC,EAAQ,KAAK,AAAN,CAAO,EAAE,CACrC,CADuC,CAAC,IAClC,AAAI,KAAK,CACb,CAAA,8CAAA,EAAiD,EAAQ,KAAD,AAAM,CAAA,CAAE,CACjE,CAAC,AAEJ,OAAO,CACT,CAAC,KADiD,CAAC,6CC3D7C,SAAU,EACd,CAAU,CACV,CAAqE,EAErE,MAAO,CAIL,CAR2B,AAS3B,SAAO,CACP,MAAM,CAAE,CAAS,CAOlB,EAAE,CACM,CADJ,SAED,EACA,KADO,CACD,CAAE,CAAC,EAA0B,EAAF,GAC/B,CAD4D,EAAE,CACxD,CAD0D,CAC9C,EAAO,EAAa,EAAF,AAAZ,CACxB,AADe,GAA6B,AACxC,CADyC,CAE3C,AAF2C,IAEtC,CADI,EAAE,CAAC,AACD,GAAG,EAAI,EAChB,KADuB,CAAE,CAAC,AAClB,CAAiB,CAAC,EAAI,CAAD,AAAC,AAGlC,MAAO,CACL,GAAG,CAAS,CACZ,GAAG,EAAU,EAAM,EAAF,AAAS,CAG3B,AACH,CADG,AACF,CAJe,CAAa,IAK7B,GACD,AAEL,CAFK,AADK,AAGT,wDC9BD,IAAA,EAA4B,CAArB,CAA6C,CAAA,AAA3C,CAA2C,GAAA,CAAA,GACpD,EAA+D,CAAxD,AADa,CAC2D,CAAvC,AAAuC,AADzD,CACyD,KADnD,EAyBrB,IAAM,EAAkB,CAxBwB,AAyBrD,EAzBuD,GAyBlD,CAAE,EAzBsD,IAwBnC,EACX,CACf,KAAK,CAAE,SAAS,CAChB,KAAK,CAAE,SAAS,CAChB,KAAK,CAAE,SAAS,CAChB,KAAK,CAAE,SAAS,CAC+B,CAI3C,AAJ2C,SAIjC,EACd,CAAyC,CACzC,CAAsB,EAEtB,IAAM,EAAe,CACnB,GAL6B,AAK1B,CAAW,CACd,IAFgB,KAEP,CAAE,EAAY,SAAD,AAAU,CAAC,AAAE,CAAD,CAAa,SAAD,AAAU,CAAC,AAAE,CAAD,GAAK,CAC/D,WAAW,CAAE,EAAY,SAAD,EAAY,CAChC,MAAM,CAAC,EAAY,SAAD,EAAY,CAAC,CAC/B,IAAI,CACR,OAAO,CAAE,EAAY,OAAO,CAAC,AAAC,CAAV,AAAU,EAAC,EAAA,WAAA,AAAW,EAAC,EAAY,OAAO,CAAC,CAAT,AAAU,CAAC,IAAC,EAClE,GAAG,CAAE,EAAY,CAD0D,EACvD,CAAC,AAAE,CAAD,IAAN,CAAa,CAAC,EAAY,GAAG,CAAC,CAAC,CAAC,GAAP,CAAQ,EACjD,OAD0D,CAClD,CAAE,EAAY,QAAQ,CAAT,AAAU,AAAE,CAAD,KAAO,CAAC,EAAY,QAAQ,CAAT,AAAU,CAAC,CAAC,IAAC,EAChE,OADyE,SACzD,CAAE,EAAY,SAAD,OAAiB,CAC1C,MAAM,CAAC,EAAY,SAAD,OAAiB,CAAC,MACpC,EACJ,OADa,KACD,CAAE,EAAY,SAAD,GAAa,CAClC,MAAM,CAAC,EAAY,SAAD,GAAa,CAAC,MAChC,EACJ,OADa,aACO,CAAE,EAAY,SAAD,WAAqB,CAClD,MAAM,CAAC,EAAY,SAAD,WAAqB,CAAC,CACxC,OACJ,EADa,GACR,CAAE,EAAY,KAAK,CAAE,AAAD,CAAC,EAAC,AAAT,EAAS,WAAA,AAAW,EAAC,EAAY,KAAK,CAAC,CAAC,AAAE,CAAD,CAAT,KAClD,EADqE,AACnE,CAAE,EAAY,EAAE,CAAC,AAAE,CAAD,CAAa,EAAE,CAAC,AAAE,CAAvB,AAAsB,GAAK,CAC1C,CADgC,eAChB,CAAE,EAAY,SAAD,OAAiB,CAC1C,MAAM,CAAC,EAAY,SAAD,OAAiB,CAAC,CACpC,IAAI,CACR,IAAI,CAAE,EAAY,IAAI,CACjB,CAAuB,CAAC,EADZ,AACwB,IAAI,CAAC,IAAN,EACpC,EACJ,OAAO,AADM,CACJ,EAAY,IAAI,CAAG,AAAF,CAAC,CAAa,EAApB,EAAwB,CAAC,CAAC,GAAP,CAAQ,EAC/C,KAAK,CAAE,CADiD,CACrC,KAAK,CAAC,AAAE,CAAD,EAAR,GAAe,CAAC,EAAY,KAAK,CAAC,CAAC,CAAC,CAAT,GAAU,EACvD,CAAC,CAAE,EAAY,CAAC,CAAC,AAAE,CAAD,AAD8C,KACvC,CAAC,AAAZ,EAAwB,CAAC,CAAC,CAAC,CAAC,IAAC,CAAN,CACvB,CAAA,AAoChB,MArCsD,CAGlD,EAAY,SAAD,QAAkB,GAC/B,EAAa,UAAD,OAAkB,CAC5B,AA+CG,EA/CS,AADmB,SACpB,MA+CS,GAAC,GAAG,CAAC,AAAC,CAhD4B,GAgDT,CAC/C,OAAO,CADkC,AAC/B,EADiC,AACX,CADc,MACP,CACvC,GAD+B,IACxB,CAAE,MAAM,CAAC,EAAc,OAAO,CAAC,CACtC,EAD6B,GACxB,CAAE,MAAM,CAAC,EAAc,KAAK,CAAC,CAClC,CAAC,CAAE,EADwB,AACV,CAAC,CAClB,CAAC,CAAE,EAAc,CAAC,CAClB,GAFgB,IAET,CAAE,CADO,KACD,CAAC,EAAc,OAAO,CAAC,EACvC,CAtDgC,AAqDF,AAC7B,CArDC,AAqD2B,CAAA,AArD3B,AAEH,EAAa,OAAO,CAAG,CAAC,CAAZ,EAAe,EAAE,AAE3B,GAAI,EAAY,OAAO,CAAE,CAAV,MAAiB,MAAM,CAAC,EAAY,OAAO,CAAC,CAAT,AAAS,AAG3D,GAA8B,QAAQ,EAAlC,OAAO,EAAa,CAAC,CAAe,CACtC,AADuC,GACnC,CAAmB,CAAE,EADJ,GACJ,CAAC,IAAF,AAAgC,CAAG,GAAtB,EAAa,CAAC,CAAU,OAAO,CAAC,AAApB,CAAoB,AAC7D,IAAuB,CAAE,GAArB,EAAa,CAAC,EAA8B,GAAG,GAAtB,CAAb,CAA0B,CAAC,CAAU,OAAO,CAAC,AAApB,CAAoB,AAC7D,GAAI,EAAa,CAAC,IAAI,CAAG,CAAE,GAAX,KAAkB,EAAa,CAAC,EAAG,CAAE,IAAK,CAAA,AAAE,CAAd,AAAe,AAC/D,CADgE,AAC/D,CAGH,AAJmE,CAIlE,AAJmE,CAIlE,AAJmE,CAAC,CAM5C,AAN6C,AAInE,CAJoE,AAIpE,CAJoE,MAMtC,EAAE,CAAC,AAAjC,EAAa,IAAI,GACnB,GADc,IACP,EAAa,UAAD,AAAW,CAAA,AAC9B,OAAO,EAAa,UAAD,MAAiB,CAAA,AACpC,OAAO,EAAa,UAAD,EAAa,CAAA,AAChC,OAAO,EAAa,UAAD,UAAqB,CAAA,AACxC,OAAO,EAAa,OAAO,CAAA,CAEH,CAFL,QAEc,EAAE,CAAjC,AAAkC,EAArB,IAAI,GACnB,GADc,IACP,EAAa,UAAD,MAAiB,CAAA,AACpC,OAAO,EAAa,UAAD,EAAa,CAAA,AAChC,OAAO,EAAa,UAAD,UAAqB,CAAA,CAEhB,SAAS,EAAE,CAAjC,AAAkC,EAArB,IAAI,EACnB,IADc,GACP,EAAa,UAAD,MAAiB,CAE/B,AAF+B,CAGxC,CAAC,AAIM,IAAM,EAAiC,CAAA,EAAC,CAL1B,CAK0B,AAL1B,UAKS,GAAG,EAAc,AAAe,EAC5D,OAD+B,EAAa,IAC/B,CACb,iBAAiB,CAClB,CAAA,wFCrHM,KAAK,UAAU,EAAc,CAAY,EAC9C,GAAiB,IAAI,CADY,EAC7B,EAAM,EAAE,CAAH,CAA6B,KAAK,EAAE,CAAC,AAArB,EAAM,EAAE,CAC/B,AAD4B,OACrB,EAIT,GAJc,AAKZ,AAAa,CALA,EAKG,EAAX,GAAC,EAAE,EACR,AAAa,GAAG,EAAX,GAAC,EAAE,EACK,GAAG,GAAhB,EAAM,EAAE,CAAH,CACQ,KAAK,GAAlB,EAAM,EAAE,CAAH,CACQ,GAAG,GAAhB,EAAM,EAAE,CAAH,CACQ,GAAG,GAAhB,EAAM,EAAE,CAAH,CACQ,IAAI,GAAjB,EAAM,EAAE,CAAH,CACL,AAAa,KAAR,CAAc,KAAb,EAAE,EACK,KAAK,GAAlB,EAAM,EAAE,CAAH,CACQ,MAAM,GAAnB,EAAM,EAAE,CAAH,CACQ,SAAS,IAAtB,EAAM,EAAE,CAAH,CACL,AAAa,KAAR,EAAe,KAAd,EAAE,EACR,AAAa,IAAI,CAAZ,IAAC,EAAE,EACK,GAAG,GAAhB,EAAM,EAAE,CAAH,CACQ,MAAM,GAAnB,EAAM,EAAE,CAAH,CACQ,KAAK,GAAlB,EAAM,EAAE,CAAH,CACQ,MAAM,EACnB,CADA,AACC,EADK,EAAE,CAAH,AAEL,OAAO,EAIT,EAJa,CAAC,AAIV,CAAC,AACH,GAAM,kBAAE,CAAgB,CAAE,CAAG,MAAM,EAAO,CAAA,CAAA,EAAD,CAAC,KACpC,CAD8D,CAAC,AAC/C,CADgD,KAC1C,EAAiB,GAA1B,AACnB,EADkD,CAAC,CAAC,EACjB,KADS,SACK,CAAC,EAA3C,EAAc,SAAS,AAChC,CAAC,AAAC,CADoB,IACd,CAAC,AAEP,OAAO,CACT,CAAC,AACH,CAAC,EAFe,CAAC,kDC1BX,SAAU,EAAe,CAAe,EAE5C,IAAM,EAAY,AAFO,IAEH,GAAG,AAAV,CAEX,CAFiC,CAEzB,AAF0B,EAUtC,CARS,KAQF,IARiB,CAAC,KASvB,IACS,EAET,EAHQ,CACM,CAAC,IAEP,CAAC,CAAW,EAClB,GAAI,IAAa,EAVnB,EAUc,CAAU,CAVnB,CAUqB,CAAC,EAVhB,KAaT,EAAQ,CAbS,CAAI,CAahB,EAZL,GAYgB,AAElB,CAFmB,AAElB,EAf+B,CAAE,CACxB,AADyB,EACvB,CAAC,IAeb,AAAU,IACR,EAAU,EADgB,CAAnB,AACM,CAAC,GACP,AADE,GACC,EAAE,AACV,AAFoB,CAAC,CAAC,AAEZ,MAAM,CAAP,AAAQ,EACnB,CAAC,CAAC,CAGR,AADG,CACF,AADG,EAH6B,CAAC,CAAC,oOChB3BG,EAAOC,OAAO,CAAGC,EAAQ,CAAA,CAAA,IAAA,mCC1BjCF,EAAOC,OAAO,CACZC,EAAQ,CAAA,CAAA,IAAA,IACRI,QAAQ,CAAC,YAAY,CAAEC,eAAe,gCCFxCP,EAAOC,OAAO,CACZC,EAAQ,CAAA,CAAA,IAAA,IACRI,QAAQ,CAAC,YAAY,CAAEE,KAAK,kDCAe,CACrC,OAAO,CAAb,KAAK,CAAS,GAAW,AAShB,IAAI,CAAC,AAEd,KAAK,CAAC,UAAU,CAAC,CAAW,EAI5B,CAAC,CACD,KAAK,CAAC,OAAO,CAAC,CAAW,CAAE,CAAa,EAQxC,CAAC,CACF,CAAC,2BC5BF,IAAA,EAA6B,CAAtB,CAAyD,CAAvD,AAAuD,CAAA,OAEhE,EAAuC,CAAhC,CAAwD,AAF1C,CAEZ,AAAsD,CAAA,AAFxC,CAAwC,CAAC,IAAnC,EAG7B,EAA4B,CAArB,CADuD,AACL,CAAhD,AADsD,AACN,CAAA,MAAD,CAAC,AAD1B,CAE/B,CAFiC,CAEH,AADV,CACb,CAAuB,AADR,CACb,AAAqB,CAAA,CAFS,GACX,CAC+C,CAAC,EAC5E,EAAmC,CAA5B,CAA4B,AADb,CACb,AAA0B,CAAA,AADX,MAAM,EAG9B,EAAoC,CAF6C,AAE1E,CAF2E,AAEvB,CAAlD,AAAkD,CAAA,GAFhC,EAAE,GAI7B,AAF0D,CAAC,CAElB,CAAlC,AAJ4B,CAI2B,CAArD,AAAqD,CAAA,IAFlC,EAAE,EA2HxB,GAzHuD,CAAC,AAF1B,KA2HpB,EACd,CAAiC,EAEjC,CA5H+B,EAAE,CA6H7B,EAJqB,AAKrB,EACA,CA/HmC,CAgInC,CAH4B,CAAC,AAD3B,CAGsB,CAAC,AAHhB,CAAA,EAAG,CAEqB,CAFrB,AAEsB,AAFzB,SAIsD,CAAC,SAJjC,AAAnB,EAA8B,CAAC,CAM/C,MAAO,CACL,WAAW,CAAE,KAAK,CAAE,IAClB,GADyB,AACnB,CAAE,CADmB,EAAE,gBACF,CAAE,CAAkB,CAAE,CAAG,MAAM,EAExD,CAAA,CAAA,EAF8D,CAC9D,KAEI,CAAC,EAAkB,EAAe,CAAG,CAF7B,CACb,CAAC,GAC+C,EAC/C,EACA,CAFqB,AAAgB,EAevC,EAdS,KAIT,EAAqB,CAHN,CAFoD,AAGlE,AAGD,CAHE,CAGQ,EACV,CAF4B,CAAC,AAErB,CADD,EACF,EACL,EAAA,CAHkB,IACQ,CAAC,CACL,CAAC,IACvB,AAAY,EAAC,CACX,OAAO,CAAE,EAAM,EAAE,CACjB,AADc,MACR,CAAE,EAAQ,KAAD,CAAO,CACtB,aAAa,CAAE,EAAQ,KAAD,EAAQ,CAC9B,UAAU,CAAE,OAAO,CACpB,CAAC,CAAC,AAEI,CACT,CAAC,CACD,IAFgB,CAAC,EAEV,CAAE,KAAK,CAAE,IACd,GADqB,AACf,EADiB,EAAE,iBACjB,CAAmB,CAAE,CAAG,MAAM,EAAqB,CAAA,CAAA,EAAf,CAAC,KACvC,CAAC,EAAkB,EAAe,CAAG,CADc,CAAC,CAAC,GACV,EAC/C,EACA,CAFqC,AAAhB,EAiBvB,EAhBS,KAIT,EAAe,CAHA,CAGQ,AAFtB,CAHmE,AAGlE,IAEoB,GAAV,OAA0B,CAAC,AACvC,EAAqB,EACrB,EAAU,EACV,CAF4B,CAEpB,AAFqB,CACtB,EACF,EACL,EAAA,CAHkB,IACQ,CAAC,CACL,CAAC,IACvB,AAAY,EAAC,CACX,OAAO,CAAE,EAAM,EAAE,CACjB,AADc,MACR,CAAE,EAAQ,KAAD,CAAO,CACtB,aAAa,CAAE,EAAQ,KAAD,EAAQ,CAC9B,UAAU,CAAE,OAAO,CACpB,CAAC,CAAC,AAEH,EAAQ,IAAI,CAAL,AAAM,gBAAgB,CAAE,GACxB,CACT,CAAC,CACD,CAHwC,CAAC,CAAC,CAC1B,CAAC,KAEP,CAAE,KAAK,IAAI,CACnB,CADqB,EACjB,EAAS,CAAC,AACZ,GAAM,CADG,uBACD,CAAsB,CAAE,CAAG,MAAM,EAAqB,CAAA,CAAA,EAAf,CAAC,IAChD,OAAM,CADsD,CAC/B,AADgC,CAAC,CAEhE,CAAC,AACD,IAFsC,CAAC,CAAC,CAEjC,AAAG,EACV,OADmB,AACJ,CAHe,AAEV,CAEpB,GADY,EACP,EADmB,AAChB,CADiB,CAEzB,EAAQ,IAAI,CAAC,AADI,AACV,CADW,WACO,MAAE,EAC7B,CAAC,CACD,KAFsC,CAAC,CAAC,GAE9B,CAAE,GAAG,CAAG,CAAD,CACjB,KADyB,UACV,CAAE,GAAG,CAAG,CAAD,CACtB,QAAQ,EAD2B,CAEjC,GAAK,CAAD,CAKJ,GALU,EAAE,CAAC,CAKN,AADP,EAAK,CAAA,EAAA,AAAG,AACI,CAAC,CADL,sBAAA,AAAsB,EAAC,EAAM,EAAE,CAAH,AAAI,EAAI,CAE9C,CAAC,CACD,EAHmD,CAAC,MAG3C,CAAE,GAAG,CAAG,CAAD,CAChB,EAAE,CAAE,OAAO,CADmB,AAE9B,SAAS,CAAE,EAAQ,KAAD,IAAU,CAC5B,WAAW,CAAE,KAAK,CAAE,IAClB,GAAI,CAD6B,AAC5B,EAD8B,AAEjC,EAFmC,IAE7B,AAAI,KAAK,CAAC,IADK,EAAE,CAAC,4CAC2C,CAAC,CAGtE,AAHuE,GAGnE,CAAC,AADiB,MAAA,CAAA,EAAM,EAAA,EACV,WADuB,AAAb,EAAc,GACtB,CAElB,AAFmB,IAEb,AAH0C,CAAC,CAAC,AAGrC,CAAA,EAAG,EAAH,AAAG,WAAW,AAAX,EAAY,CAC1B,OAAO,CACL,EAAc,WAAD,GAAe,EAAA,CAAA,EAC5B,EAAA,wBAAA,AAAwB,EACtB,EAAc,SAAS,EAAV,AAAY,iBAAiB,CAC3C,CACH,KAAK,CAAE,EACP,MADe,AACT,CAAE,EAAmB,MAAM,CAClC,CAAC,CAAC,AAEH,GAAI,CADe,AACd,GAHuB,GAET,CAAA,EAAM,CACV,CADU,CACR,CAAC,gBADyB,AAAlB,EAAmB,GAE1C,IAFiD,CAAC,CAE5C,AAAI,AAFyC,KAEpC,CACb,CAAA,wCAAA,EAA2C,EAAS,EAAE,CAAA,CAAE,CACzD,AAEL,CAHyD,AACnD,AAEL,AACD,GAAM,qBAAE,CAAmB,CAAE,CAAG,MAAM,EAAqB,CAAA,CAAA,EAAf,CAAC,KACvC,CAAC,EAAkB,EAAe,CAAG,CADc,CAAC,CAAC,GACV,EAC/C,CAAE,EADmB,AAAgB,CAChC,CAAkB,CAAE,KAAK,CAAE,CAAQ,CAAE,CAC1C,CAAE,CAFgE,EAE7D,CAAa,AADsB,CACpB,KAAK,CAAE,CAAQ,CAAE,CACtC,CAAC,AAEF,EAAU,EAH2B,AAIrC,EAAQ,CADD,CAEP,CADK,CACG,IAAI,CAAL,AAAM,GAFa,CAAC,CACL,CAAC,UACM,CAAE,GAC/B,EAAQ,IAAI,CAAL,AAAM,MADkC,CAAC,CAAC,MACtB,CAAE,EAC/B,CAAC,CACF,AACH,CADI,AACH,SAHgD,CAAC,CAAC,+CC3OnD,IAAA,EAAmC,CCD5B,ADCA,CCDgE,CAAA,ADC9D,ACDA,CAA8D,IDCzD,ECDwD,ADCtD,CCDuD,CDMhE,ICNe,ADCA,CAKV,CCN0B,MAAM,GDMtB,CALY,CAAC,AAKA,CAMlC,EACC,ECOI,CDPE,IAP0B,IAOxB,CAAM,WAAE,CAAS,YAAE,CAAU,GCOJ,YDPM,CAAa,SAAE,CAAO,CAAE,CAAG,IAAI,CAAC,aAC3D,EAAC,OCOO,CDNlB,CCMoD,CDLpD,ACKqD,IDLjD,AADE,CACA,CACJ,MAAM,CAAE,SAAS,SACjB,EACA,KADO,CACD,CAAE,eAAe,eACvB,aAAa,AACb,EACD,QADW,GAEZ,EACD,CACH,AADI,CACH,ACLK,ADID,EECF,GFFU,ICHG,ICSd,MDRA,OCQM,ADRC,ECQY,IAAI,GAAG,CAMnB,AANS,CAOd,AAHC,CAAC,GAGE,CAAC,CAAK,CAAE,CAAI,EACd,IAAM,EAAc,EAAW,GAAG,CAAC,GACnC,AADiB,CAAa,CAAU,CAAC,AACrC,CADsC,CAExC,IAAK,IAAM,CADE,CACA,CADE,CAAC,CACC,EACf,EAAE,AAAC,EAGT,CAAC,CAHY,CAAC,CAAC,CADiB,CAAE,CAAC,KAKnC,CAAU,EAAO,EAAE,CAAJ,EACR,CADE,CACS,GAAG,CAAC,GAGlB,CAHa,CAAU,AAGZ,CAHa,EAAE,AAGZ,CAHa,AAGZ,IAAL,AAAa,CAAH,CAAC,CAAK,CAAC,EAAE,CAAC,AAF9B,CAE+B,CAFpB,GAAG,CAAC,EAAO,EAAZ,CAAU,CAAM,GAAG,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,CAK/B,AALgC,GAK7B,EAAE,AACV,IAAM,EAAc,EAAW,GAAG,CAAC,GAAlB,AACb,CAD0B,CAAU,CAAC,AAEvC,CAFwC,CAE5B,MADC,AACK,CAAC,CADJ,CAGnB,AAHoB,AACL,AAAU,CAAC,AAEzB,CAAC,AAFyB,CAI9B,ADpCH,CAAC,ACoCG,qGEpCG,eAAA,EACL,CDL+B,ACKU,CDLT,ACMhC,CAAqB,EAErB,OAAO,EAAQ,CACb,MAAM,CAAE,EDRa,WCQA,CACrB,OAAQ,GAAQ,GDNK,EAAE,ECMO,CAAE,EAAO,IAAD,IAAS,EAAI,QAAQ,CAAC,CAC7D,CAAC,AACJ,CADK,AACJ,AD9BD,IAAA,EAA6B,CAAtB,AAAwC,CAAC,CAAvC,AAAuC,CAAA,QAIhD,GAJqB,CAIf,CAJiB,CAIA,IAAI,CAJE,MAIK,CAa5B,AAbc,CAAgD,CAAC,OAarD,EAAY,CAA0B,EACpD,ECII,CDJA,EAAe,CADM,CCKf,CDJY,CAAC,GACrB,GCG6B,IDHtB,CADyB,CACV,AADW,CCQrB,EDPa,CAAC,GAG5B,IAAM,CAH8B,CAAiB,ACS7C,CDT8C,AAGxC,CAAJ,ACMF,IAAS,ADNE,KACjB,IAAM,EAAU,CAAA,EAAG,EAAA,GAAH,SAAe,AAAZ,EAAa,GAC1B,EAAS,GADyB,CAC5B,AAD6B,CAAC,CACrB,EAAY,EAAY,CAC3C,MAD8B,CAAW,AAClC,CAAE,EAAS,MAAD,CAAQ,CACzB,QAAQ,CAAE,QAAQ,CACnB,CAAC,CAAC,AAIH,MAHe,IAAI,EAAE,CAAjB,AAAkB,GACpB,EAAe,CADP,KACa,CAAC,GAEjB,CACT,CAAC,AAHiB,CAGhB,EAHgC,AAG9B,CAH+B,AAEpB,AACV,AAEL,CALoC,AAEpB,MAEhB,EAAe,GAAG,CAAC,EAAU,GACtB,CACT,AAFmC,CAElC,AAFmC,CAAP,AAAb,AAAqB,CACxB,CAAC,wDEnCd,IAAA,EAA4B,CAArB,CAA6D,CAA3D,AAA4D,CAAA,QAMrE,EANoB,EAAE,AAMhB,EAAQ,GAAH,CANiB,AAMV,OAAO,CAiBlB,CAjBsC,CAAC,GAiBlC,UAAU,EACpB,CAA0B,EAE1B,GAAI,EAAM,GAAG,AAAJ,CAAK,GAEZ,CALoC,IAGhB,CAAC,CAEd,CAFgB,CAAC,AAM1B,EAJa,CAAC,CAIR,EAAa,AAAa,IAAI,CAAC,EADpB,CACD,AAAW,KADV,CAAA,EAAM,EAAA,WAAW,AAAX,EAAY,GAMnC,KAN2C,CAAC,CAGxC,AAHyC,GAI3C,EAAM,GAAD,AAAI,CAAC,CADE,EAAE,AAGT,CAHU,AAInB,CAAC,GAHqB,CAAC,CAAC,GAEL,CAAC,kDCrBd,SAAU,EACd,CAAuB,EAEvB,MAAyB,MAHM,EAGE,EAA1B,OAAO,EACV,EAAO,EADS,EACV,MAAW,CAAC,YAAY,CAAC,CAC/B,EAAO,EAAE,CAAC,CAAJ,SAAc,CAAC,YAAY,CAAC,AACxC,CADyC,AACxC,0DCrBD,IAAA,EAA2B,CAApB,CAAgD,CAA9C,AAA8C,CAAA,IAAD,CAAC,GACvD,CADmB,CACgB,CADd,AACd,CAAwD,CAAA,AAAtD,CAAsD,GADpC,KAYpB,IAXuD,AAWjD,CAXkD,CAY7D,GAZyB,EAAE,MAAM,UAWC,uBACU,CAAC,AAClC,CADmC,CAE9C,MAFqD,eACnB,uBACU,CAAC,AAkDlC,CAlDmC,CAkDZ,AAAC,IACnC,EAnDqD,CAkDH,CAC5C,CAD+D,CAC7C,CAAA,AAD+C,EAC5C,EAAA,GADI,OACJ,AAAU,CAAb,CAAc,GACtC,GAAI,CADyC,CAAC,CAAC,CACpB,EACzB,MAAO,MADa,AACP,CAAC,AAEhB,GAAI,IAAuB,CAHuB,CAIhD,CAJkD,CAAC,IAI5C,MADa,AACP,AAEf,CAFgB,MAEV,AAAI,EAHwC,EAAE,CAAC,AAGtC,CAAC,2BAA2B,CAAC,AAC9C,CAD+C,AAC9C,CAAC,yBArEA,sIAAsI,CAAC,2FAY/F,KAAM,CAAC,8BA2BT,AAAC,GAIvC,AAAI,AAAY,MAAM,CAAX,CAAa,CAHR,AAGS,EAFvB,GAF+D,AAE1C,EAF4C,CAlCnE,CAkCqE,UAElD,CADiB,QACU,CAC7C,CAAC,sBArC0C,CAAC,AAF7C,4CAA4C,CAAC,yBAiDX,AAAC,IACnC,CAD+C,EAAE,CAC3C,CAD6C,CACvC,CAAA,EAAG,CAAH,CAAG,kBAAA,AAAkB,EAAE,EAAC,OAAO,CAAC,OACxC,AAAJ,EAAW,IAAD,MAAW,CAAC,YAAY,CAAC,CAC1B,CAD4B,AAC5B,CAD6B,MAC7B,EAAU,EAAM,IAAA,MAAA,EAAa,EAAM,EAAE,CAAH,AAAG,CAAE,CAEzC,AAF0C,CAE1C,QAAA,EAAW,EAAM,EAAE,CAAH,AAAG,CAAA,EAAI,EAAM,GAAA,CAAA,AAAK,AAC3C,CAD4C,AAC3C,CAAC,sDC3DI,SAAU,EAAM,CAAU,EAAX,AACnB,OAAO,IAAI,OAAO,CAAE,AAAD,GAAa,CAAD,GAAJ,EAAE,IAAa,CAAC,EAAS,EAAE,CAAC,AACzD,CAD0D,AACzD,CADmD,AAAO,qEEI3D,EAAA,EAAA,CAAA,CAAA,gBDHgB,EACd,CAAyB,CACzB,ACDkB,AAAQ,EAAN,GDDG,CAGrB,CAAI,WACJ,CAAS,CAAA,CCHuC,ADIkB,CCJlB,ADIkB,CAAE,EAEtE,GCJK,EAAiC,CDI/B,CACL,CCJK,EDIF,CAAG,CACN,CCJK,EADS,EAAE,EADmC,EDM1C,ACN4C,CDM1C,CCLW,CDKP,CAAD,ACJM,EAAE,AAFqC,MAC3B,AACV,CDIK,ACLK,EDKD,CAAD,MCN6C,CAAA,CDMnC,CAAC,AAAC,CCJI,ADIJ,IAC1C,YAAa,EAAI,CAAD,ECKQ,QDLI,CAAC,AAAE,CAAD,KAAO,CAAC,EAAI,CAAD,UAAY,CAAC,CAAG,AAAF,CAAC,GAAK,CAC7D,CCKG,QDLO,EAAI,CCKC,ADLF,OAAS,CAAC,AAAE,CAAD,KAAO,CAAC,EAAI,CAAD,OAAS,CAAC,CAAG,AAAF,CAAC,GAAK,CACpD,CCKG,eDLc,EAAI,CAAD,cAAgB,CAAC,AAAE,CAAD,CAAK,CAAD,cAAgB,CAAC,AAAE,CAAD,GAAK,CACjE,gBAAgB,CAAE,EAAI,CAAD,eAAiB,CAClC,OAAO,EAAI,CAAD,cCQsB,CAAA,EDPhC,GCWO,CDXH,IACJ,EAAY,MAAE,CAAL,CAAC,CAAC,SAAS,CAAS,CAAE,CAAC,AAAE,CAAD,AAAC,CAAE,CAAC,AACnC,AACV,CAAC,AADS,EAD2B,SCa/B,CAAC,oBAxBP,IAAA,EAAO,CAAA,CAAA,CAAA,CAAA,QAUA,IAAM,EAAkB,CAC7B,GDNa,GCMN,KDLG,MCMV,MAAO,SAAS,CACR,CAAA,AAIJ,CDVa,IAEb,CAAC,GCQS,EACd,CDTkC,ACSqB,CDT3C,ACUZ,CAAsB,EAEtB,IAAM,EDXF,ACWY,CDXX,ACYH,GAAG,CAAkB,CDXC,ACYtB,WAAW,CAAE,EAAmB,WAAW,CACvC,IAD2B,EACrB,CAAC,EAAmB,WAAW,CAAC,CACtC,GADyB,CACrB,CACR,eAAe,CAAE,EAAmB,eAAe,CAAhB,AAC/B,EAAmB,eAAe,CAAhB,AAClB,IAAI,CACR,iBAAiB,CAAE,EAAmB,gBAAD,CAAkB,CACnD,MAAM,CAAC,EAAmB,gBAAD,CAAkB,CAAC,CAC5C,IAAI,CACR,iBAAiB,CAAE,EAAmB,gBAAD,CAAkB,CACnD,MAAM,CAAC,EAAmB,gBAAD,CAAkB,CAAC,CAC5C,IAAI,CACR,OAAO,CAAE,EAAmB,OAAO,CAC/B,MAAM,CAAC,CADgB,CACG,OAAO,CAAC,CAClC,IAAI,CACR,EAF6B,EAEzB,CAAE,EAAmB,IAAI,CACzB,EAAmB,IAAI,CAAC,GAAG,CADP,AACQ,AAAC,GAAG,AAAK,CAAD,CAAF,AAAa,EAA7B,CAAgC,CAClD,AADmD,CAAC,EAAN,CAC1C,CACR,EAAE,CAAE,EAAmB,EAAE,CAAC,AAAE,CAAD,CAAoB,EAAE,CAAC,AAAE,CAAD,GAAK,CACxD,GADsB,KAAwB,QAC9B,CAAE,EAAmB,gBAAgB,AAAjB,CAAiB,CAAA,EACjD,EAAA,WAAW,AAAX,EAAY,EAAmB,gBAAD,AAAiB,CAAC,CAChD,IAAI,CACR,MAAM,CAAE,EAAmB,MAAM,CAC7B,CAAe,CAAC,EAAmB,KADb,CACmB,CAAC,CAC1C,IAAI,CACR,GAFsC,CAElC,CAAE,EAAmB,IAAI,CACzB,EAAA,SADoB,MACL,CACb,EAAmB,IAAoC,CACxD,EAAI,EAAmB,IAAI,CAC5B,EAFoB,EAEhB,CACa,CAOvB,AAPuB,KAFM,EAIzB,EAAmB,YAAY,GACjC,CADoB,CACZ,KAAD,OAAa,CAAG,MAAM,CAAC,EAAmB,aAAY,CAAC,CAAA,AAC5D,CAD8C,CAC3B,WAAW,GAChC,EADoB,AACZ,KAAD,MAAY,CAAG,MAAM,CAAC,EAAmB,YAAW,CAAC,CAAA,AAEvD,CACT,CAAC,AAMM,AAT4C,IAStC,CAPG,CAOqC,AAPrC,CAOqC,EAAC,EAAA,eAAA,AAAe,EAAhC,AACnC,GADsC,WAAA,EAAa,IAC/B,CACpB,wBAAwB,CACzB,CAAA,sIIzDM,eAAe,EACpB,CAAyC,CACzC,CFHuB,AEGgB,EAEvC,IAAM,EAAU,KAAH,CAAS,EAAQ,CAC5B,IAD2B,EACrB,CAAE,2BAA2B,CACnC,MAAM,CAAA,CAAG,EAAO,IAAD,AAAK,CAAC,CHMK,KGHxB,CAAC,EACH,MAAM,AAAI,CADE,CAAC,IACG,EHQI,mEGLS,EAAC,EAClC,CAAC,IADwC,CAAC,CAAC,0CHlC3C,IAAA,ECDgC,CDCe,AAAxC,ACDA,CDCyC,ACDe,CAAA,ADCtD,ACDA,CAAsD,WDC1C,CCDyC,CAAC,ADCxC,CCDC,EAAE,GDCG,GCDG,cCYzB,KAAK,UAAU,EACpB,CAAyC,MAEnC,EAAiB,IAHY,EAGN,EAAQ,KAAD,GAC1B,CDAoC,CAClC,kBCCZ,MAAA,CAAA,EAAO,EDEE,WAAA,ACFS,EAAC,GDEG,AAsHxB,IAAM,EAAkB,IAAI,GAAG,CAqCzB,CAlCH,CAAC,GAHiB,IAqCL,EAAiB,CAA6B,EAC5D,GAAM,QADwB,AAE5B,CAAM,OACN,CAAK,kBACL,CAAgB,eAChB,CAAa,CACb,mBAAiB,SACjB,CAAO,CACR,CAAG,EACE,EADE,AACQ,CADP,CACa,EAAE,CAAX,AAAQ,AAAI,AAErB,EAAS,EAAgB,EAAnB,CAAsB,CAAC,GAQjC,IARwC,CAAC,CAAb,AAAc,CAErC,IACH,EAAS,AADA,AAhKb,EAgKe,CAAC,CACN,KAjKD,CACe,CACtB,CAAY,CAAA,CACU,CACtB,CAAgC,MAMhC,CAuJkC,CAtJ9B,EALA,EAAoD,EAAE,CAAC,EDOpC,ACNU,EAAE,AAIA,CAJC,AAEpC,AAEoC,GAFrB,IAII,CAAA,AAJC,CAAC,CAIF,EAAA,YAAA,AAAY,EAAC,OAAE,EDOsB,OCPf,GDOuB,CCDhE,CDCkE,CCPnB,aAMhC,IAAI,GAEb,CAAC,SAIL,CAJe,EAIf,CACE,IAAM,EAAc,MAAM,EAAgB,ADY5B,CCZG,CDYD,CCVhB,ADUiB,GCVjB,CAAK,GAF+C,AAE/C,CAFgD,CAEf,AAFgB,CAAb,CAEc,CDWhB,ACXiB,AACtD,IAAA,EAAsB,EAAE,CAAC,AACzB,GAAA,MACO,EDeE,ECfE,CAAC,CAAG,GAAkB,CAAE,CAAE,CAAC,EAAI,EAAa,CAAC,EAAE,CAAE,AACxD,CAD0B,AAA+B,CACzC,GADiC,CAC7B,CAAC,MAAM,CAAC,CAAb,AAAc,CAAC,CAAC,CAAC,KAGlC,CDgBC,CAAC,AChBgB,CDgBf,AChBgB,EAAY,CAEjC,AAFkC,EAEhB,EAClB,IAHgC,AAG1B,CAHW,CAGG,GADS,CAAC,AACN,CAAC,GAAG,CAAX,CAAa,CAC9B,AAD+B,GAC/B,EAAiB,CAAC,AAEhB,CDee,CAAC,CAAC,CCfX,EACJ,AAAC,GAAc,CAAA,CAAW,CAAC,AAAG,CADjB,CACiC,GAAlC,GAAwC,CAAC,EAEtC,IAF8B,AAE1B,CAAC,GACtB,EAAmB,EAAiB,EADL,CAAC,CAAC,CACQ,CAAC,CAAC,GAC7C,CAAC,AAGD,CAJkB,CDkBV,CClB6B,CAIhC,ADcK,ICdC,CAAC,IAFZ,EAFgE,AAElD,CAFmD,CAAC,AAIlD,GAEd,IAJS,AAIJ,EAJkB,CAAC,CAIb,IAFkB,CAAE,AAEE,CAFD,GAGX,CAAC,CAAC,AAG3B,CAH4B,AAG3B,AACH,CAAE,AAAD,GALiD,CAAE,CAAC,AAAlB,CAK1B,EAAc,CAAF,AAAG,AAClB,EACF,EAAQ,GADC,AACW,AAEpB,CAFqB,CADV,AACJ,AAAe,CADV,IAGL,CAAC,KAAK,CACX,CAAA,4DAAA,EAA+D,EAAG,CAAA,AAAE,CACrE,AAEL,CAFM,AAEL,AAKD,IAAM,EAAY,IAAI,CAAC,EAAR,CAAW,CACxB,IACA,IAAI,CAAC,GAAG,CACN,AAjGe,CA+FH,GAGZ,AAlGmB,CAAC,CAAC,EAkGjB,CAAC,ED/FqB,CC+FlB,CAAC,AAhGM,CA+FD,EA/FI,CAS1B,AAgFwC,AAzFb,CAAC,ECMzB,MDGM,AAAoB,CAuFE,AAvFkB,EAuFhB,AArF/B,KAAO,EAAW,AA8EuC,CAzFZ,CCUzB,IDCI,CARE,CAQT,CARW,AAQD,AAFD,CANG,CAAC,EASjB,OAAO,AAoFsC,CApFrC,AAbI,AAiGkC,CACtD,CACF,CAAC,CAnGyB,CAAC,AAiB9B,CCL2B,ADZI,CEkB3B,CFN4C,CAAC,GAK1C,AADK,CEEF,CFFa,CACb,EAjBgC,CAaH,CAAC,CAGX,AAHY,CAGX,CAAC,EAAK,ACFH,CAAC,ADEA,CCFC,EDEe,CAAD,CAAO,CAAH,CAAc,CAAC,AAAvB,CAAwB,CAAC,AACzD,AADkC,EACvB,AAbqD,EAYZ,IACnC,AAChC,CADiC,AAChC,CAwE2D,KAYxD,MEpF2C,CFoF3C,CAAA,EAAM,CAZkE,CAAC,AAYnE,CAZoE,IAYpE,AAAK,EAAC,EAAa,IApGE,CAoGe,AApGd,CAAC,AAoGmC,CApGlC,AAoGT,AAA4C,CAEjE,AAFkE,CAAC,CAA3C,CAG1B,CADM,AACL,AAGD,CANwC,CAEhC,CAAC,EAFmC,EAMrC,SAAS,AACd,CAAuC,CACvC,CAA2B,EAW3B,IAbuB,GAIvB,EAAY,IAAI,CAAC,GAEZ,CAFM,GAGT,CAHuB,CAAC,AAGN,CAHO,CAEd,AAEX,EAFa,CAEF,AAFG,EAGd,EADe,CAAC,AAAR,AAlH+E,CAmHnF,CAIC,CANU,AAET,CAAC,IAF6B,CAAC,EAMvB,EAIa,CAAC,EAAE,CAA1B,AAA2B,CAF/B,EAAc,EAFW,AAEC,MAEX,AAFiB,CAAE,AAAvB,AAAsB,EAAG,AAAX,CAAgB,CAAH,AAAE,CAAG,EAAK,EAAQ,CAAC,CAAC,AAE1C,MAAM,GACpB,OAAkB,EAClB,MADe,CACD,AADa,CAAC,CAE5B,EADW,CACA,EAEf,CAAC,AACH,CAJ6B,AAGzB,AACH,AACH,CALgC,AAChB,AAAQ,AAGpB,AACH,CAJwB,AAyDY,EAAQ,EAAO,EAAT,AAAwB,CAAjB,EAE9C,EAAgB,EAFsD,CAAC,AAEpD,CAFqD,AAEpD,EAAS,AAFgC,IAKxD,CAHsB,CAAQ,AAGvB,CAHwB,AAArB,CAAsB,AAGP,EAAnB,AACf,CAAC,WAD+B,GAAmB,CAAC,CAAC,uBD1LrD,IAAA,EAAY,IAAI,GAAG,CA0Bb,CA1BoD,CAAC,ECJnC,KD8BR,EACd,CAA8B,KAExB,iBAAE,CAAe,OAAE,CAAK,QAAE,CAAM,CAAE,CAAG,EAErC,EAAU,EAAM,CAF4B,CAAC,AGNvC,AHQY,CAAX,AAAQ,AAAI,AACnB,EAAM,CAAH,AAAG,EAAG,EAAO,EGRL,EHQK,CCZQ,CAAA,EAAA,CDYgB,CAAC,AACzC,EACJ,EAAQ,CGVwC,CAAC,CAAC,EFErC,ADQN,YAAkB,EApCQ,EAoCJ,CApCO,CAsCtC,GAAI,EAAI,GAAG,CAAC,GAAG,AAEb,CAFc,EAAE,CAAC,CCTC,EDWX,EAAI,CAAD,EAAI,CAAC,CCRuB,ADImB,CAAC,CAIxC,AAEpB,CAFsB,CAAC,EAEvB,EAAgB,IAAI,OAAO,CAAqB,CAAC,EAAS,CCPnB,IDQjC,AAAC,GACH,EACM,AAAJ,IADI,CACK,CACP,IAHc,EAAE,CAAC,8DAGoD,CACtE,CACF,CAAC,AAGJ,IAAM,EAAO,CAAA,EAAG,EAAH,AAAG,YAAY,AAAZ,EAAa,OAAE,KAAK,IAAE,CAAM,CAAE,CAAC,CAAC,AAG5C,EAHwC,AAGzB,CAAC,CAAC,CAAC,AAEhB,EAAU,EAAiB,GAFjB,AAEH,ACbA,IDcJ,EACP,GADY,EADkB,CAExB,CAAE,MAAM,aACI,KAAK,IAAI,EAAE,IAEvB,GCXc,EDWqB,CAAC,IAEtC,EACM,AAAJ,ACdc,ADWF,GCXmC,CAEhC,ADWX,CACK,CAAA,CAAA,wBAAA,EACoB,EAAe,aAAA,IAAA,EAAoB,EAAiB,OAAA,CAAS,CACzF,CACF,CAAC,AACF,IAHmF,EAIrF,CAAC,AACD,GAAI,CCfD,ADeE,AACH,IAAM,EAAU,KAAH,CAAS,EAA0B,EAAS,CACvD,IADqD,AACjD,CAAE,IAIR,IAEA,EAAQ,CAFD,CAGT,CAHW,AAGV,AAAC,AClBa,CDeH,CCjBG,ADaiB,AAMvB,AAPwC,GAQzC,CAAC,AAET,CAAC,AACH,CAAC,CACF,CAAC,AAEJ,CAFK,AAEJ,CAAC,CAAC,OAAO,CAAC,KACT,EAAI,CAAD,KAAO,CAAC,EACb,CAAC,CAAC,CAAC,AAGH,OADA,EAAI,CAAD,EAAI,CAAC,EAAK,CAAF,EACJ,CACT,CAAC,KADe,CAAC,wDInGjB,IAAA,EAAkC,CAA3B,CAA2B,CAAA,AAAzB,CAAyB,CAAqC,CAAC,MAUlE,QAVoB,CAUV,CAVY,CAUE,CAAqB,EACjD,EAXgC,CAW5B,CAAC,EACH,EAFyB,KAElB,EAGT,CAJiB,EAAE,AACL,AAGU,CAJJ,AACL,MAGgB,EAAE,CAAC,AAA9B,EAAa,EAAE,CACjB,OAAO,AADO,EAIhB,EAHa,CAAC,AAGU,OAAO,GAA3B,EAAa,EAAE,EAAY,CAAA,EAAI,EAAA,CAAnB,gBAAmB,AAAiB,EAAC,GAAe,CAAC,AACnE,IAAM,EAAW,EAD8C,AACb,CADc,EACnD,MAA8C,CAAV,CAAY,CAAC,AAC9D,GAAI,GAAW,IAAJ,UAAkB,GAAI,GAAW,EAAQ,EAAZ,GAAW,OAAa,CAC9D,CADgE,CAAC,KAC1D,EAET,EAFa,CAAC,AAEV,GAAS,IAAF,SAAe,CAAE,CAC1B,AAD2B,IACrB,EAAW,EAAQ,IAAX,CAAU,QAAc,CAAC,AACvC,MAAyB,SAAS,GAA3B,EAAS,IAAI,EAAL,AAAyC,SAAS,CAAC,EAA5B,EAAS,IAAI,AACrD,CACF,AADG,CAD+C,AAEjD,AACD,OAAO,CACT,CAAC,AAKK,GANQ,CAAC,KAMC,EAAgC,CAA0B,EACxE,GAAI,CAAC,EACH,IADS,EAAE,CAAC,AACL,EAET,GAFc,CAAC,AAEX,GAA+B,EACnC,EAL6C,CAKzC,AADoC,CAAC,EACb,GAAlB,IAAyB,GAArB,EAAO,EAAE,CAAc,CAAjB,AAAkB,AACpC,CAF8B,GAExB,EAAW,EAA2B,GAA/B,CAA8B,KAAU,EAAE,CAAC,AACpD,YAAY,GAAI,IAClB,EAA+B,CADN,CACc,CADZ,CAAC,GACU,KAAC,AAAU,CAAC,CAEhD,SAAS,GAAI,AAFa,IAG5B,EAA+B,CADT,CACiB,CADf,CAAC,GACa,EAAC,AAAO,CAAC,AAEnD,CACA,AADC,GACG,IAAyB,EAAnB,IAAI,CAAsB,CAHJ,EAGjB,EAAO,EAAE,EAAH,AAAe,CAAA,EAAI,EAAA,iBAAA,AAAiB,EAAC,EAAM,CAAC,CAAC,AAAE,CAClE,AADmE,IAC7D,EAAW,EAA2B,GAA/B,CAA8B,KAAU,EAAE,CAAC,AACxD,GAAI,GAAW,IAAJ,UAAkB,GAAI,GAAW,EAAQ,EAAZ,GAAW,OAAa,CAAE,CAAC,AACjE,IAAM,EAAe,EAAQ,KAAD,GAAV,IAAuB,CAAC,AACtC,YAAY,GAAI,GAClB,GAA+B,EAAa,IADd,EAAE,CAAC,GACU,AAAC,AAAU,CAAC,CAErD,SAAS,EAFiB,CAEb,IACf,EAA+B,EAAa,IADjB,EAAE,CAAC,AACc,AAAO,CAAC,AAExD,CAAC,AACD,CAH+C,EAG3C,GAAS,IAAF,KAHqB,IAGN,CAAE,CAAC,AAC3B,IAAM,EAAW,EAAQ,IAAX,CAAU,QAAc,CAAC,AACvC,GAAI,AAAkB,QAAV,CAAmB,KAAlB,IAAI,CAAgB,CAC/B,AADgC,IAC1B,EAAe,EAAS,MAAD,EAAX,IAAwB,CAAC,AACvC,GAAgB,SAAJ,GAAgB,GAAI,IAClC,EAA+B,EAAa,IADE,EAAE,CAAC,GACL,AAAU,AAAX,CAAY,CAErD,GAAgB,SAAJ,AAAa,AAFC,GAEG,IAC/B,EAA+B,EAAa,IADD,EAAE,CAAC,AACF,AAAO,CAAC,AAExD,CAAC,AACqB,CAHyB,QAGhB,EAAE,CAAC,AAA9B,EAAS,CAHmB,GAGf,EAAL,CACV,EAA+B,EAAS,MAAD,IAAW,GAAI,CAAA,CAAK,AAE/D,CAFgE,AAE/D,AACH,CAAC,AACD,OAJkC,AAI3B,CACT,CAAC,0BADoC,CAAC,mEC5EtC,IAAA,EAAuC,CAAhC,CAAgC,CAA9B,AAA8B,CAAA,QAArB,AAGlB,EAHoB,EAGd,EAAyB,EAHL,YAAY,CAAC,KAGX,QAA+B,CAAC,AAWrD,KAAK,UAAU,EACpB,CAAqB,CACrB,CAAgB,CAChB,CAAS,MASL,EANJ,GAAI,AAMwB,CANvB,AAMwB,AA2E/B,OAvFgD,EAuFvC,AAAgB,CAAc,EACrC,GAlFoB,AAkFhB,CAAC,AAEH,QAHoB,CAEpB,EAAA,SAAA,AAAS,EAAC,IACH,CADQ,AAEjB,CAFkB,AAEjB,AAAC,CAFiB,CACN,CAAC,EACN,CACN,AADO,OACA,CACT,CAAC,AACH,CAAC,CAxFsB,CAsFP,CAAC,CArFb,GADyB,CAAC,EAAE,AACtB,AAAI,CADmB,IACd,CAAC,oCAAoC,CAAC,CAGvD,AAHwD,IAGlD,EAAkB,MAAM,EAAQ,KAAjB,AAAgB,EAAQ,CAAC,GAI9C,GAAI,EAAiB,CAAC,AACpB,GAAI,CAAC,AACH,EAAQ,GAAH,CAAO,CAAC,CAFE,CAJiD,CAAC,CAAC,CAMhD,CAAC,EACrB,CAAC,AAAC,KAAM,CACN,AADO,EACC,CAAA,CAAE,AACZ,CADO,AAAM,AACZ,AAED,CALoC,AAK/B,CALgC,AAK/B,CALgC,CAKvB,CAAG,CACpB,CAAC,GADe,CAAU,CAAC,AAEzB,CADK,CAAC,AACE,CACN,CAAC,CADE,CACO,CAAE,EACb,CAAC,AAGJ,EAJa,AAIL,CAJc,IAIf,EAAQ,CAAC,EAAsB,CAAA,EAAE,EAAA,SAAA,AAAS,EAAC,GACpD,CAWO,AAZiC,AACvC,CADwD,CAAC,CAAC,CAAC,CAYhD,UAAU,EACpB,CAAqB,CACrB,CAAgB,EAEhB,IAEI,EAFE,EAAkB,CAES,CAAC,IAFJ,EAAQ,KAAD,AAAhB,EAAwB,AAJK,CAIJ,GAI9C,GAAI,EAAiB,CAAC,AACpB,GAAI,CAAC,AACH,EAAQ,GAAH,CAAO,CAAC,CAFE,CAJiD,CAAC,CAAC,CAMhD,CAAC,EACrB,CAAC,AAAC,KAAM,CAAC,AACP,EAAQ,CAAA,CAAE,AACZ,CADa,AACZ,AAED,AAHO,CAF6B,CAAC,CAAC,IAK/B,CAAK,CAAC,EAAS,CAAC,AACvB,EAAQ,GADa,EACd,EAAQ,CAAC,EAAsB,CAAA,EAAE,EAAA,SAAA,AAAS,EAAC,GACpD,CADwC,AACvC,AACH,CAMO,AARoD,AAE1D,CAF2D,CAAC,CAAC,EAQlD,UAAU,EACpB,CAAqB,CACrB,CAAgB,EAEhB,IAAM,EAAW,MAAH,AAAS,EAAQ,KAAD,EAAQ,CAAC,GAJa,AAMpD,GAAI,CAAC,EACH,MADW,CACJ,CADM,CAAC,EACH,CAAC,AAGd,CAN6D,CAAC,CAAC,AAM3D,CAAC,AACH,IAAM,EAAQ,GAAH,CAAO,CAAC,KAAK,CAAC,GAEzB,GAAI,EAF6B,CAEtB,AAFuB,CAEtB,AAFuB,CAE1B,CAAY,CACnB,CADqB,CAAC,GAAJ,EACX,CAAK,CAAC,EAAS,CAAC,AAGzB,KAHuB,EAGhB,IAAI,AACb,CADc,AACb,AAAC,KAAM,CAAC,AACP,OAAO,IACT,AADa,CACZ,AACH,AAFgB,CAEf,mJC7FK,SAAU,EAAS,CAAc,EACrC,GADsB,GACf,AAAiB,QAAQ,SAAlB,GAAgC,EAA3B,EAA+B,CAAC,EAAf,CACtC,CAAC,AAQK,GATqC,MAS3B,EAAS,CAAc,EACrC,GADsB,GACE,QAAQ,CAAC,CAA1B,OAAO,CAChB,CAAC,AASK,GAVe,MAUL,EACd,CAAc,CACd,EAAc,EAAE,EAEhB,MAJ8B,CAIvB,EAAS,IAAU,CAAL,CAAN,AAAO,AAAS,EAAD,GAAM,CAAE,AAAD,GAAI,AAAK,CAAD,CAAF,CAAM,EAAI,EACvD,CAQM,AARL,EAD2D,CAAC,CAAC,KAS9C,EAKd,CAAc,CACd,CAGC,EAED,CAXsB,GAWhB,EAAW,GAAQ,GAAX,AAAS,AAAK,EAAI,EAC1B,EAAa,GAAQ,CADa,CAAC,CAChB,EAAT,AAAgB,EAAI,EACpC,MAD4C,CAAC,AAE3C,EAAS,IACT,CAAC,AADa,CAAC,AAAP,IACF,CAAC,OAAO,CAAC,IACf,CADoB,CAAC,IACf,CAAC,OAAO,CAAC,GAAO,EAAF,CAAC,EAAM,CAAC,CAAC,CAAC,CAAC,CAAE,CAAC,CAAC,EAAE,CAAG,CAAD,CAAU,CAAC,CAAC,EAAI,EAAP,AAAkB,CAAC,CAAC,CAExE,AAFyE,CAExE,AADE,CAAC,GADiE,wFG1C/D,SAAU,EAEd,CAAiB,CAEjB,CADA,AACiD,CAJ7B,AAKpB,CAJA,EAIa,CAAI,CDKF,AAAU,AAAa,ICFpC,IAIF,IAAM,CALU,CAAC,AAKO,EAAa,GAAG,CAAC,AAAC,ADAnB,EAAE,CCChB,ADDiB,ECAqB,AAChC,CADqB,CAAf,AAA4B,EAAE,KAC3B,CAAC,GAAG,EAAE,AAC1B,GFiBiC,UEb9B,GAAG,EAAE,AACV,IAlBgE,AAkB3D,IAAM,EAAE,EFiBS,CEjBL,EACf,EAAE,EAGR,CFc8B,AEd7B,AF/BD,IAAA,EAA4B,CEWiE,AFXtF,CAA+C,CE2BhB,AF3BgB,AAA7C,CAA6C,AE2Bf,IF3Bc,CAAC,EACtD,EAA0B,CADN,AACb,AAAwC,CAAC,CAAA,AAAvC,AADa,CAC0B,KADpB,GACV,AAElB,EAFoB,AAEqB,CAAlC,AAAwC,CAAA,CAAtC,AAAsC,CAAA,EAFrB,MAI1B,EAA8B,CAAvB,CAA2C,CAAzC,AAAwC,AAAC,CAAA,CAFmC,CAAC,MAGtF,EAA4B,CAArB,CAAgD,AADjC,CACb,AAA8C,CAD/B,AAC+B,CAHhB,EAAE,CAGa,CAAC,CADzB,EAY9B,EAXoB,EAAE,AAWhB,EAAuB,IAXD,cAWF,aAAkC,CACtD,AADuD,EAClC,gBAAH,WAA8B,CAAC,AACjD,EAAoB,GCRG,oBDQoB,CAAC,AAoB5C,SAAU,EAAwB,CAAqB,CElB7C,KFsBR,EAAiB,CAAA,CCbf,CDakB,CCbhB,CAAC,ADae,UAAH,CAAG,AAAW,EAAqB,QACpD,CAD6D,CAAC,AAC9D,CAD+D,AAC/D,EAAqB,EAAA,WAAA,AAAW,EAAsB,QACtD,CAD+D,CAC/D,AADgE,AAChE,CADiE,AACjE,EAAyB,EElBG,GAAA,QAAA,AFkBQ,OAAoB,GACxD,EAAA,CAAA,EACJ,CAFqE,CAAC,AAEtE,CAFuE,UAEvE,AAAW,EAAmB,SAAS,CAAC,CAAC,AAErC,ECdC,CAAA,EDcoB,EAAA,WAAW,AAAX,EAAgC,IAAI,GAAG,EAAE,AAGpE,CAHqE,CAAC,AAG/D,GAAG,EAAE,GACV,EAAA,WAAA,AAAW,EAAC,CAAC,GAAG,EAAmB,QAAQ,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CACxD,CAAC,EAAmB,CAAC,CAAC,AAGzB,EAAO,IAAD,CACJ,CCfC,GDeK,EAAW,EAAuB,IAA1B,IAAkC,EAAE,CAAC,AACnD,GAAI,CAAC,ICfI,CDc8B,IAKvC,CAJe,CAAC,EAIV,EAAe,EAAmB,QAAQ,EAAE,CAAC,GAAG,CAAC,EAAS,EAAE,CAAC,CAAC,AAE/D,CCjBD,CDe2D,CAE1C,IAAiB,GAKtC,EALiB,AAKM,GALU,AAAa,EAAE,CAAC,EAKlB,CAAC,EAClC,CAAC,CAAE,CAAC,EAAoB,EAAuB,CAAC,CADxB,AACyB,AAGjD,IAAM,EAA4B,CAAA,EAChC,EAAA,CAJoB,MAAwB,IAI5C,AAAW,EAA+B,IAAI,GAAG,CADjB,CACmB,AAE/C,CAFgD,CAAC,AAEjC,CAAA,EAAG,EAAA,SAAH,EAAG,AAAW,EAAC,IAE/B,CAFoC,CAEjB,AAFkB,CAAC,QClE9B,CAEM,EAE6B,CDgEX,CAAhB,AC7DtB,EDCqB,ECDf,EAAY,ECLR,EDKY,MAEV,ECLE,EDaR,EAAW,AAAC,CCNH,GDCb,IAK2B,AALtB,EAKwB,EALlB,AAKoB,OACvB,CANW,CAAI,GACrB,GAKc,CAAC,EANe,CAAE,CAAC,AACzB,CAUP,CAVS,CAAC,EAUJ,CCNH,CAAC,GDMO,AAAI,IACZ,OAvB0D,CAsBlC,CAAE,AACjB,CADkB,AACjB,GAAG,CDWkB,AAGf,CCdD,AACnB,EAAS,IACX,AAvByF,CAuBxF,CADS,ADgBN,ACfF,KADoB,EAAE,AAInB,CAJoB,CAAC,QAK1B,IACS,CDYW,GCbZ,CACM,CAAC,MAEL,GDeG,CCdX,EAAU,EADgB,CACb,CAAC,CDeP,ECdA,AADE,GACC,EAAE,AACV,AAFoB,CAAC,CAEX,AAFY,MAEN,CAAP,AAAQ,KAGtB,AACH,CADI,AACH,CD4BwC,CChCR,CAAC,CAAC,ADgCS,CACjC,CADmC,EAhBH,EAiB3B,CAAC,IAAI,CAAC,EAA6B,QAAQ,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,AACnE,CAAC,EAA6B,CAAC,CAAC,AAG7B,AAJ0C,EAIrB,AAAC,IAC1B,EADwC,EAAE,AACpC,EADsC,AAC3B,EAA6B,IADxB,AACR,IAAwC,EAAE,AAJ1B,CAI2B,AACzD,GAAI,EAAS,GAAG,CAAC,EAAL,AAAY,EAAE,CAAC,CAAJ,AACrB,AAF2C,CAChB,CAAC,KAG9B,AAFS,IAEH,EAAW,IAAI,EAAP,CAAU,CAAC,GACzB,EAAS,GADwB,AACrB,CADsB,AACrB,CADsB,CAC3B,AAAY,EAAE,CAAE,CAAL,EACnB,EAA6B,CADC,CAAC,CAAC,KACK,CAAC,EACxC,CAAC,CAAC,AAEI,EAAwB,AAAC,EAHiB,CAAC,CAK/C,AALgD,EAGL,EAAE,AAEvC,EAFyC,AAE9B,CALW,GAKP,EAAP,CAAU,CAAC,AADR,CADQ,CACqB,MACb,CAAC,CAAC,AADmB,EAAE,CAAC,CAEzD,EAAS,MAAD,AAAO,CAAC,EAAO,EAAE,CAAC,AAFmB,CAEvB,AAAK,AAC3B,EAA6B,QAAQ,CAAC,EACxC,CAAC,CAAC,AAEI,EAAqB,AAAC,EAHoB,CAAC,CAAC,EAGR,CACxC,CAD0C,CAC1C,CAD4C,CAHhB,KAGN,uBACtB,AAA8B,EAAC,EAAS,EAAO,EAAE,CAAX,AAAY,CAAJ,AAAK,AACnD,EAAsB,GAGlB,EAAkB,CAHM,CAAC,CAAC,KAGA,EAAE,GAAK,CAHhB,CAGA,EACnB,EADyC,AACjC,EADmC,CAAC,EACrC,KAAW,CAAC,GACnB,EAAmB,QAAQ,KADU,CACT,AADU,CAAC,CACrB,CAClB,EAAuB,IADc,CAAC,CAAC,EACR,MAAC,GAChC,EAAkB,CADI,GAAmB,CAAC,CAAC,EACjB,MAAC,CAAV,EACjB,EAAkC,IADE,CAAC,CAAC,EACI,CAAC,cAAc,CAAC,CAAC,AAE/D,CAAC,CAAC,AAQI,EAAmB,EAVY,GAUP,CAC5B,EACA,IADc,CAId,CALoB,CAEW,CAG3B,CAFJ,AACgB,AACX,EADkB,AADrB,IACoB,CACV,EAAE,CAAC,EADkB,EAAE,CAEjC,AAFkC,MAExB,AAAJ,KAAS,CAAC,kDAAkD,CAAC,CAAC,AAGtE,IAAM,EAAe,MAAM,CAAC,GAAV,EAAe,IAC3B,AAAJ,AADmC,EAAE,CACxB,IAAF,cAAoB,EAAI,CAAA,CAAA,EAAC,EAAA,aAAA,AAAa,EAAC,GACzC,GAD+C,CAAC,EAC1C,AAD4C,CAAC,CAExD,EACA,EAAQ,EADF,GACC,CAAO,CACd,EAAQ,KAAD,OAH+B,MAGZ,CAC1B,GAGK,CAEX,CAAC,CAAC,EAAE,AAiBJ,CAnBiB,AAEZ,CAFa,KAIlB,GAPwB,CACnB,CAAC,CAMA,EAAQ,KAAD,EAAQ,CAAC,EAAoB,EAAO,EAAE,CAAC,CAAC,AAAL,AAGhD,EAAmB,GAEf,GAFqB,AAEZ,CAFa,CAAC,AAHa,EAK7B,MAFO,OAEY,IAAK,GACjC,EADsC,AAChB,EADkB,CAAC,AAI3C,EAAO,IAAD,GAH8B,CAAC,CAAC,AAGtB,CAAC,IAHM,YAGU,CAAE,KAAK,IAAI,CAE1C,CAF4C,GAEtC,EAAY,MAAM,CAAT,CAA0B,EAAQ,GACjD,CAD+C,EACtC,CAD+C,CAAC,CAAC,CACnD,EADiC,GACtB,EAAE,CAAC,EAAW,EAAiB,KAAnB,GAA2B,EAAE,CAC7D,AAD8D,CAAC,AAC9D,CAAC,CAAC,AAD+C,AAG3C,CACT,CAAC,CAAC,AAEI,EAAU,KAAH,AAAQ,CAAE,CAHF,CAAC,AAGiB,IAAF,CAEnC,EAFoE,EAAE,AAEhE,EAFkE,AAEhD,MAAM,EAAiB,EAAQ,GAEvD,AAFqB,CAAgC,GAAS,CAAC,CAAC,CAChE,EAD8C,CACrC,IAAF,KAAW,EAAE,CAAC,EAAiB,EAAiB,QAAQ,EAAE,CAA7B,AAA8B,CAAC,AAC5D,CACT,CAFwD,AAEvD,CAAC,AAEI,EAAwB,AAAC,IAC7B,IAAM,EAAU,AAJM,CAAC,CAIM,AADoB,EAAE,CACtC,CADwC,GAA5B,GACG,AAAW,EAAE,CAAC,AAC1C,GAAI,CAAC,EACH,KADU,CACJ,AAAI,CADE,CAAC,GACE,CAAC,kDAAkD,CAAC,CAAC,AAItE,EAAmB,GAGnB,EAAkB,OAHa,CAAC,AAGN,CAHO,AAGN,EAHT,CAIlB,EAAmB,CADF,MAAsB,CAAC,AACb,CADc,AACb,GAC5B,EAAuB,EADL,AAAiB,CAAC,CAAC,IACN,CAAC,EAAa,QAAQ,CAA/B,CAAsB,AAAW,CAAC,CAAC,AACzD,EAAkC,QAAQ,CAAC,WAAW,CAAC,CAAC,AAQxD,IAAM,EAAgB,EAAa,CARF,QAQd,AAAyB,CAAV,AAChC,gBAAgB,CALQ,AAAC,CAMzB,GALA,EAAmB,IADyB,EAAE,EACnB,AADqB,CACpB,EAC9B,CAAC,AAIkB,CAJjB,AAKD,CAAC,AAEI,EAAoB,AARN,EAQmB,CARC,CAAC,CAAC,MAQM,CAAV,AAAW,GAA1B,WAAwC,CAAE,AAAC,GAChE,CADyE,CAAJ,AAC9C,EADgD,MACxC,CAAC,IAE5B,CAFiC,CAAC,AAEhB,CADvB,CAAC,AACmC,GAFb,MAEsB,CAAV,AAAW,CAA1B,WAAsC,CAAE,GAAG,EAAE,AAChE,GACF,CAAC,CAAC,CAEI,AAFH,EAEsB,GAAG,EAAE,AAC5B,EAAmB,CAJH,EAKhB,AALkB,CAAC,GAGC,AAGpB,IACA,CAH+B,CAAC,CAAC,AAInC,CAAC,AACH,CALsB,AACL,AAGb,AACH,CAAC,AAEI,CANa,CAMK,AANJ,KAMS,AALR,CAKU,CAJZ,AADI,CAAC,CACH,CAAC,AAKpB,EAAsB,CADH,EAGK,GAHyB,EAAE,EAAE,AAGtB,EAFG,AAED,CAFE,AAE/B,AAA8B,CAFE,CAEnB,EAAE,EACjB,AAHmB,MAGb,AADQ,EACA,KAAD,EAAQ,CAAC,EAAoB,EAAa,EAAE,CAAC,AAE9D,CAF+D,AAE9D,CAAC,AAIF,EACE,GAAG,AAPqD,CAMpD,CACC,AACH,EARwC,EAQlC,EAAS,EAAuB,EAA1B,MAAkC,EAAE,CAAC,AAC7C,EACF,EAAQ,EADA,EAAE,CAAC,AADwB,AAE5B,EAAQ,CAAC,EAAiB,CAAA,EAAE,EAAA,SAAA,AAAS,CAAX,CAAY,IAE7C,EAFmD,AAE3C,CAF4C,CAAC,CAAC,EAE/C,KAAW,CAAC,EAEvB,CAAC,CACD,CAAC,EAAuB,EACxB,GAIF,EACE,AALK,CACN,CAAC,CALwC,CAQpC,AARqC,CASpC,AATqC,IASjC,CAEP,CAFS,EANY,CAQf,EADW,AACL,CAAH,CADyB,MACd,EADsB,EAAE,CAAC,AACxB,GADY,AACT,CAAC,AAAC,GAAG,AAAK,CAAD,CAAF,CAAM,AAAE,EAAE,CAAC,CAAC,MAAM,CAAC,AAAC,CAAC,EAAE,AAAG,CAAC,CAAC,CAAC,CAAa,CAAC,AAE1E,EAAQ,KAAD,EAAQ,CACb,EAAoB,CAAA,EACpB,EAAA,SAAA,AAAS,EAAC,EADU,GACL,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,EAAI,CAAD,AAAE,CAAC,CAAC,CACzC,AACH,CADI,AACH,CACD,CAAC,EAAiB,EAClB,GAGF,EAHO,CACN,CAAC,AAEI,EAA0B,GAJb,EAIkB,CAAE,IACrC,CADiD,EAAE,CAC7C,CAD+C,CACtC,EAAkB,EAArB,CADe,KACc,EAAE,CAAC,AAC5C,GAAI,CAD4B,AAC3B,EACH,IADS,EAAE,AACL,AAAI,CADE,IACG,CAAC,wBAAwB,CAAC,CAAC,AAG5C,GAAI,CAAC,EAAO,IAAD,OAAY,CACrB,CADuB,CAAC,IAClB,AAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC,AAG9D,GAAI,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,GAAS,CAAC,AAE1B,EAFsB,CAAC,CAEjB,EAAmB,MAAM,EAAwB,GACvD,GADsB,AAClB,CAD0D,CAAC,AACzC,CAD0C,AACzC,AACrB,IAAM,EAAiB,EACpB,IAHiD,CAClC,GAEP,EADS,AACP,CACV,GAFoC,CAEhC,CAAC,AAAC,CAAC,EAAE,AAAG,CAAD,AAAE,CAAC,EAAE,GAAK,GACxB,GAAI,EAAgB,CAClB,AADmB,MACb,CAFgC,CAEjB,AAFkB,CAAC,EACxB,QACgB,CAAZ,AAAa,GACjC,EADsC,CAAC,CAAC,EAClC,EAAO,IAAD,OAAY,CAAC,GAEzB,EAF8B,AAER,CAFS,CAAC,CAGhC,GAD4B,CAAC,CAAC,CAEhC,CADS,AACR,AACH,CAAC,AAED,MAAM,EALmB,AAKZ,IAAD,OAAY,CAAC,GACzB,EAD8B,AACR,CADS,CAAC,AAElC,CAAC,GAD6B,CAAC,CAAC,AAE9B,CADK,CAAC,IACA,EAAO,GAFQ,CAET,OAAY,CAAC,GAI3B,EAJgC,AAIT,CAJU,CAAC,MAIH,CAAC,EAAO,IAAD,IAAS,CAAzB,CAA2B,CAAC,AACpD,CADqD,AACpD,CAAC,AAuBF,MAAO,oBACL,kBAAkB,OAClB,sBAAsB,cACtB,EACA,iBAAiB,GACjB,WAFiC,OAEf,WAClB,OAAO,YACP,EACA,YAAY,CA7Bd,CA4BkB,QA5BT,AAAa,CAAe,EACnC,IAAM,EAAgB,EAAmB,CADtB,OAC8B,CAA9B,CAAgC,CASnD,AAToD,GAG9B,CAMlB,CANyB,AAHW,IAGZ,CAAM,CAAC,AAAC,CAAC,EAAE,CACrC,CADuC,CAMxB,EAAE,AALX,CAKY,CALG,EAAc,GAAG,CAAC,CAAC,CAAC,EAAE,AAAzB,CAA0B,CAAC,AAE7C,CAFkC,KAElC,CAAA,EAAO,EAAA,SAAA,AAAS,EAAC,KAAa,CAAA,EAAK,EAAA,EAAN,CAAC,MAAc,AAAT,EAAU,CAAC,CAAC,AACjD,CADkD,AACjD,CAAC,CAAC,AAGD,OAAO,AAGT,IAAM,EAAY,IAAI,GAAP,AAAU,CAAC,GAC1B,IAAK,IAAM,CAAC,CAD2B,CAAC,CAAC,CACzB,EACd,EAAU,EADU,CAAE,AACT,CADU,AACT,CAAC,CAAC,CAAP,CAAS,CAAE,CAAC,CAAC,CAAC,AAEzB,EAAmB,QAAQ,CAAC,EAC9B,CAAC,CAWC,GAZkB,EAAmB,CAAC,CAAC,SAYvB,CAtMO,AAAC,IACxB,EADsC,AACnB,EADqB,CAExC,CAF0C,CAEnC,CADkB,CAAC,CAAC,CACrB,MAAW,CADC,CAEpB,AADqB,CAAC,AACrB,CAAC,iBAoMA,gBAAgB,GAChB,gBAAgB,QAChB,kBACA,GADqB,YACN,WACf,EACD,AACH,CADI,AACH,AAMM,KAAK,UAAU,EACpB,CAAqB,EATI,AAWzB,GAAI,CAAC,AACH,IAAM,EAAQ,GAAH,GAAS,EAAQ,IAJiB,CAIlB,EAAQ,CAAC,GACpC,GAAI,EACF,GADO,EAAE,CAAC,CACH,IAAI,CAF2C,AAE1C,CAF2C,CAAC,GAEvC,CAAC,GAEpB,EAFyB,CAAa,CAAC,EAEhC,EAAE,AACX,CADY,AACX,AAAC,KAAM,CAAC,AACP,MAAO,EAAE,AACX,CADY,AACX,AACH,CAAC,AAKM,KAAK,UAAU,EACpB,CAAqB,EAErB,GAAI,CAAC,AACH,IAAM,EAAQ,GAAH,GAAS,EAAQ,AAJa,KAId,EAAQ,CAAC,GACpC,GAAI,EACF,GADO,EAAE,CAAC,CACH,CAEX,CAAC,AAAC,CAJsD,CAAC,CAAC,AAE9B,CAAC,CAErB,CAAC,CAAC,AAEV,OAAO,IAAI,AACb,CAKO,AALN,AADa,KAMF,UAAU,EACpB,CAAqB,EAErB,GAAI,CAAC,AACH,IAAM,EAAQ,GAAH,GAJ4B,AAInB,EAAQ,KAAD,EAAQ,CAAC,GACpC,GAAI,EACF,GADO,EAAE,CAAC,CACH,EAF4C,CAAC,CAEzC,AAF0C,CAEzC,KAAK,CAAC,EAEtB,CAAC,AAAC,EAFyB,CAAU,CAAC,CAE9B,CAAC,CAAC,AAEV,OAAO,IAAI,AACb,CADc,AACb,AAKM,IAAM,EAA8B,KAAK,CAC9C,EACA,EACA,EACA,EAFsB,CADL,EAEU,AAG3B,IAAM,EAAS,EAAU,AANa,EAM1B,GAFgC,EAEpB,AADxB,EAAE,CACiC,EAAE,CAAC,AACtC,GAAI,CAAC,EACH,IADS,EAAE,AACL,AAAI,CADE,IACG,CAAC,kDAAkD,CAAC,CAAC,AAGtE,IAAM,EAAM,CAAA,EAAG,CAAH,CAAG,WAAA,AAAW,EAAC,EAE3B,KAFkC,CAAC,CAAC,AAE9B,EAAO,IAAD,GAAQ,CAAC,CACnB,KAAK,CAAE,EAAQ,KAAK,AAAN,CACd,MAAM,CAAE,EACR,IADc,WACC,CAAE,EAClB,CAAC,CAAC,AAGH,EAJyB,EAInB,EAAkB,EAAU,OAAD,EAAU,CAAC,CAAvB,WAAmC,CAAE,GAAG,EAAE,AAC7D,GACF,CAAC,CAAC,CAAC,AACG,EAAmB,GAAG,EAAE,AAC5B,GAHgB,CAIhB,CAJkB,CAAC,AAIA,EACrB,CAHsB,AAGrB,CAAC,AAEF,EAH2B,CAAC,CAAC,CADZ,EAIV,AAJY,CAAC,AAKtB,CAAC,CAAC,EAJoB,CAGP,CAAC,qKGzZhB,IAAA,EAA8B,EAAA,CAArB,AAAqB,CAAA,QAC9B,EAA0B,EAAA,CAAA,AAAjB,CAAiB,MADI,EAE9B,EAA8B,EAAA,CAArB,AAAqB,CAAA,EADJ,MA+Eb,EAAN,UA9EuB,IAmFpB,EAAA,SAAA,CAAU,EAKlB,GACA,GACA,AAEA,aAAY,CAAA,CAA6D,CACvE,KAAA,CAAM,EAEN,IAAA,CAAK,UAAA,CAAa,EAAO,UAAA,CACzB,IAAA,CAAA,CAAA,CAAK,CAAiB,EAAO,aAAA,CAC7B,IAAA,CAAA,CAAA,CAAK,CAAa,CAAC,CAAA,CACnB,IAAA,CAAK,KAAA,CAAQ,EAAO,KAAA,EAAS,IAE7B,IAAA,CAAK,OAFwC,GAExC,CAAW,EAAO,OAAO,EAC9B,IAAA,CAAK,UAAA,CAAW,CAClB,CAEA,WACE,CAAA,CACM,CACN,IAAA,CAAK,OAAA,CAAU,EAEf,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,OAAA,CAAQ,MAAM,CACvC,CAEA,IAAI,MAAiC,CACnC,OAAO,IAAA,CAAK,OAAA,CAAQ,IAAA,AACtB,CAEA,YAAY,CAAA,CAAsD,CAC3D,IAAA,CAAA,CAAA,CAAK,CAAW,QAAA,CAAS,KAC5B,GADoC,CACpC,CAAA,CADuC,AACvC,CAAK,CAAW,IAAA,CAAK,GAGrB,IAAA,CAH6B,AAGxB,cAAA,CAAe,EAEpB,IAAA,CAAA,CAAA,CAAK,CAAe,MAAA,CAAO,CACzB,KAAM,gBACN,SAAU,IAAA,UACV,CACF,CAAC,EAEL,CAEA,eAAe,CAAA,CAAsD,CACnE,IAAA,CAAA,CAAA,CAAK,CAAa,IAAA,CAAA,CAAA,AAAK,CAAA,CAAW,MAAA,CAAO,AAAC,GAAM,IAAM,GAEtD,IAAA,CAF8D,AAEzD,UAAA,CAAW,EAEhB,IAAA,CAAA,CAAA,CAAK,CAAe,MAAA,CAAO,CACzB,KAAM,kBACN,SAAU,IAAA,UACV,CACF,CAAC,CACH,CAEU,gBAAiB,CACpB,IAAA,CAAA,CAAA,CAAK,CAAW,MAAA,EAAQ,CACD,WAAW,CAAjC,IAAA,CAAK,KAAA,CAAM,MAAA,CACb,IAAA,CAAK,UAAA,CAAW,EAEhB,IAAA,CAAA,CAAA,CAAK,CAAe,MAAA,CAAO,IAAI,EAGrC,CAEA,UAA6B,CAC3B,OACE,IAAA,CAAA,CAAA,CAAK,EAAU,SAAS,GAExB,EAFwB,EAExB,CAAK,OAAA,CAAQ,IAAA,CAAK,KAAA,CAAM,SAAU,CAEtC,CAEA,MAAM,QAAQ,CAAA,CAAuC,CACnD,IAAM,EAAa,KACjB,CADuB,GACvB,CAAA,CAAA,CAAK,CAAU,CAAE,KAAM,UAAW,CAAC,CACrC,EAEA,IAAA,CAAA,CAAA,CAAK,CAAA,CAAA,AAXqB,EAWV,EAAA,aAAA,EAAc,CAC5B,GAAI,IACF,AAAK,EADG,EACJ,AAAC,CAAK,OAAA,CAAQ,UAAA,CAGX,CAHuB,GAGvB,CAAK,OAAA,CAAQ,UAAA,CAAW,GAFtB,MAE+B,EAFvB,MAAA,CAAO,AAAI,MAAM,qBAAqB,CAAC,EAI1D,OAAQ,CAAC,EAAc,KACrB,IAAA,CAD+B,AAC/B,CAAA,CAAK,CAAU,CAAE,KAAM,SAAU,eAAc,OAAM,CAAC,CACxD,EACA,QAAS,KACP,CADa,GACb,CAAA,CAAA,CAAK,CAAU,CAAE,KAAM,OAAQ,CAAC,CAClC,aACA,EACA,MAAO,IAAA,CAAK,OAAA,CAAQ,KAAA,EAAS,EAC7B,WAAY,IAAA,CAAK,OAAA,CAAQ,UAAA,CACzB,YAAa,IAAA,CAAK,OAAA,CAAQ,WAAA,CAC1B,OAAQ,IAAM,IAAA,CAAA,CAAA,AAAK,CAAA,CAAe,MAAA,CAAO,IAAI,CAC/C,CAAC,EAED,IAAM,EAAiC,YAAtB,IAAA,CAAK,KAAA,CAAM,MAAA,CACtB,EAAW,CAAC,IAAA,CAAA,CAAA,CAAK,CAAS,QAAA,CAAS,EAEzC,GAAI,CACF,GAAI,EAEF,QAFY,AAGP,CACL,EAFW,EAEX,CAAA,CAAA,CAAK,CAAU,CAAE,KAAM,oBAAW,WAAW,CAAS,CAAC,EAEvD,MAAM,IAAA,CAAA,CAAA,CAAK,CAAe,MAAA,CAAO,QAAA,GAC/B,EACA,IAAA,EAEF,IAAM,EAAU,MAAM,IAAA,CAAK,OAAA,CAAQ,QAAA,GAAW,GAC1C,IAAY,EADuC,EACvC,CAAK,KAAA,CAAM,OAAA,EAAS,AAClC,IAAA,CAAA,CAAK,AAAL,CAAK,CAAU,CACb,KAAM,kBACN,YACA,WACA,CACF,CAAC,CAEL,CACA,IAAM,EAAO,MAAM,IAAA,CAAA,CAAA,CAAK,CAAS,KAAA,CAAM,EAwBvC,OArBA,MAAM,IAAA,CAAA,CAAA,CAAK,CAAe,MAAA,CAAO,SAAA,GAC/B,EACA,EACA,IAAA,CAAK,KAAA,CAAM,OAAA,CACX,IAAA,EAGF,MAAM,IAAA,CAAK,OAAA,CAAQ,SAAA,GAAY,EAAM,EAAW,IAAA,CAAK,KAAA,CAAM,OAAQ,EAGnE,MAAM,IAAA,CAAA,CAAA,CAAK,CAAe,MAAA,CAAO,SAAA,GAC/B,EACA,KACA,IAAA,CAAK,KAAA,CAAM,SAAA,CACX,IAAA,CAAK,KAAA,CAAM,OAAA,CACX,IAAA,EAGF,MAAM,IAAA,CAAK,OAAA,CAAQ,SAAA,GAAY,EAAM,KAAM,EAAW,IAAA,CAAK,KAAA,CAAM,OAAO,EAExE,IAAA,CAAA,CAAA,CAAK,CAAU,CAAE,KAAM,eAAW,CAAK,CAAC,EACjC,CACT,CAAA,MAAS,EAAO,CACd,GAAI,CA8BF,MA5BA,MAAM,IAAA,CAAA,CAAA,CAAK,CAAe,MAAA,CAAO,OAAA,GAC/B,EACA,EACA,IAAA,CAAK,KAAA,CAAM,OAAA,CACX,IAAA,EAGF,MAAM,IAAA,CAAK,OAAA,CAAQ,OAAA,GACjB,EACA,EACA,IAAA,CAAK,KAAA,CAAM,OAAA,EAIb,MAAM,IAAA,CAAA,CAAA,CAAK,CAAe,MAAA,CAAO,SAAA,GAC/B,KAAA,EACA,EACA,IAAA,CAAK,KAAA,CAAM,SAAA,CACX,IAAA,CAAK,KAAA,CAAM,OAAA,CACX,IAAA,EAGF,MAAM,IAAA,CAAK,OAAA,CAAQ,SAAA,GACjB,KAAA,EACA,EACA,EACA,IAAA,CAAK,KAAA,CAAM,OAAA,EAEP,CACR,QAAE,CACA,IAAA,CAAA,CAAA,CAAK,CAAU,CAAE,KAAM,cAAS,CAAuB,CAAC,CAC1D,CACF,QAAE,CACA,IAAA,CAAA,CAAA,CAAK,CAAe,OAAA,CAAQ,IAAI,CAClC,CACF,GAEA,CAAU,CAAA,EAA2D,AAwDnE,IAAA,CAAK,KAAA,CAAQ,CAvDG,AACd,IAEA,MADuD,CAC/C,EAAO,IAAA,EAAM,AACnB,IAAK,SACH,MAAO,CACL,GAAG,CAAA,CACH,aAAc,EAAO,YAAA,CACrB,cAAe,EAAO,KAAA,AACxB,CACF,KAAK,QACH,MAAO,CACL,GAAG,CAAA,CACH,UAAU,CACZ,CACF,KAAK,WACH,MAAO,CACL,GAAG,CAAA,CACH,UAAU,CACZ,CACF,KAAK,UACH,MAAO,CACL,GAAG,CAAA,CACH,QAAS,EAAO,OAAA,CAChB,KAAM,KAAA,EACN,aAAc,EACd,cAAe,KACf,MAAO,KACP,SAAU,EAAO,QAAA,CACjB,OAAQ,UACR,UAAW,EAAO,SAAA,CAClB,YAAa,KAAK,GAAA,CAAI,CACxB,CACF,KAAK,UACH,MAAO,CACL,GAAG,CAAA,CACH,KAAM,EAAO,IAAA,CACb,aAAc,EACd,cAAe,KACf,MAAO,KACP,OAAQ,UACR,UAAU,CACZ,CACF,KAAK,QACH,MAAO,CACL,GAAG,CAAA,CACH,KAAM,KAAA,EACN,MAAO,EAAO,KAAA,CACd,aAAc,EAAM,YAAA,CAAe,EACnC,cAAe,EAAO,KAAA,CACtB,SAAU,GACV,OAAQ,OACV,CACJ,EACF,EACqB,IAAA,CAAK,KAAK,EAE/B,EAAA,aAAA,CAAc,KAAA,CAAM,KAClB,CADwB,GACxB,CAAA,CAAA,CAAK,CAAW,OAAA,CAAQ,AAAC,IACvB,EAAS,OAD2B,SAC3B,CAAiB,EAC5B,CAAC,EACD,CAFkC,GAElC,CAAA,CAAA,CAAK,CAAe,MAAA,CAAO,CACzB,SAAU,IAAA,CACV,KAAM,iBACN,CACF,CAAC,CACH,CAAC,CACH,CACF,EAEO,SAAS,IAMd,MAAO,CACL,OAFoD,CAE3C,KAAA,EACT,KAAM,KAAA,EACN,MAAO,KACP,aAAc,EACd,cAAe,KACf,UAAU,EACV,OAAQ,OACR,UAAW,KAAA,EACX,YAAa,CACf,CACF,0EC3WM,SAAU,EACd,CAAwB,CACxB,CAAgB,EAEhB,EAAY,SAAD,KAJ0B,GAIR,CAAC,CAC5B,QAAQ,CAAE,EAAU,CAAC,IAAJ,CAAC,CAAC,SAAiB,CAAE,EAAQ,CAAC,AAAE,CAAD,AAAE,GAAL,YAAoB,CAAC,CACnE,CAAC,CAAC,AACH,EAAY,SAAD,QAAkB,CAAC,CAC5B,QAAQ,CAAE,EACN,CAAC,IADY,sBACc,CAAE,EAAQ,CACrC,CAAC,GADmC,uBACT,CAAC,CACjC,CAAC,CACF,AADG,EACS,SAAD,QAAkB,CAAC,CAC5B,QAAQ,CAAE,EAAU,CAAC,IAAJ,CAAC,CAAC,AAAQ,CAAE,EAAQ,CAAC,AAAE,CAAD,AAAE,GAAL,GAAW,CAAC,CACjD,CAAC,CAAC,AACH,EAAY,SAAD,QAAkB,CAAC,CAC5B,QAAQ,CAAE,EAAU,CAAC,IAAJ,CAAC,CAAC,EAAU,CAAE,EAAQ,CAAC,AAAE,CAAD,AAAE,GAAL,KAAa,CAAC,CACrD,CAAC,AACJ,CADK,AACJ,gECjBM,IAAM,EAAqB,CAAA,EAAG,AAFC,EAAA,CAAA,CAAA,QAED,IAAH,SAAG,AAAa,EAEhD,GAAG,EAAI,CAAC,CAAC,CAAC,yGUFV,EAAA,EAAA,CAAA,CAAA,QTFF,EAAA,EAAA,CAAA,CAAA,QGCA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACI,EAAa,cAAc,EAAA,YAAY,CACzC,YAAY,EAAS,CAAC,CAAC,CAAE,CACvB,KAAK,GACL,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,EAAC,CAAA,AAAQ,CAAmB,EAAhB,EAAoB,GACtC,EACA,CAAQ,AAAR,AAAS,CACT,IAH+B,EAGzB,CAAM,CAAE,CAAO,CAAE,CAAK,CAAE,CAC5B,IAAM,EAAW,EAAQ,QAAQ,CAC3B,EAAY,EAAQ,SAAS,EAAI,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAAC,EAAU,GACnE,EAAQ,IAAI,CAAC,GAAG,CAAC,GAYrB,OAXK,IACH,EAAQ,CADE,GACE,EAAA,KAAK,CAAC,QAChB,WACA,YACA,EACA,QAAS,EAAO,mBAAmB,CAAC,SACpC,EACA,eAAgB,EAAO,gBAAgB,CAAC,EAC1C,GACA,IAAI,CAAC,GAAG,CAAC,IAEJ,CACT,CACA,IAAI,CAAK,CAAE,CACJ,IAAI,EAAC,CAAA,AAAQ,CAAC,GAAG,CAAC,EAAM,SAAS,GAAG,CACvC,IAAI,EAAC,CAAA,AAAQ,CAAC,GAAG,CAAC,EAAM,SAAS,CAAE,GACnC,IAAI,CAAC,MAAM,CAAC,CACV,KAAM,cACN,CACF,GAEJ,CACA,OAAO,CAAK,CAAE,CACZ,IAAM,EAAa,IAAI,EAAC,CAAA,AAAQ,CAAC,GAAG,CAAC,EAAM,SAAS,EAChD,IACF,EAAM,MADQ,CACD,GACT,IAAe,GACjB,IADwB,AACpB,EAAC,CAAA,AAAQ,CAAC,MAAM,CAAC,EAAM,SAAS,EAEtC,IAAI,CAAC,MAAM,CAAC,CAAE,KAAM,gBAAW,CAAM,GAEzC,CACA,OAAQ,CACN,EAAA,aAAa,CAAC,KAAK,CAAC,KAClB,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,AAAC,IACrB,IAAI,CAAC,MAAM,CAAC,EACd,EACF,EACF,CACA,IAAI,CAAS,CAAE,CACb,OAAO,IAAI,CAAC,CAAA,CAAQ,CAAC,GAAG,CAAC,EAC3B,CACA,QAAS,CACP,MAAO,IAAI,IAAI,CAAC,CAAA,CAAQ,CAAC,MAAM,GAAG,AACpC,CACA,KAAK,CAAO,CAAE,CACZ,IAAM,EAAmB,CAAE,OAAO,EAAM,GAAG,CAAO,AAAC,EACnD,OAAO,IAAI,CAAC,MAAM,GAAG,IAAI,CACvB,AAAC,GAAU,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAkB,GAE5C,CACA,QAAQ,EAAU,CAAC,CAAC,CAAE,CACpB,IAAM,EAAU,IAAI,CAAC,MAAM,GAC3B,OAAO,OAAO,IAAI,CAAC,GAAS,MAAM,CAAG,EAAI,EAAQ,MAAM,CAAC,AAAC,GAAU,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAS,IAAU,CACnG,CACA,OAAO,CAAK,CAAE,CACZ,EAAA,aAAa,CAAC,KAAK,CAAC,KAClB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAE,AAAD,IACrB,EAAS,EACX,EACF,EACF,CACA,SAAU,CACR,EAAA,aAAa,CAAC,KAAK,CAAC,KAClB,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,AAAC,IACrB,EAAM,OAAO,EACf,EACF,EACF,CACA,UAAW,CACT,EAAA,aAAa,CAAC,KAAK,CAAC,KAClB,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,AAAC,IACrB,EAAM,QAAQ,EAChB,EACF,EACF,CACF,EF1FA,EAAA,EAAA,CAAA,CAAA,YAGI,EAAgB,cAAc,EAAA,YAAY,CAC5C,YAAY,EAAS,CAAC,CAAC,CAAE,CACvB,KAAK,GACL,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,EAAC,CAAA,AAAU,CAAmB,EAAhB,EAAoB,IACtC,IAAI,EAAC,CAD0B,AAC1B,AAAO,CAAmB,EAAhB,EAAoB,IACnC,IAAI,EAAC,CADuB,AACvB,AAAW,CAAG,CACrB,CACA,CAAA,CAAU,AAAC,EACX,CAAQ,AAAD,AAAP,EACA,CAAA,AAAW,AAAC,CACZ,MAAM,CAAM,CAAE,CAAO,CAAE,CAAK,CAAE,CAC5B,IAAM,EAAW,IAAI,EAAA,QAAQ,CAAC,CAC5B,cAAe,IAAI,CACnB,WAAY,EAAE,IAAI,EAAC,CAAW,AAAX,CACnB,QAAS,EAAO,sBAAsB,CAAC,GACvC,OACF,GAEA,OADA,IAAI,CAAC,GAAG,CAAC,GACF,CACT,CACA,IAAI,CAAQ,CAAE,CACZ,IAAI,EAAC,CAAA,AAAU,CAAC,GAAG,CAAC,GACpB,IAAM,EAAQ,EAAS,GACvB,GAAqB,UAAjB,OAAO,EAAoB,CAC7B,IAAM,EAAkB,IAAI,EAAC,CAAA,AAAO,CAAC,GAAG,CAAC,GACrC,EACF,EAAgB,IAAI,CAAC,GAErB,IAAI,CAHe,AAGd,CAAA,CAAO,CAAC,GAAG,CAAC,EAAO,CAAC,EAAS,CAEtC,CACA,IAAI,CAAC,MAAM,CAAC,CAAE,KAAM,iBAAS,CAAS,EACxC,CACA,OAAO,CAAQ,CAAE,CACf,GAAI,IAAI,EAAC,CAAA,AAAU,CAAC,MAAM,CAAC,GAAW,CACpC,IAAM,EAAQ,EAAS,GACvB,GAAqB,UAAjB,OAAO,EAAoB,CAC7B,IAAM,EAAkB,IAAI,EAAC,CAAA,AAAO,CAAC,GAAG,CAAC,GACzC,GAAI,EACF,GAAI,EAAgB,MAAM,CAAG,EAAG,CADb,AAEjB,IAAM,EAAQ,EAAgB,OAAO,CAAC,EAClC,CAAU,CAAC,GAAG,IAChB,EAAgB,MAAM,CAAC,EAAO,EAElC,MAAW,CAAe,AAAnB,CAAoB,EAAE,GAAK,GAChC,IAAI,EAAC,CADqC,AACrC,AAAO,CAAC,MAAM,CAAC,EAG1B,CACF,CACA,IAAI,CAAC,MAAM,CAAC,CAAE,KAAM,mBAAW,CAAS,EAC1C,CACA,OAAO,CAAQ,CAAE,CACf,IAAM,EAAQ,EAAS,GACvB,GAAI,AAAiB,iBAAV,EAOT,MAAO,EAPsB,EAC7B,IAAM,EAAyB,IAAI,EAAC,CAAA,AAAO,CAAC,GAAG,CAAC,GAC1C,EAAuB,GAAwB,KACnD,AAAC,GAAyB,YAAnB,EAAE,KAAK,CAAC,MAAM,EAEvB,MAAO,CAAC,GAAwB,IAAyB,CAC3D,CAGF,CACA,KAJS,GAID,CAAQ,CAAE,CAChB,IAAM,EAAQ,EAAS,GACvB,GAAqB,UAAjB,OAAO,EAIT,OAAO,QAAQ,OAAO,EAJO,EAC7B,IAAM,EAAgB,IAAI,EAAC,CAAA,AAAO,CAAC,GAAG,CAAC,IAAQ,KAAK,AAAC,GAAM,IAAM,GAAY,EAAE,KAAK,CAAC,QAAQ,EAC7F,OAAO,GAAe,YAAc,QAAQ,OAAO,EACrD,CAGF,CACA,KAJS,EAID,CACN,EAAA,aAAa,CAAC,KAAK,CAAC,KAClB,IAAI,CAAC,CAAA,CAAU,CAAC,OAAO,CAAC,AAAC,IACvB,IAAI,CAAC,MAAM,CAAC,CAAE,KAAM,mBAAW,CAAS,EAC1C,GACA,IAAI,EAAC,CAAU,AAAV,CAAW,KAAK,GACrB,IAAI,EAAC,CAAA,AAAO,CAAC,KAAK,EACpB,EACF,CACA,QAAS,CACP,OAAO,MAAM,IAAI,CAAC,IAAI,EAAC,CAAA,AAAU,CACnC,CACA,KAAK,CAAO,CAAE,CACZ,IAAM,EAAmB,CAAE,OAAO,EAAM,GAAG,CAAO,AAAC,EACnD,OAAO,IAAI,CAAC,MAAM,GAAG,IAAI,CACvB,AAAC,GAAa,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,EAAkB,GAElD,CACA,QAAQ,EAAU,CAAC,CAAC,CAAE,CACpB,OAAO,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,AAAC,GAAa,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,EAAS,GACnE,CACA,OAAO,CAAK,CAAE,CACZ,EAAA,aAAa,CAAC,KAAK,CAAC,KAClB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,AAAC,IACtB,EAAS,EACX,EACF,EACF,CACA,uBAAwB,CACtB,IAAM,EAAkB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,AAAC,GAAM,EAAE,KAAK,CAAC,QAAQ,EACpE,OAAO,EAAA,aAAa,CAAC,KAAK,CACxB,IAAM,QAAQ,GAAG,CACf,EAAgB,GAAG,CAAE,AAAD,GAAc,EAAS,QAAQ,GAAG,KAAK,CAAC,EAAA,IAAI,IAGtE,CACF,EACA,SAAS,EAAS,CAAQ,EACxB,OAAO,EAAS,OAAO,CAAC,KAAK,EAAE,EACjC,CD1GA,IAAA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QEXA,SAAS,EAAsB,CAAK,EAClC,MAAO,CACL,QAAS,CAAC,EAAS,KACjB,IAAM,EAAU,EAAQ,OAAO,CACzB,EAAY,EAAQ,YAAY,EAAE,MAAM,WAAW,UACnD,EAAW,EAAQ,KAAK,CAAC,IAAI,EAAE,OAAS,EAAE,CAC1C,EAAgB,EAAQ,KAAK,CAAC,IAAI,EAAE,YAAc,EAAE,CACtD,EAAS,CAAE,MAAO,EAAE,CAAE,WAAY,EAAG,AAAD,EACpC,EAAc,EACZ,EAAU,UACd,IAAI,GAAY,EAgBV,EAAU,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,EAAQ,OAAO,CAAE,EAAQ,YAAY,EAC7D,EAAY,MAAO,EAAM,EAAO,SAQ5B,EAPR,GAAI,EACF,OAAO,EADM,MACE,MAAM,GAEvB,GAAI,AAAS,SAAQ,EAAK,KAAK,CAAC,MAAM,CACpC,CADsC,MAC/B,QAAQ,OAAO,CAAC,GAazB,IAAM,GAjCN,OAAO,OAiCgB,OAjCF,CAAC,EAuBI,CACtB,OAAQ,EAAQ,MAAM,CACtB,SAAU,EAAQ,QAAQ,CAC1B,UAAW,EACX,UAAW,EAAW,WAAa,UACnC,KAAM,EAAQ,OAAO,CAAC,IAAI,AAC5B,EA7B4B,SAAU,CACtC,YAAY,EACZ,IAAK,KACC,EAAQ,MAAM,CAAC,OAAO,CACxB,CAD0B,EACd,EAEZ,EAAQ,MAAM,CAAC,gBAAgB,CAAC,QAAS,KACvC,GAAY,CACd,GAEK,EAAQ,MAAM,CAEzB,GAmBS,GAGH,EAAO,MAAM,EAAQ,GACrB,UAAE,CAAQ,CAAE,CAAG,EAAQ,OAAO,CAC9B,EAAQ,EAAW,EAAA,UAAU,CAAG,EAAA,QAAQ,CAC9C,MAAO,CACL,MAAO,EAAM,EAAK,KAAK,CAAE,EAAM,GAC/B,WAAY,EAAM,EAAK,UAAU,CAAE,EAAO,EAC5C,CACF,EACA,GAAI,GAAa,EAAS,MAAM,CAAE,CAChC,IAAM,EAAW,AAAc,eAEzB,EAAU,CACd,MAAO,EACP,WAAY,CACd,EACM,EAAQ,AALM,GAgD9B,QAhDyC,CAgDhC,AAAqB,CAAO,CAAE,CAAE,OAAK,YAAE,CAAU,CAAE,EAC1D,OAAO,EAAM,MAAM,CAAG,EAAI,EAAQ,oBAAoB,GAAG,CAAK,CAAC,EAAE,CAAE,EAAO,CAAU,CAAC,EAAE,CAAE,GAAc,KAAK,CAC9G,EAlDgE,CAAA,EAK5B,EAAS,GACnC,EAAS,MAAM,EAAU,EAAS,EAAO,EAC3C,KAAO,CACL,IAAM,EAAiB,GAAS,EAAS,MAAM,CAC/C,EAAG,CACD,IAAM,EAAwB,IAAhB,EAAoB,CAAa,CAAC,EAAE,EAAI,EAAQ,gBAAgB,CAAG,EAAiB,EAAS,GAC3G,GAAI,EAAc,GAAc,MAAT,AAAe,EACpC,MAEF,EAAS,MAAM,EAAU,EAAQ,GACjC,GACF,OAAS,EAAc,EAAgB,AACzC,CACA,OAAO,CACT,EACI,EAAQ,OAAO,CAAC,SAAS,CAC3B,CAD6B,CACrB,OAAO,CAAG,IACT,EAAQ,OAAO,CAAC,SAAS,GAC9B,EACA,CACE,OAAQ,EAAQ,MAAM,CACtB,SAAU,EAAQ,QAAQ,CAC1B,KAAM,EAAQ,OAAO,CAAC,IAAI,CAC1B,OAAQ,EAAQ,MAAM,AACxB,EACA,GAIJ,EAAQ,OAAO,CAAG,CAEtB,CACF,CACF,CACA,SAAS,EAAiB,CAAO,CAAE,OAAE,CAAK,YAAE,CAAU,CAAE,EACtD,IAAM,EAAY,EAAM,MAAM,CAAG,EACjC,OAAO,EAAM,MAAM,CAAG,EAAI,EAAQ,gBAAgB,CAChD,CAAK,CAAC,EAAU,CAChB,EACA,CAAU,CAAC,EAAU,CACrB,GACE,KAAK,CACX,CFzFA,IAAI,EAAc,OAChB,CAAA,AAAW,AAAC,AACZ,CAAA,EAAc,AAAC,EACf,CAAA,AAAe,AAAC,EAChB,CAAA,AAAc,AAAC,EACf,CAAA,AAAiB,AAAC,AAClB,CAAA,EAAW,AAAC,EACZ,CAAkB,AAAlB,AAAiB,EACjB,CAAA,AAAkB,AAAC,AACnB,aAAY,EAAS,CAAC,CAAC,CAAE,CACvB,IAAI,EAAC,CAAA,AAAW,CAAG,EAAO,UAAU,EAAI,IAAI,EAC5C,IAAI,EAAC,CAAA,AAAc,CAAG,EAAO,aAAa,EAAI,IAAI,EAClD,IAAI,EAAC,CAAA,AAAe,CAAG,EAAO,cAAc,EAAI,CAAC,EACjD,IAAI,CAAC,CAAA,CAAc,CAAmB,EAAhB,EAAoB,IAC1C,IAAI,EAAC,CAD8B,AAC9B,AAAiB,CAAmB,EAAhB,EAAoB,IAC7C,IAAI,EAAC,CADiC,AACjC,AAAW,CAAG,CACrB,CACA,OAAQ,CACN,IAAI,EAAC,CAAA,AAAW,GACS,GAAG,CAAxB,IAAI,EAAC,CAAW,AAAX,GACT,IAAI,EAAC,CAAA,AAAiB,CAAG,EAAA,YAAY,CAAC,SAAS,CAAC,MAAO,IACjD,IACF,KADW,CACL,IAAI,CAAC,qBAAqB,GAChC,IAAI,EAAC,CAAA,AAAW,CAAC,OAAO,GAE5B,GACA,IAAI,EAAC,CAAkB,AAAlB,CAAqB,EAAA,aAAa,CAAC,SAAS,CAAC,MAAO,IACnD,IACF,IADU,EACJ,IAAI,CAAC,qBAAqB,GAChC,IAAI,EAAC,CAAA,AAAW,CAAC,QAAQ,GAE7B,GACF,CACA,SAAU,CACR,IAAI,EAAC,CAAA,AAAW,GACS,GAAG,CAAxB,IAAI,EAAC,CAAA,AAAW,GACpB,IAAI,EAAC,CAAA,AAAiB,KACtB,IAAI,EAAC,CAAA,AAAiB,CAAG,KAAK,EAC9B,IAAI,EAAC,CAAkB,AAAlB,KACL,IAAI,EAAC,CAAA,AAAkB,CAAG,KAAK,EACjC,CACA,WAAW,CAAO,CAAE,CAClB,OAAO,IAAI,EAAC,CAAA,AAAW,CAAC,OAAO,CAAC,CAAE,GAAG,CAAO,CAAE,YAAa,UAAW,GAAG,MAAM,AACjF,CACA,WAAW,CAAO,CAAE,CAClB,OAAO,IAAI,EAAC,CAAA,AAAc,CAAC,OAAO,CAAC,CAAE,GAAG,CAAO,CAAE,OAAQ,SAAU,GAAG,MAAM,AAC9E,CAQA,aAAa,CAAQ,CAAE,CACrB,IAAM,EAAU,IAAI,CAAC,mBAAmB,CAAC,CAAE,UAAS,GACpD,OAAO,IAAI,EAAC,CAAA,AAAW,CAAC,GAAG,CAAC,EAAQ,SAAS,GAAG,MAAM,IACxD,CACA,gBAAgB,CAAO,CAAE,CACvB,IAAM,EAAmB,IAAI,CAAC,mBAAmB,CAAC,GAC5C,EAAQ,IAAI,EAAC,CAAA,AAAW,CAAC,KAAK,CAAC,IAAI,CAAE,GACrC,EAAa,EAAM,KAAK,CAAC,IAAI,QACnC,AAAmB,KAAK,GAAG,CAAvB,EACK,IAAI,CAAC,UAAU,CAAC,IAErB,EAAQ,iBAAiB,EAAI,EAAM,aAAa,CAAC,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,EAAiB,SAAS,CAAE,KAC3F,IADoG,AAChG,CAAC,aAAa,CAAC,GAEnB,QAAQ,OAAO,CAAC,GACzB,CACA,eAAe,CAAO,CAAE,CACtB,OAAO,IAAI,EAAC,CAAW,AAAX,CAAY,OAAO,CAAC,GAAS,GAAG,CAAC,CAAC,UAAE,CAAQ,OAAE,CAAK,CAAE,GAExD,CAAC,EADK,EAAM,IAAI,CACA,CAE3B,CACA,aAAa,CAAQ,CAAE,CAAO,CAAE,CAAO,CAAE,CACvC,IAAM,EAAmB,IAAI,CAAC,mBAAmB,CAAC,UAAE,CAAS,GACvD,EAAQ,IAAI,CAAC,CAAA,CAAW,CAAC,GAAG,CAChC,EAAiB,SAAS,EAEtB,EAAW,GAAO,MAAM,KACxB,EAAO,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,EAAS,GACvC,GAAa,KAAK,GAAG,CAAjB,EAGJ,OAAO,IAAI,EAAC,CAAA,AAAW,CAAC,KAAK,CAAC,IAAI,CAAE,GAAkB,OAAO,CAAC,EAAM,CAAE,GAAG,CAAO,CAAE,QAAQ,CAAK,EACjG,CACA,eAAe,CAAO,CAAE,CAAO,CAAE,CAAO,CAAE,CACxC,OAAO,EAAA,aAAa,CAAC,KAAK,CACxB,IAAM,IAAI,EAAC,CAAA,AAAW,CAAC,OAAO,CAAC,GAAS,GAAG,CAAC,CAAC,UAAE,CAAQ,CAAE,GAAK,CAC5D,EACA,IAAI,CAAC,YAAY,CAAC,EAAU,EAAS,GACtC,EAEL,CACA,cAAc,CAAQ,CAAE,CACtB,IAAM,EAAU,IAAI,CAAC,mBAAmB,CAAC,UAAE,CAAS,GACpD,OAAO,IAAI,EAAC,CAAA,AAAW,CAAC,GAAG,CACzB,EAAQ,SAAS,GAChB,KACL,CACA,cAAc,CAAO,CAAE,CACrB,IAAM,EAAa,IAAI,CAAC,CAAA,CAAW,CACnC,EAAA,aAAa,CAAC,KAAK,CAAC,KAClB,EAAW,OAAO,CAAC,GAAS,OAAO,CAAC,AAAC,IACnC,EAAW,MAAM,CAAC,EACpB,EACF,EACF,CACA,aAAa,CAAO,CAAE,CAAO,CAAE,CAC7B,IAAM,EAAa,IAAI,EAAC,CAAA,AAAW,CACnC,OAAO,EAAA,aAAa,CAAC,KAAK,CAAC,KACzB,EAAW,OAAO,CAAC,GAAS,OAAO,CAAC,AAAC,IACnC,EAAM,KAAK,EACb,GACO,IAAI,CAAC,cAAc,CACxB,CACE,KAAM,SACN,GAAG,CAAO,AACZ,EACA,IAGN,CACA,cAAc,CAAO,CAAE,EAAgB,CAAC,CAAC,CAAE,CACzC,IAAM,EAAyB,CAAE,OAAQ,GAAM,GAAG,CAAa,AAAC,EAIhE,OAAO,QAAQ,GAAG,CAAC,AAHF,EAAA,aAAa,CAAC,KAAK,CAClC,IAAM,IAAI,EAAC,CAAW,AAAX,CAAY,OAAO,CAAC,GAAS,GAAG,CAAC,AAAC,GAAU,EAAM,MAAM,CAAC,MAEzC,IAAI,CAAC,EAAA,IAAI,EAAE,KAAK,CAAC,EAAA,IAAI,CACpD,CACA,kBAAkB,CAAO,CAAE,EAAU,CAAC,CAAC,CAAE,CACvC,OAAO,EAAA,aAAa,CAAC,KAAK,CAAC,IAIzB,CAHA,IAAI,EAAC,CAAW,AAAX,CAAY,OAAO,CAAC,GAAS,OAAO,CAAC,AAAC,IACzC,EAAM,UAAU,EAClB,GACI,GAAS,cAAgB,QAAQ,AAC5B,QAAQ,OAAO,GAEjB,IAAI,CAAC,cAAc,CACxB,CACE,GAAG,CAAO,CACV,KAAM,GAAS,aAAe,GAAS,MAAQ,QACjD,EACA,GAGN,CACA,eAAe,CAAO,CAAE,EAAU,CAAC,CAAC,CAAE,CACpC,IAAM,EAAe,CACnB,GAAG,CAAO,CACV,cAAe,EAAQ,aAAa,GAAI,CAC1C,EAUA,OAAO,QAAQ,GAAG,CATD,AASE,EATF,aAAa,CAAC,KAAK,CAClC,IAAM,IAAI,EAAC,CAAA,AAAW,CAAC,OAAO,CAAC,GAAS,MAAM,CAAC,AAAC,GAAU,CAAC,EAAM,UAAU,IAAM,CAAC,EAAM,QAAQ,IAAI,GAAG,CAAC,AAAC,IACvG,IAAI,EAAU,EAAM,KAAK,CAAC,KAAK,EAAG,GAIlC,OAHI,AAAC,EAAa,YAAY,EAAE,CAC9B,EAAU,EAAQ,KAAK,CAAC,EAAA,KAAI,EAEK,WAA5B,EAAM,KAAK,CAAC,WAAW,CAAgB,QAAQ,OAAO,GAAK,CACpE,KAE2B,IAAI,CAAC,EAAA,IAAI,CACxC,CACA,WAAW,CAAO,CAAE,CAClB,IAAM,EAAmB,IAAI,CAAC,mBAAmB,CAAC,EACnB,MAAK,GAAG,CAAnC,EAAiB,KAAK,GACxB,EAAiB,KAAK,EAAG,CAAA,EAE3B,IAAM,EAAQ,IAAI,EAAC,CAAA,AAAW,CAAC,KAAK,CAAC,IAAI,CAAE,GAC3C,OAAO,EAAM,aAAa,CACxB,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,EAAiB,SAAS,CAAE,IAC3C,EAAM,KAAK,CAAC,GAAoB,QAAQ,OAAO,CAAC,EAAM,KAAK,CAAC,IAAI,CACtE,CACA,cAAc,CAAO,CAAE,CACrB,OAAO,IAAI,CAAC,UAAU,CAAC,GAAS,IAAI,CAAC,EAAA,IAAI,EAAE,KAAK,CAAC,EAAA,IAAI,CACvD,CACA,mBAAmB,CAAO,CAAE,CAE1B,OADA,EAAQ,QAAQ,CAAG,EAAsB,EAAQ,KAAK,EAC/C,IAAI,CAAC,UAAU,CAAC,EACzB,CACA,sBAAsB,CAAO,CAAE,CAC7B,OAAO,IAAI,CAAC,kBAAkB,CAAC,GAAS,IAAI,CAAC,EAAA,IAAI,EAAE,KAAK,CAAC,EAAA,IAAI,CAC/D,CACA,wBAAwB,CAAO,CAAE,CAE/B,OADA,EAAQ,QAAQ,CAAG,EAAsB,EAAQ,KAAK,EAC/C,IAAI,CAAC,eAAe,CAAC,EAC9B,CACA,uBAAwB,QACtB,AAAI,EAAA,aAAa,CAAC,QAAQ,GACjB,CADqB,GACjB,EAAC,CAAA,AAAc,CAAC,qBAAqB,GAE3C,QAAQ,OAAO,EACxB,CACA,eAAgB,CACd,OAAO,IAAI,EAAC,CAAA,AAAW,AACzB,CACA,kBAAmB,CACjB,OAAO,IAAI,EAAC,CAAA,AAAc,AAC5B,CACA,mBAAoB,CAClB,OAAO,IAAI,EAAC,CAAA,AAAe,AAC7B,CACA,kBAAkB,CAAO,CAAE,CACzB,IAAI,EAAC,CAAe,AAAf,CAAkB,CACzB,CACA,iBAAiB,CAAQ,CAAE,CAAO,CAAE,CAClC,IAAI,EAAC,CAAA,AAAc,CAAC,GAAG,CAAC,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAW,UACzC,EACA,eAAgB,CAClB,EACF,CACA,iBAAiB,CAAQ,CAAE,CACzB,IAAM,EAAW,IAAI,IAAI,CAAC,CAAA,CAAc,CAAC,MAAM,GAAG,CAC5C,EAAS,CAAC,EAMhB,OALA,EAAS,OAAO,CAAC,AAAC,IACZ,CAAA,EAAA,EAAA,eAAA,AAAe,EAAC,EAAU,EAAa,QAAQ,GAAG,AACpD,OAAO,MAAM,CAAC,EAAQ,EAAa,cAAc,CAErD,GACO,CACT,CACA,oBAAoB,CAAW,CAAE,CAAO,CAAE,CACxC,IAAI,EAAC,CAAA,AAAiB,CAAC,GAAG,CAAC,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAc,aAC/C,EACA,eAAgB,CAClB,EACF,CACA,oBAAoB,CAAW,CAAE,CAC/B,IAAM,EAAW,IAAI,IAAI,EAAC,CAAA,AAAiB,CAAC,MAAM,GAAG,CAC/C,EAAS,CAAC,EAMhB,OALA,EAAS,OAAO,CAAC,AAAC,IACZ,CAAA,EAAA,EAAA,eAAA,AAAe,EAAC,EAAa,EAAa,WAAW,GAAG,AAC1D,OAAO,MAAM,CAAC,EAAQ,EAAa,cAAc,CAErD,GACO,CACT,CACA,oBAAoB,CAAO,CAAE,CAC3B,GAAI,EAAQ,UAAU,CACpB,CADsB,MACf,EAET,IAAM,EAAmB,CACvB,GAAG,IAAI,EAAC,CAAA,AAAe,CAAC,OAAO,CAC/B,GAAG,IAAI,CAAC,gBAAgB,CAAC,EAAQ,QAAQ,CAAC,CAC1C,GAAG,CAAO,CACV,YAAY,CACd,EAmBA,OAlBI,AAAC,EAAiB,SAAS,EAAE,CAC/B,EAAiB,SAAS,CAAG,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAChD,EAAiB,QAAQ,CACzB,EAAA,EAGA,AAAwC,KAAK,GAAG,GAA/B,kBAAkB,GACrC,EAAiB,kBAAkB,CAAG,AAAiC,aAAhB,WAAW,AAAK,EAEnC,AAAlC,KAAuC,GAAG,GAAzB,YAAY,GAC/B,EAAiB,YAAY,CAAG,CAAC,CAAC,EAAiB,QAAA,AAAQ,EAEzD,CAAC,EAAiB,WAAW,EAAI,EAAiB,SAAS,EAAE,CAC/D,EAAiB,WAAW,CAAG,cAAA,EAE7B,EAAiB,OAAO,GAAK,EAAA,SAAS,EAAE,CAC1C,EAAiB,OAAO,EAAG,CAAA,EAEtB,CACT,CACA,uBAAuB,CAAO,CAAE,QAC9B,AAAI,GAAS,WACJ,CADgB,CAGlB,CACL,GAAG,IAAI,EAAC,CAAe,AAAf,CAAgB,SAAS,CACjC,GAAG,GAAS,aAAe,IAAI,CAAC,mBAAmB,CAAC,EAAQ,WAAW,CAAC,CACxE,GAAG,CAAO,CACV,YAAY,CACd,CACF,CACA,OAAQ,CACN,IAAI,CAAC,CAAA,CAAW,CAAC,KAAK,GACtB,IAAI,EAAC,CAAA,AAAc,CAAC,KAAK,EAC3B,CACF,4CI7PM,SAAU,EAAqB,CAAsB,CAAE,CAAU,ICmFjB,IDlFpD,CAAI,WA5Ca,CAAM,CAAE,CAAM,CEFT,ADAA,CEAC,AHGvB,CEHwB,EACnB,ACAA,AHED,CAAC,AIFE,AFEP,ACFO,AFAA,CGDqB,EACrB,ADDuB,ADAA,CCAC,CHGlB,CGDN,ADGA,CDL2B,IDGd,GAEpB,GAAI,CAAC,AGDE,EHCE,GAAkB,UAAb,OAAA,CELsD,CAAC,CFKjB,UAAb,OAAO,CAAC,CAAe,CAAC,MAIzD,CAAS,CAAC,AAHd,GAAA,EAAM,WAAW,CGAK,EAAE,AHAF,EAAE,EGAM,SAAA,CHAO,OAAO,KAAK,AAK7C,CAL8C,KAKxC,OAAO,CAAC,CAAC,CAAC,EKHM,ALGF,EOSM,GPTD,CAAC,OAAO,CAAC,CAAC,CAAC,CAAE,CAAC,AAEzC,CM+C0C,CAC7C,CAAC,ANhDM,GADK,CAAC,CAAC,MAAA,IACI,CAAC,CAAA,MAAA,CAAA,OAAgB,KAAK,CAAC,AACjC,CAAC,CAAA,EAAY,GAAD,CAAC,IAAA,GAAgB,CAAC,CGKrB,CHL+B,CAAC,CAAC,EAAA,CAAI,CAAC,CAAC,CGMlD,AHNmD,CAAA,EAAI,OAAO,SAC1D,KAGL,CAAC,CAAC,OAAO,GAAK,OAAO,SAAS,CAAC,OAAO,CACxC,OAAA,EAAS,OAAA,KAAc,CAAC,CAAC,OAAA,MACvB,EAAE,QAAQ,GAAK,OAAO,SAAS,CAAA,QAAS,CGQJ,OAAA,EAAA,QHPrB,KAAO,CAAC,CAAC,QAAQ,GAEpC,IAAA,EAAA,OAAoB,IAAA,CAAA,GAEpB,GAAA,CADA,EAAS,EAAK,CIoGE,CJpGH,IAAC,AAAM,CAAC,GACrB,OAAsB,IAAI,CAAC,CAAC,CAAC,AEWR,CFXS,MAAA,CAAQ,OAAO,EAE7C,IAAK,EAAI,EAAQ,AAAC,CAAA,EAChB,QACI,CAAC,OAAO,MAAM,CAAC,EAAA,CAAO,CAAA,EAAI,EAAG,MAAA,CAAA,EAEnC,IAAK,CAAC,CAAG,EAAS,GAAD,CAAC,IAAA,CAChB,IAAM,EAAM,CAAH,AAAO,AAJgD,CAI/C,CAAC,CAAA,IAEd,GAAO,CAAC,EAAU,CAAA,CAAA,EAAM,CCoFO,CDpFJ,CAAC,EAAG,CGON,AHPM,CAAI,OAAO,EAGhD,OAAO,CACT,CAAC,OAIM,GAAM,CAAC,EAAI,CAAC,EAAK,GAIpB,EAAmB,MAGhB,EAAA,EAH0B,CAAC,aAG3B,EAAiB,EAAS,GAFxB,IAE+B,CAAM,CAAC,QOoBK,kCJvDhD,SAAA,EAA+B,CAGpC,EACC,GAAM,CAAC,EAAI,EAAA,CAAA,CAAA,EAAA,EAAA,QAAA,AAAiB,EAAkB,CC+F0B,KD9FlE,CAAC,EAAY,CEuCI,CAAA,EFvCD,EAAA,QAAA,EACpB,IACE,CHPwD,GGOpD,EAAY,CACd,QADa,OACb,CACE,UAAW,CHRH,AGSN,UAAW,CAAC,EAAM,EAAF,AAAU,KGiCpC,CAAA,EAAA,CHjC6C,CGiC7C,CHjC+C,EAAE,aGiCjD,EHhCyC,EGiCf,CAAC,SHjC0B,CAAC,CIIO,ED6BrB,CAAC,EAAA,CAAA,EAAA,EHlD4B,SAAD,CAAC,MAAA,EGmDlD,EDpDM,ACoDA,GHlDG,AGkDJ,OAAW,CAAE,CAAC,SAAS,CAAE,OAAO,CAAC,CAAC,AHlDI,EGmDxB,AHnDwB,UAAA,OGmDrD,EAAM,ANjDJ,UMiDc,CAAA,OAAQ,KHjCjB,EAAA,gBAAA,EAAiB,CHRK,CAAC,AGQF,CAAG,CAAH,gBAAoB,CAAC,CAAC,EAAA,CAAA,EAC3C,EHRW,GAAA,aAAA,EGQM,EAAW,CAAC,QAAQ,CAAE,OAAO,CAAC,CAAC,EAChD,CAAC,EACD,EAAA,cAAA,AAAc,EAAC,OACN,EAAU,KAAK,CACtB,CADgB,AAAQ,MAChB,CDDrB,CAAE,CAAA,KCCmC,CACxB,gBAAiB,CAFuC,CAElC,KEoCiB,QHjCP,EAAA,GCD/B,KAAK,CAAC,AAAC,CAAC,EAAE,SAED,KAAA,CAAM,sBAAuB,CAAC,CACxC,AADyC,CAAC,AACzC,AHT+B,EAAA,IAAA,CAAA,IGWvB,QAAQ,GAAA,CAAI,CACjB,EAAY,CIUG,APjBN,AAAU,gBGOU,CAAC,CAC5B,QAAQ,CAEN,CADA,AAEE,cAAc,CACd,EAAU,UAAU,EAAE,KAAK,CAAC,EAAE,EAC5B,EAAU,KAAK,CAAC,EAAE,CACpB,EAAU,UAAU,EAAE,OAAO,AALwC,EAKpC,EAAU,EAAE,CACrC,IADkC,EAGhD,EAAA,uBAAA,AAAuB,EACrB,EACA,EAAU,OADC,AACF,GAAW,EAAE,KAAK,CAAC,EAAE,EAAI,EAAU,KAAK,CAAC,CAAP,CAAS,CACrD,CACF,CEmCW,AFnCV,CAAC,AAIb,WAEO,CAGP,SAAS,CAAE,EAAE,CEsCK,EFtCF,IAAI,aACpB,uBAOP,EAAA,oBAAA,CAAA,QAA6B,CAAA,CAAC,KAAK,CAAE,EAAM,GAAD,IAAQ,CAAA,SAAA,CAAA,EACjD,EAAA,IAAA,EAAC,EAAA,mBAAmB,CAAA,CAAC,MAAM,CAAE,EAAW,SAAA,IACtC,EAAA,GAAA,EAAC,EAAA,qBAAqB,CAAC,QAAQ,CAAA,CAAC,KAAK,CAAE,EAAK,GAAA,MACzC,EAAM,GAAD,KAAS,EACgB,CAChC,EAAE,EACiB,EACQ,CACjC,CAAC,QDvDY,EFFF,CEKV,EAEF,IAAM,EAAA,CAAA,EAAoB,EAAA,OAAA,AAAO,EAAA,IACzB,EAAM,GAAD,ACCsB,cDDJ,EAAA,CAAA,EAAI,EAAA,uBAAA,AAAuB,EAAC,EAAA,eAAe,CAAC,CACzE,CAAC,EAAM,GAAD,cAAkB,CAAC,CAC1B,CAAC,SAGA,EAAA,GAAA,EAAC,CFXS,CAAA,CEWY,QAAS,GCHM,QDIlC,EAAM,GAAD,KAAS,EACM,CACxB,CAAC","ignoreList":[0,1,7,8,9,12,13,14,15,16,21,22,23,24,25,26,30,31,32,36,37,38,39,40,41,42,43,44,45,46,47]}