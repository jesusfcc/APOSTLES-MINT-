{"version":3,"sources":["../../../../node_modules/abitype/src/human-readable/parseAbiItem.ts","../../../../node_modules/thirdweb/src/utils/abi/encodeAbiParameters.ts","../../../../node_modules/thirdweb/src/utils/encoding/helpers/byte-size.ts","../../../../node_modules/thirdweb/src/utils/abi/prepare-method.ts","../../../../node_modules/thirdweb/src/transaction/actions/estimate-gas-cost.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/zora-sepolia.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/base.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/optimism.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/base-sepolia.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/optimism-sepolia.ts","../../../../node_modules/thirdweb/src/chains/chain-definitions/zora.ts","../../../../node_modules/thirdweb/src/chains/constants.ts","../../../../node_modules/thirdweb/src/transaction/utils.ts","../../../../node_modules/thirdweb/src/rpc/actions/eth_call.ts","../../../../node_modules/thirdweb/src/transaction/read-contract.ts","../../../../node_modules/thirdweb/src/utils/bytecode/detectExtension.ts","../../../../node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/read/decimals.ts","../../../../node_modules/thirdweb/src/extensions/erc20/read/decimals.ts"],"sourcesContent":["import type { Abi } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiItemError } from './errors/abiItem.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signature, Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * type Result = ParseAbiItem<\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n> =\n  | (signature extends string\n      ? string extends signature\n        ? Abi[number]\n        : signature extends Signature<signature> // Validate signature\n          ? ParseSignature<signature>\n          : never\n      : never)\n  | (signature extends readonly string[]\n      ? string[] extends signature\n        ? Abi[number] // Return generic Abi item since type was no inferrable\n        : signature extends Signatures<signature> // Validate signature\n          ? ParseStructs<signature> extends infer structs\n            ? {\n                [key in keyof signature]: ParseSignature<\n                  signature[key] extends string ? signature[key] : never,\n                  structs\n                >\n              } extends infer mapped extends readonly unknown[]\n              ? // Filter out `never` since those are structs\n                Filter<mapped, never>[0] extends infer result\n                ? result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\n                  ? never\n                  : result\n                : never\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n>(\n  signature: Narrow<signature> &\n    (\n      | (signature extends string\n          ? string extends signature\n            ? unknown\n            : Signature<signature>\n          : never)\n      | (signature extends readonly string[]\n          ? signature extends readonly [] // empty array\n            ? Error<'At least one signature required.'>\n            : string[] extends signature\n              ? unknown\n              : Signatures<signature>\n          : never)\n    ),\n): ParseAbiItem<signature> {\n  let abiItem: ParseAbiItem<signature> | undefined\n  if (typeof signature === 'string')\n    abiItem = parseSignature(signature) as ParseAbiItem<signature>\n  else {\n    const structs = parseStructs(signature as readonly string[])\n    const length = signature.length as number\n    for (let i = 0; i < length; i++) {\n      const signature_ = (signature as readonly string[])[i]!\n      if (isStructSignature(signature_)) continue\n      abiItem = parseSignature(signature_, structs) as ParseAbiItem<signature>\n      break\n    }\n  }\n\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\n  return abiItem as ParseAbiItem<signature>\n}\n","import type {\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from \"abitype\";\nimport * as ox__Hex from \"ox/Hex\";\nimport { isAddress } from \"../address.js\";\nimport { byteSize } from \"../encoding/helpers/byte-size.js\";\nimport {\n  boolToHex,\n  type Hex,\n  numberToHex,\n  padHex,\n  stringToHex,\n} from \"../encoding/hex.js\";\n\n/**\n * Encodes the given ABI parameters and values into a hexadecimal string.\n * @template TParams - The type of the ABI parameters.\n * @param params - The ABI parameters.\n * @param values - The corresponding values for the ABI parameters.\n * @returns - The encoded ABI parameters as a hexadecimal string.\n * @throws {Error} - If the number of parameters and values do not match.\n * @example\n * ```ts\n * import { encodeAbiParameters } from \"thirdweb/utils\";\n *\n * const params = [\n *  { name: \"param1\", type: \"uint256\" },\n *  { name: \"param2\", type: \"string\" },\n * ];\n * const values = [123, \"hello\"];\n *\n * const data = encodeAbiParameters(params, values);\n * console.log(data);\n * ```\n * @utils\n */\nexport function encodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: TParams,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): Hex {\n  if (params.length !== values.length) {\n    throw new Error(\"The number of parameters and values must match.\");\n  }\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) {\n    return \"0x\";\n  }\n  return data;\n}\n\n//UTILS\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex };\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] };\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>;\n\nfunction prepareParams<const TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: TParams;\n  values: AbiParametersToPrimitiveTypes<TParams>;\n}) {\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < params.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    preparedParams.push(prepareParam({ param: params[i]!, value: values[i] }));\n  }\n  return preparedParams;\n}\n\n/**\n * @internal Export for unit test\n */\nexport function prepareParam<const TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam;\n  value: AbiParameterToPrimitiveType<TParam>;\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, { length, param: { ...param, type } });\n  }\n  if (param.type === \"tuple\") {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    });\n  }\n  if (param.type === \"address\") {\n    return encodeAddress(value as unknown as Hex);\n  }\n  if (param.type === \"bool\") {\n    return encodeBool(value as unknown as boolean);\n  }\n  if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\n    const signed = param.type.startsWith(\"int\");\n    return encodeNumber(value as unknown as number, { signed });\n  }\n  if (param.type.startsWith(\"bytes\")) {\n    return encodeBytes(value as unknown as Hex, { param });\n  }\n  if (param.type === \"string\") {\n    return encodeString(value as unknown as string);\n  }\n  throw new Error(`Unsupported parameter type: ${param.type}`);\n}\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticSize += 32;\n    } else {\n      staticSize += byteSize(encoded);\n    }\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = [];\n  const dynamicParams: Hex[] = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n      dynamicParams.push(encoded);\n      dynamicSize += byteSize(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return ox__Hex.concat(...[...staticParams, ...dynamicParams]);\n}\n\n/////////////////////////////////////////////////////////////////\n\n/**\n * @internal Export for unit test\n */\nexport function encodeAddress(value: Hex): PreparedParam {\n  // We allow empty strings for deployment transactions where there is no to address\n  if ((value as string) !== \"\" && value !== undefined && !isAddress(value)) {\n    throw new Error(`Invalid address: ${value}`);\n  }\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) };\n}\n\nfunction encodeArray<const TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null;\n    param: TParam;\n  },\n): PreparedParam {\n  const dynamic = length === null;\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Invalid array value.\");\n  }\n  if (!dynamic && value.length !== length) {\n    throw new Error(\"Invalid array length.\");\n  }\n\n  let dynamicChild = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] });\n    if (preparedParam.dynamic) {\n      dynamicChild = true;\n    }\n    preparedParams.push(preparedParam);\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length_ = numberToHex(preparedParams.length, { size: 32 });\n      return {\n        dynamic: true,\n        encoded:\n          preparedParams.length > 0\n            ? ox__Hex.concat(...[length_, data])\n            : length_,\n      };\n    }\n    if (dynamicChild) {\n      return { dynamic: true, encoded: data };\n    }\n  }\n  return {\n    dynamic: false,\n    encoded: ox__Hex.concat(...preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction encodeBytes<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split(\"bytes\");\n  const bytesSize = byteSize(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) {\n      value_ = padHex(value_, {\n        dir: \"right\",\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      });\n    }\n    return {\n      dynamic: true,\n      encoded: ox__Hex.concat(\n        ...[padHex(numberToHex(bytesSize, { size: 32 })), value_],\n      ),\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) {\n    throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);\n  }\n  return { dynamic: false, encoded: padHex(value, { dir: \"right\" }) };\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      signed,\n      size: 32,\n    }),\n  };\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(byteSize(hexValue) / 32);\n  const parts: Hex[] = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(ox__Hex.slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: \"right\",\n      }),\n    );\n  }\n  return {\n    dynamic: true,\n    encoded: ox__Hex.concat(\n      ...[padHex(numberToHex(byteSize(hexValue), { size: 32 })), ...parts],\n    ),\n  };\n}\n\nfunction encodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < param.components.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const param_ = param.components[i]!;\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      value: (value as any)[index!] as readonly unknown[],\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) {\n      dynamic = true;\n    }\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : ox__Hex.concat(...preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      [matches[2] ? Number(matches[2]) : null, matches[1]!]\n    : undefined;\n}\n","import { type Hex, isHex } from \"../hex.js\";\n\n/**\n * Calculates the byte size of a Hex string or Uint8Array.\n * If the value is a Hex string, it accounts for the leading \"0x\" prefix.\n * @param value The Hex string or Uint8Array.\n * @returns The byte size of the value.\n * @example\n * ```ts\n * import { byteSize } from \"thirdweb/utils\";\n * const size = byteSize(\"0x1a4\");\n * console.log(size); // 2\n * ```\n */\nexport function byteSize(value: Hex | Uint8Array) {\n  if (isHex(value, { strict: false })) {\n    return Math.ceil((value.length - 2) / 2);\n  }\n  return value.length;\n}\n","import { type AbiFunction, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { LruMap } from \"../caching/lru.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringify } from \"../json.js\";\n\ntype ParseMethod<method extends AbiFunction | `function ${string}`> =\n  // if the method IS an AbiFunction, return it\n  method extends AbiFunction\n    ? method\n    : method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : never;\n\nexport type PreparedMethod<TMethod extends AbiFunction | `function ${string}`> =\n  // [\"fn signature\", \"inputs\", \"outputs\"]\n  [Hex, ParseMethod<TMethod>[\"inputs\"], ParseMethod<TMethod>[\"outputs\"]];\n\nconst prepareMethodCache = new LruMap<PreparedMethod<AbiFunction>>(4096);\n\n/**\n * Prepares a method for usage by converting it into a prepared method object.\n * @param method The method to prepare.\n * @returns The prepared method object.\n * @example\n * ```ts\n * import { prepareMethod } from \"thirdweb/utils\";\n * const method = \"function transfer(address to, uint256 value)\";\n * const preparedMethod = prepareMethod(method);\n * ```\n * @contract\n */\nexport function prepareMethod<\n  const TMethod extends AbiFunction | `function ${string}`,\n>(method: TMethod): PreparedMethod<TMethod> {\n  const key = typeof method === \"string\" ? method : stringify(method);\n  if (prepareMethodCache.has(key)) {\n    return prepareMethodCache.get(key) as PreparedMethod<TMethod>;\n  }\n  type ParsedAbiFn = ParseMethod<TMethod>;\n\n  const abiFn =\n    typeof method === \"string\"\n      ? // @ts-expect-error - we're sure it's a string...\n        (parseAbiItem(method) as ParsedAbiFn)\n      : (method as ParsedAbiFn);\n\n  // encode the method signature\n  const sig = toFunctionSelector(abiFn);\n\n  const ret: PreparedMethod<TMethod> = [sig, abiFn.inputs, abiFn.outputs];\n  prepareMethodCache.set(key, ret);\n  return ret;\n}\n","import { isOpStackChain } from \"../../chains/constants.js\";\nimport { getDefaultGasOverrides } from \"../../gas/fee-data.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { toEther } from \"../../utils/units.js\";\nimport { type EstimateGasOptions, estimateGas } from \"./estimate-gas.js\";\n\nexport type EstimateGasCostResult = {\n  /**\n   * The estimated gas cost in ether.\n   */\n  ether: string;\n  /**\n   * The estimated gas cost in wei.\n   */\n  wei: bigint;\n};\n\n/**\n * Estimate the gas cost of a transaction in ether and wei.\n * @example\n * ```ts\n * import { estimateGasCost } from \"thirdweb\";\n *\n * const gasCost = await estimateGasCost({ transaction });\n * ```\n * @transaction\n */\nexport async function estimateGasCost(\n  options: EstimateGasOptions,\n): Promise<EstimateGasCostResult> {\n  const { transaction } = options;\n  const from = options.from ?? options.account?.address ?? undefined;\n  const gasLimit =\n    (await resolvePromisedValue(transaction.gas)) ||\n    (await estimateGas({ from, transaction }));\n  const fees = await getDefaultGasOverrides(\n    transaction.client,\n    transaction.chain,\n  );\n  const gasPrice = fees.maxFeePerGas || fees.gasPrice;\n  if (gasPrice === undefined) {\n    throw new Error(\n      `Unable to determine gas price for chain ${transaction.chain.id}`,\n    );\n  }\n  let l1Fee: bigint;\n  if (await isOpStackChain(transaction.chain)) {\n    const { estimateL1Fee } = await import(\"../../gas/estimate-l1-fee.js\");\n    l1Fee = await estimateL1Fee({\n      transaction,\n    });\n  } else {\n    l1Fee = 0n;\n  }\n  const wei = gasLimit * gasPrice + l1Fee;\n  return {\n    ether: toEther(wei),\n    wei,\n  };\n}\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const zoraSepolia = /*@__PURE__*/ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://sepolia.explorer.zora.energy/api\",\n      name: \"Zora Sepolia Explorer\",\n      url: \"https://sepolia.explorer.zora.energy/\",\n    },\n  ],\n  id: 999999999,\n  name: \"Zora Sepolia\",\n\n  nativeCurrency: {\n    decimals: 18,\n    name: \"Zora Sepolia\",\n    symbol: \"ETH\",\n  },\n  testnet: true,\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const base = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://api.basescan.org/api\",\n      name: \"Basescan\",\n      url: \"https://basescan.org\",\n    },\n  ],\n  id: 8453,\n  name: \"Base\",\n  nativeCurrency: { decimals: 18, name: \"Ether\", symbol: \"ETH\" },\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const optimism = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://api-optimistic.etherscan.io\",\n      name: \"Optimism Explorer\",\n      url: \"https://optimistic.etherscan.io\",\n    },\n  ],\n  id: 10,\n  name: \"OP Mainnet\",\n  nativeCurrency: { decimals: 18, name: \"Ether\", symbol: \"ETH\" },\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const baseSepolia = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://api-sepolia.basescan.org/api\",\n      name: \"Basescan\",\n      url: \"https://sepolia.basescan.org\",\n    },\n  ],\n  id: 84532,\n  name: \"Base Sepolia\",\n  nativeCurrency: { decimals: 18, name: \"Sepolia Ether\", symbol: \"ETH\" },\n  testnet: true,\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const optimismSepolia = /* @__PURE__ */ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://optimism-sepolia.blockscout.com/api\",\n      name: \"Blockscout\",\n      url: \"https://optimism-sepolia.blockscout.com\",\n    },\n  ],\n  id: 11155420,\n  name: \"OP Sepolia\",\n  nativeCurrency: { decimals: 18, name: \"Sepolia Ether\", symbol: \"ETH\" },\n  testnet: true,\n});\n","import { defineChain } from \"../utils.js\";\n\n/**\n * @chain\n */\nexport const zora = /*@__PURE__*/ defineChain({\n  blockExplorers: [\n    {\n      apiUrl: \"https://explorer.zora.energy/api\",\n      name: \"Explorer\",\n      url: \"https://explorer.zora.energy\",\n    },\n  ],\n  id: 7777777,\n  name: \"Zora\",\n  nativeCurrency: {\n    decimals: 18,\n    name: \"Ether\",\n    symbol: \"ETH\",\n  },\n});\n","import { base } from \"./chain-definitions/base.js\";\nimport { baseSepolia } from \"./chain-definitions/base-sepolia.js\";\nimport { optimism } from \"./chain-definitions/optimism.js\";\nimport { optimismSepolia } from \"./chain-definitions/optimism-sepolia.js\";\nimport { zora } from \"./chain-definitions/zora.js\";\nimport { zoraSepolia } from \"./chain-definitions/zora-sepolia.js\";\nimport type { Chain } from \"./types.js\";\n\nconst opChains = [\n  base.id,\n  baseSepolia.id,\n  optimism.id,\n  optimismSepolia.id,\n  zora.id,\n  zoraSepolia.id,\n  34443, // mode\n  919, // mode testnet\n  42220, // celo\n  44787, // celo testnet\n  204, // opBNB\n  5611, // opBNB testnet\n];\n\n/**\n * TODO this should be in the chain definition itself\n * @internal\n */\nexport async function isOpStackChain(chain: Chain) {\n  if (chain.id === 1337 || chain.id === 31337) {\n    return false;\n  }\n\n  if (opChains.includes(chain.id)) {\n    return true;\n  }\n  // fallback to checking the stack on rpc\n  try {\n    const { getChainMetadata } = await import(\"./utils.js\");\n    const chainMetadata = await getChainMetadata(chain);\n    return chainMetadata.stackType === \"optimism_bedrock\";\n  } catch {\n    // If the network check fails, assume it's not a OP chain\n    return false;\n  }\n}\n","import type { AbiFunction } from \"abitype\";\nimport { getGasPrice } from \"../gas/get-gas-price.js\";\nimport { estimateGasCost } from \"./actions/estimate-gas-cost.js\";\nimport type { PreparedTransaction } from \"./prepare-transaction.js\";\n\n/**\n * @internal\n */\nexport function isAbiFunction(item: unknown): item is AbiFunction {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"function\"\n  );\n}\n\nexport async function getTransactionGasCost(\n  tx: PreparedTransaction,\n  from?: string,\n) {\n  try {\n    const gasCost = await estimateGasCost({\n      from,\n      transaction: tx,\n    });\n\n    const bufferCost = gasCost.wei / 10n;\n\n    // Note: get tx.value AFTER estimateGasCost\n    // add 10% extra gas cost to the estimate to ensure user buys enough to cover the tx cost\n    return gasCost.wei + bufferCost;\n  } catch {\n    if (from) {\n      // try again without passing from\n      return await getTransactionGasCost(tx);\n    }\n    // fallback if both fail, use the tx value + 1M * gas price\n    const gasPrice = await getGasPrice({\n      chain: tx.chain,\n      client: tx.client,\n    });\n\n    return 1_000_000n * gasPrice;\n  }\n}\n","import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          code: override.code,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { decodeAbiParameters, type TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n    from?: string;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    from: options.from ? getAddress(options.from) : undefined,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n","import type { AbiFunction } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport type { PreparedMethod } from \"../abi/prepare-method.js\";\n\ntype DetectExtensionOptions = {\n  method: string | AbiFunction | PreparedMethod<AbiFunction>;\n  availableSelectors: string[];\n};\n\n/**\n * Detects if the specified method is present in the contract bytecode.\n * @param options - The options for detecting the extension.\n * @returns A promise that resolves to a boolean indicating if the extension is detected.\n * @example\n * ```ts\n * import { detectMethod } from \"thirdweb/utils/extensions/detect.js\";\n * const hasDecimals = await detectMethod({\n *  method: \"function decimals() view returns (uint8)\",\n *  availableSelectors: [\"0x313ce567\"],\n * });\n * ```\n * @contract\n */\nexport function detectMethod(options: DetectExtensionOptions): boolean {\n  const fnSelector = Array.isArray(options.method)\n    ? options.method[0]\n    : toFunctionSelector(options.method);\n\n  return options.availableSelectors.includes(fnSelector);\n}\n","import { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\nexport const FN_SELECTOR = \"0x313ce567\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint8\",\n  },\n] as const;\n\n/**\n * Checks if the `decimals` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `decimals` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isDecimalsSupported } from \"thirdweb/extensions/erc20\";\n * const supported = isDecimalsSupported([\"0x...\"]);\n * ```\n */\nexport function isDecimalsSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the decimals function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC20\n * @example\n * ```ts\n * import { decodeDecimalsResult } from \"thirdweb/extensions/erc20\";\n * const result = decodeDecimalsResultResult(\"...\");\n * ```\n */\nexport function decodeDecimalsResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"decimals\" function on the contract.\n * @param options - The options for the decimals function.\n * @returns The parsed result of the function call.\n * @extension ERC20\n * @example\n * ```ts\n * import { decimals } from \"thirdweb/extensions/erc20\";\n *\n * const result = await decimals({\n *  contract,\n * });\n *\n * ```\n */\nexport async function decimals(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n","import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { decimals as generatedDecimals } from \"../__generated__/IERC20/read/decimals.js\";\n\nexport { isDecimalsSupported } from \"../__generated__/IERC20/read/decimals.js\";\n\n/**\n * Retrieves the number of decimal places for a given ERC20 contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the number of decimal places.\n * @extension ERC20\n * @example\n * ```ts\n * import { decimals } from \"thirdweb/extensions/erc20\";\n *\n * const tokenDecimals = await decimals({ contract });\n * ```\n */\nexport async function decimals(\n  options: BaseTransactionOptions,\n): Promise<number> {\n  return withCache(() => generatedDecimals(options), {\n    cacheKey: `${options.contract.chain.id}:${options.contract.address}:decimals`,\n    // can never change, so cache forever\n    cacheTime: Number.POSITIVE_INFINITY,\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,4,5,6,7,8,9,10,11,12,13,14]}